<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Skeleton Physics - WebAssembly Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: hidden;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 12px;
            color: white;
            text-align: center;
            z-index: 1000;
        }
        
        #loading.hidden {
            display: none;
        }
        
        .spinner {
            border: 4px solid rgba(77, 166, 255, 0.3);
            border-top: 4px solid #4da6ff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            color: white;
            max-width: 320px;
            max-height: 90vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        #controls h2 {
            margin-bottom: 15px;
            font-size: 20px;
            color: #4da6ff;
            border-bottom: 2px solid #4da6ff;
            padding-bottom: 8px;
        }
        
        #controls h3 {
            margin-top: 15px;
            margin-bottom: 10px;
            font-size: 14px;
            color: #80c0ff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #b0d0ff;
        }
        
        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: linear-gradient(135deg, #4da6ff 0%, #3d85cc 100%);
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(77, 166, 255, 0.3);
        }
        
        button:hover:not(:disabled) {
            background: linear-gradient(135deg, #5bb6ff 0%, #4d95dc 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(77, 166, 255, 0.4);
        }
        
        button:active:not(:disabled) {
            transform: translateY(0);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 8px 0;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
        }
        
        input[type="range"]::-webkit-slider-track {
            background: rgba(77, 166, 255, 0.3);
            height: 4px;
            border-radius: 2px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            background: #4da6ff;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -6px;
        }
        
        input[type="checkbox"] {
            margin-right: 8px;
        }
        
        .value-display {
            float: right;
            font-weight: 600;
            color: #4da6ff;
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 12px;
            color: white;
            font-size: 12px;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }
        
        #info div {
            margin: 5px 0;
        }
        
        .info-label {
            color: #80c0ff;
            font-weight: 600;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            margin: 8px 0;
            cursor: pointer;
            font-size: 13px;
        }
        
        .checkbox-label input {
            cursor: pointer;
        }

        .wasm-badge {
            display: inline-block;
            background: linear-gradient(135deg, #654ea3 0%, #eaafc8 100%);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: bold;
            letter-spacing: 1px;
            margin-left: 8px;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(77, 166, 255, 0.5);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(77, 166, 255, 0.7);
        }
    </style>
</head>
<body>
    <div id="loading">
        <h2>Loading Skeleton Physics</h2>
        <div class="spinner"></div>
        <p id="load-status">Initializing WebAssembly module...</p>
    </div>
    
    <div id="canvas-container"></div>
    
    <div id="controls">
        <h2>ðŸ¦´ Skeleton Physics <span class="wasm-badge">WASM</span></h2>
        
        <h3>Poses</h3>
        <button id="btn-apose">A-Pose (Rest)</button>
        <button id="btn-tpose">T-Pose</button>
        <button id="btn-sit">Sitting</button>
        <button id="btn-squat">Deep Squat</button>
        <button id="btn-reach">Reach Forward</button>
        <button id="btn-wave">Wave</button>
        
        <h3>Physics Settings</h3>
        <div class="control-group">
            <label class="checkbox-label">
                <input type="checkbox" id="chk-physics" checked>
                Enable Physics Simulation
            </label>
            <label class="checkbox-label">
                <input type="checkbox" id="chk-gravity" checked>
                Enable Gravity
            </label>
        </div>
        
        <div class="control-group">
            <label>
                Joint Stiffness <span class="value-display" id="val-stiffness">100</span>
            </label>
            <input type="range" id="slider-stiffness" min="10" max="500" value="100" step="10">
        </div>
        
        <div class="control-group">
            <label>
                Joint Damping <span class="value-display" id="val-damping">20</span>
            </label>
            <input type="range" id="slider-damping" min="5" max="100" value="20" step="5">
        </div>
        
        <h3>Visualization</h3>
        <div class="control-group">
            <label class="checkbox-label">
                <input type="checkbox" id="chk-bones" checked>
                Show Bones
            </label>
            <label class="checkbox-label">
                <input type="checkbox" id="chk-joints" checked>
                Show Joints
            </label>
            <label class="checkbox-label">
                <input type="checkbox" id="chk-limits">
                Show Joint Limits
            </label>
            <label class="checkbox-label">
                <input type="checkbox" id="chk-com">
                Show Center of Mass
            </label>
            <label class="checkbox-label">
                <input type="checkbox" id="chk-ik-targets">
                Show IK Targets
            </label>
        </div>
        
        <h3>Tests</h3>
        <button id="btn-test-shoulder">Test Shoulder Range</button>
        <button id="btn-test-elbow">Test Elbow</button>
        <button id="btn-test-knee">Test Knee</button>
        <button id="btn-reset">Reset Pose</button>
        
        <h3>Performance</h3>
        <div id="perf-info" style="font-size: 11px; color: #80c0ff;">
            <div>Physics: <span id="perf-physics">0.0ms</span></div>
            <div>Render: <span id="perf-render">0.0ms</span></div>
            <div>Total: <span id="perf-total">0.0ms</span></div>
        </div>
    </div>
    
    <div id="info">
        <div><span class="info-label">FPS:</span> <span id="fps">60</span></div>
        <div><span class="info-label">Bones:</span> <span id="bone-count">0</span></div>
        <div><span class="info-label">Joints:</span> <span id="joint-count">0</span></div>
        <div><span class="info-label">Engine:</span> <span style="color: #eaafc8;">WebAssembly</span></div>
        <div style="margin-top: 10px;"><span class="info-label">Controls:</span></div>
        <div>â€¢ Left click + drag: Rotate view</div>
        <div>â€¢ Right click + drag: Pan view</div>
        <div>â€¢ Scroll: Zoom</div>
    </div>

    <script type="module">
        import { createHumanSkeleton, createCanvasRenderer, applyPose } from '../src/adapters/skeleton-demo.js';
        // ============================================================================
        // WASM MODULE LOADER
        // ============================================================================
        
        const DEG2RAD = Math.PI / 180;
        const RAD2DEG = 180 / Math.PI;
        
        let WasmModule = null;
        
        // Update loading status
        function updateLoadStatus(message) {
            document.getElementById('load-status').textContent = message;
        }
        
        // ============================================================================
        // Initialize skeleton physics (WASM only)
        // ============================================================================
        
        async function initPhysics() {
            updateLoadStatus('Loading WebAssembly module...');
            
            try {
                const createModule = await import('../wasm/skeleton-physics.js');
                WasmModule = await createModule.default();
                updateLoadStatus('WebAssembly loaded successfully!');
                console.log('âœ“ Using WebAssembly physics engine');
                console.log('WASM Module exports:', Object.keys(WasmModule));
                console.log('Skeleton class available:', !!WasmModule.Skeleton);
                return true;
            } catch (error) {
                console.error('Failed to load WASM module:', error);
                updateLoadStatus('Error: Failed to load WebAssembly module');
                throw new Error('WebAssembly module is required but could not be loaded: ' + error.message);
            }
        }
        
        // ============================================================================
        // Skeleton builder
        // ============================================================================
        
        function createSkeleton() {
            if (!WasmModule || !WasmModule.Skeleton) {
                throw new Error('WASM module not properly loaded or Skeleton class not available');
            }
            console.log('Creating skeleton...');
            const skeleton = new WasmModule.Skeleton();
            console.log('Skeleton created, initial bone count:', skeleton.getBoneCount());
            
            // Joint type enum
            const JointType = {
                FREE6DOF: 0,
                BALL: 1,
                HINGE: 2,
                TWIST: 3,
                SWING_TWIST: 4
            };
            
            // Add bones
            const pelvis = skeleton.addBone('pelvis', -1, 0, 1.0, 0, 0.12, 0.11, 9.5);
            const spine01 = skeleton.addBone('spine_01', pelvis, 0, 0.08, 0, 0.10, 0.07, 3.0);
            const spine02 = skeleton.addBone('spine_02', spine01, 0, 0.10, 0, 0.10, 0.07, 3.0);
            const spine03 = skeleton.addBone('spine_03', spine02, 0, 0.10, 0, 0.10, 0.07, 3.0);
            const chest = skeleton.addBone('chest', spine03, 0, 0.12, 0, 0.14, 0.10, 15.0);
            const neck = skeleton.addBone('neck', chest, 0, 0.12, 0, 0.08, 0.04, 1.5);
            const head = skeleton.addBone('head', neck, 0, 0.10, 0, 0.12, 0.08, 6.0);
            
            // Right arm
            const clavR = skeleton.addBone('clav_R', chest, 0.08, 0.10, 0, 0.14, 0.02, 0.4);
            const scapR = skeleton.addBone('scap_R', clavR, 0.14, 0, 0, 0.05, 0.06, 0.3);
            const upperArmR = skeleton.addBone('upperArm_R', scapR, 0.05, -0.02, 0, 0.28, 0.05, 2.1);
            const forearmR = skeleton.addBone('forearm_R', upperArmR, 0, -0.28, 0, 0.24, 0.04, 1.6);
            const handR = skeleton.addBone('hand_R', forearmR, 0, -0.24, 0, 0.08, 0.035, 0.8);
            
            // Left arm
            const clavL = skeleton.addBone('clav_L', chest, -0.08, 0.10, 0, 0.14, 0.02, 0.4);
            const scapL = skeleton.addBone('scap_L', clavL, -0.14, 0, 0, 0.05, 0.06, 0.3);
            const upperArmL = skeleton.addBone('upperArm_L', scapL, -0.05, -0.02, 0, 0.28, 0.05, 2.1);
            const forearmL = skeleton.addBone('forearm_L', upperArmL, 0, -0.28, 0, 0.24, 0.04, 1.6);
            const handL = skeleton.addBone('hand_L', forearmL, 0, -0.24, 0, 0.08, 0.035, 0.8);
            
            // Right leg
            const thighR = skeleton.addBone('thigh_R', pelvis, 0.10, -0.08, 0, 0.40, 0.06, 7.5);
            const shinR = skeleton.addBone('shin_R', thighR, 0, -0.40, 0, 0.38, 0.045, 3.8);
            const footR = skeleton.addBone('foot_R', shinR, 0, -0.38, 0.05, 0.10, 0.035, 0.8);
            const toeR = skeleton.addBone('toe_R', footR, 0, -0.02, 0.08, 0.05, 0.02, 0.2);
            
            // Left leg
            const thighL = skeleton.addBone('thigh_L', pelvis, -0.10, -0.08, 0, 0.40, 0.06, 7.5);
            const shinL = skeleton.addBone('shin_L', thighL, 0, -0.40, 0, 0.38, 0.045, 3.8);
            const footL = skeleton.addBone('foot_L', shinL, 0, -0.38, 0.05, 0.10, 0.035, 0.8);
            const toeL = skeleton.addBone('toe_L', footL, 0, -0.02, 0.08, 0.05, 0.02, 0.2);
            
            // Add joints
            // Spine
            skeleton.addJoint('spine01', pelvis, spine01, JointType.SWING_TWIST,
                -30*DEG2RAD, -30*DEG2RAD, -15*DEG2RAD, 30*DEG2RAD, 30*DEG2RAD, 15*DEG2RAD, 200, 30);
            skeleton.addJoint('spine02', spine01, spine02, JointType.SWING_TWIST,
                -30*DEG2RAD, -30*DEG2RAD, -15*DEG2RAD, 30*DEG2RAD, 30*DEG2RAD, 15*DEG2RAD, 200, 30);
            skeleton.addJoint('spine03', spine02, spine03, JointType.SWING_TWIST,
                -30*DEG2RAD, -30*DEG2RAD, -15*DEG2RAD, 30*DEG2RAD, 30*DEG2RAD, 15*DEG2RAD, 200, 30);
            skeleton.addJoint('chest', spine03, chest, JointType.SWING_TWIST,
                -30*DEG2RAD, -30*DEG2RAD, -15*DEG2RAD, 30*DEG2RAD, 30*DEG2RAD, 15*DEG2RAD, 220, 35);
            
            // Neck & head
            skeleton.addJoint('neck', chest, neck, JointType.BALL,
                -45*DEG2RAD, -60*DEG2RAD, -80*DEG2RAD, 60*DEG2RAD, 45*DEG2RAD, 80*DEG2RAD, 150, 25);
            skeleton.addJoint('head', neck, head, JointType.BALL,
                -20*DEG2RAD, -10*DEG2RAD, -30*DEG2RAD, 20*DEG2RAD, 10*DEG2RAD, 30*DEG2RAD, 120, 20);
            
            // Right arm
            skeleton.addJoint('clav_R', chest, clavR, JointType.BALL,
                -10*DEG2RAD, -45*DEG2RAD, -20*DEG2RAD, 15*DEG2RAD, 45*DEG2RAD, 20*DEG2RAD, 100, 15);
            skeleton.addJoint('scap_R', clavR, scapR, JointType.BALL,
                -20*DEG2RAD, -30*DEG2RAD, -60*DEG2RAD, 20*DEG2RAD, 30*DEG2RAD, 0*DEG2RAD, 80, 12);
            skeleton.addJoint('shoulder_R', scapR, upperArmR, JointType.BALL,
                -45*DEG2RAD, -180*DEG2RAD, -90*DEG2RAD, 30*DEG2RAD, 180*DEG2RAD, 70*DEG2RAD, 150, 20);
            skeleton.addJoint('elbow_R', upperArmR, forearmR, JointType.HINGE,
                -5*DEG2RAD, 0, 0, 150*DEG2RAD, 0, 0, 180, 25);
            skeleton.addJoint('wrist_R', forearmR, handR, JointType.BALL,
                -80*DEG2RAD, -20*DEG2RAD, -80*DEG2RAD, 70*DEG2RAD, 30*DEG2RAD, 80*DEG2RAD, 100, 15);
            
            // Left arm
            skeleton.addJoint('clav_L', chest, clavL, JointType.BALL,
                -10*DEG2RAD, -45*DEG2RAD, -20*DEG2RAD, 15*DEG2RAD, 45*DEG2RAD, 20*DEG2RAD, 100, 15);
            skeleton.addJoint('scap_L', clavL, scapL, JointType.BALL,
                -20*DEG2RAD, -30*DEG2RAD, -60*DEG2RAD, 20*DEG2RAD, 30*DEG2RAD, 0*DEG2RAD, 80, 12);
            skeleton.addJoint('shoulder_L', scapL, upperArmL, JointType.BALL,
                -45*DEG2RAD, -180*DEG2RAD, -70*DEG2RAD, 30*DEG2RAD, 180*DEG2RAD, 90*DEG2RAD, 150, 20);
            skeleton.addJoint('elbow_L', upperArmL, forearmL, JointType.HINGE,
                -5*DEG2RAD, 0, 0, 150*DEG2RAD, 0, 0, 180, 25);
            skeleton.addJoint('wrist_L', forearmL, handL, JointType.BALL,
                -80*DEG2RAD, -20*DEG2RAD, -80*DEG2RAD, 70*DEG2RAD, 30*DEG2RAD, 80*DEG2RAD, 100, 15);
            
            // Right leg
            skeleton.addJoint('hip_R', pelvis, thighR, JointType.BALL,
                -120*DEG2RAD, -30*DEG2RAD, -45*DEG2RAD, 20*DEG2RAD, 45*DEG2RAD, 35*DEG2RAD, 200, 30);
            skeleton.addJoint('knee_R', thighR, shinR, JointType.HINGE,
                0, 0, 0, 150*DEG2RAD, 0, 0, 220, 35);
            skeleton.addJoint('ankle_R', shinR, footR, JointType.HINGE,
                -50*DEG2RAD, 0, 0, 20*DEG2RAD, 0, 0, 150, 20);
            skeleton.addJoint('toe_R', footR, toeR, JointType.HINGE,
                -40*DEG2RAD, 0, 0, 65*DEG2RAD, 0, 0, 80, 10);
            
            // Left leg
            skeleton.addJoint('hip_L', pelvis, thighL, JointType.BALL,
                -120*DEG2RAD, -30*DEG2RAD, -35*DEG2RAD, 20*DEG2RAD, 45*DEG2RAD, 45*DEG2RAD, 200, 30);
            skeleton.addJoint('knee_L', thighL, shinL, JointType.HINGE,
                0, 0, 0, 150*DEG2RAD, 0, 0, 220, 35);
            skeleton.addJoint('ankle_L', shinL, footL, JointType.HINGE,
                -50*DEG2RAD, 0, 0, 20*DEG2RAD, 0, 0, 150, 20);
            skeleton.addJoint('toe_L', footL, toeL, JointType.HINGE,
                -40*DEG2RAD, 0, 0, 65*DEG2RAD, 0, 0, 80, 10);
            
            console.log('Skeleton creation complete. Final bone count:', skeleton.getBoneCount());
            console.log('Final joint count:', skeleton.getJointCount());
            return skeleton;
        }
        
        // Fallback skeleton for testing
        function createTestSkeleton() {
            console.log('Creating test skeleton (fallback)...');
            return {
                getBoneCount: () => 3,
                getJointCount: () => 2,
                getBonePosition: (i) => {
                    const positions = [
                        { x: 0, y: 1, z: 0 },    // pelvis
                        { x: 0, y: 1.5, z: 0 },  // spine
                        { x: 0.2, y: 1.8, z: 0 } // head
                    ];
                    return positions[i] || { x: 0, y: 0, z: 0 };
                },
                getBoneRotation: (i) => ({ x: 0, y: 0, z: 0, w: 1 }),
                getBoneName: (i) => ['pelvis', 'spine', 'head'][i] || 'bone_' + i,
                getBoneLength: (i) => 0.3,
                getBoneRadius: (i) => 0.05,
                getJointName: (i) => ['spine_joint', 'head_joint'][i] || 'joint_' + i,
                getJointChildBoneIndex: (i) => i + 1,
                computeCenterOfMass: () => ({ x: 0, y: 1.2, z: 0 }),
                update: (dt) => {},
                setPhysicsEnabled: (enabled) => {},
                setGravityEnabled: (enabled) => {},
                setGlobalStiffness: (stiffness) => {},
                setGlobalDamping: (damping) => {},
                setJointTargetAngles: (jointIdx, x, y, z) => {}
            };
        }
        
        // ============================================================================
        // WASM-Only Canvas 2D Renderer
        // ============================================================================
        
        class SkeletonRenderer {
            constructor(container, skeleton) {
                this.skeleton = skeleton;
                
                // Create canvas
                this.canvas = document.createElement('canvas');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.canvas.style.display = 'block';
                container.appendChild(this.canvas);
                
                this.ctx = this.canvas.getContext('2d');
                
                // Camera settings
                this.camera = {
                    x: 0,
                    y: 1,
                    z: 0,  // Closer to skeleton
                    rotationX: -0.1,  // Less tilted
                    rotationY: 0,
                    zoom: 2.0  // Zoomed in more
                };
                
                // Rendering options
                this.showBones = true;
                this.showJoints = true;
                this.showCOM = false;
                this.showLimits = false;
                this.showIKTargets = false;
                
                this.setupControls();
                window.addEventListener('resize', () => this.onResize());
            }
            
            setupControls() {
                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };
                let isRightDrag = false;
                
                this.canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    isRightDrag = e.button === 2;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    if (isRightDrag) {
                        const panSpeed = 0.002;
                        this.camera.x -= deltaX * panSpeed;
                        this.camera.y += deltaY * panSpeed;
                    } else {
                        const rotateSpeed = 0.005;
                        this.camera.rotationY -= deltaX * rotateSpeed;
                        this.camera.rotationX += deltaY * rotateSpeed;
                        this.camera.rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.camera.rotationX));
                    }
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    isDragging = false;
                });
                
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomSpeed = 0.001;
                    this.camera.zoom += e.deltaY * zoomSpeed;
                    this.camera.zoom = Math.max(0.1, Math.min(5.0, this.camera.zoom));
                });
                
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            // Apply quaternion rotation to a vector
            rotateVector(v, q) {
                // v' = q * v * q^-1
                // For unit quaternions: q^-1 = q* (conjugate)
                const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
                const vx = v.x, vy = v.y, vz = v.z;
                
                // First: q * v (treating v as quaternion with w=0)
                const t1x = qw * vx + qy * vz - qz * vy;
                const t1y = qw * vy + qz * vx - qx * vz;
                const t1z = qw * vz + qx * vy - qy * vx;
                const t1w = -qx * vx - qy * vy - qz * vz;
                
                // Second: result * q* (conjugate)
                const rx = t1w * (-qx) + t1x * qw + t1y * (-qz) - t1z * (-qy);
                const ry = t1w * (-qy) + t1y * qw + t1z * (-qx) - t1x * (-qz);
                const rz = t1w * (-qz) + t1z * qw + t1x * (-qy) - t1y * (-qx);
                
                return { x: rx, y: ry, z: rz };
            }
            
            // Convert 3D world coordinates to 2D screen coordinates
            worldToScreen(worldPos) {
                // Simple orthographic projection
                const scale = 200 * this.camera.zoom;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Apply camera rotation
                const cosY = Math.cos(this.camera.rotationY);
                const sinY = Math.sin(this.camera.rotationY);
                const cosX = Math.cos(this.camera.rotationX);
                const sinX = Math.sin(this.camera.rotationX);
                
                // Rotate around Y axis
                let x = worldPos.x * cosY - worldPos.z * sinY;
                let y = worldPos.y;
                let z = worldPos.x * sinY + worldPos.z * cosY;
                
                // Rotate around X axis
                const tempY = y * cosX - z * sinX;
                z = y * sinX + z * cosX;
                y = tempY;
                
                // Apply camera translation
                x -= this.camera.x;
                y -= this.camera.y;
                z -= this.camera.z;
                
                // Project to screen
                const screenX = centerX + x * scale;
                const screenY = centerY - y * scale;
                
                const result = { x: screenX, y: screenY, z: z };
                // console.log(`World (${worldPos.x}, ${worldPos.y}, ${worldPos.z}) -> Screen (${screenX}, ${screenY}, z=${z})`);
                return result;
            }
            
            // Draw a bone as a line
            drawBone(startPos, endPos, radius) {
                const start = this.worldToScreen(startPos);
                const end = this.worldToScreen(endPos);
                
                // Don't skip behind camera for now - let's see everything
                // if (start.z < 0 || end.z < 0) return;
                
                this.ctx.strokeStyle = '#00ff00';
                // Convert world-space radius to pixels using same scale as projection
                const scalePx = 200 * this.camera.zoom;
                // Keep bones readable but not oversized
                this.ctx.lineWidth = Math.max(2, radius * scalePx);
                this.ctx.lineCap = 'round';
                
                this.ctx.beginPath();
                this.ctx.moveTo(start.x, start.y);
                this.ctx.lineTo(end.x, end.y);
                this.ctx.stroke();
            }
            
            // Draw a joint as a circle
            drawJoint(pos, radius) {
                const screen = this.worldToScreen(pos);
                
                // Don't skip behind camera for now
                // if (screen.z < 0) return;
                
                const scalePx = 200 * this.camera.zoom;
                const screenRadius = Math.max(3, radius * scalePx);

                // Subtle glow without double-fill
                this.ctx.fillStyle = '#ff0000';
                this.ctx.shadowColor = '#ff0000';
                this.ctx.shadowBlur = 6;
                this.ctx.beginPath();
                this.ctx.arc(screen.x, screen.y, screenRadius, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            // Draw center of mass point
            drawCOMPoint(pos) {
                const screen = this.worldToScreen(pos);
                
                if (screen.z < 0) return;
                
                const radius = 6;
                
                this.ctx.fillStyle = '#ffff00';
                this.ctx.beginPath();
                this.ctx.arc(screen.x, screen.y, radius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Add glow effect
                this.ctx.shadowColor = '#ffff00';
                this.ctx.shadowBlur = 15;
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            update() {
                // This method is called every frame to update the skeleton visualization
                // The actual rendering happens in the render() method
            }
            
            render() {
                // Clear canvas
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid
                this.drawGrid();
                
                if (this.showBones) {
                    this.drawBones();
                }
                
                if (this.showJoints) {
                    this.drawJoints();
                }
                
                if (this.showCOM) {
                    this.drawCOMMarker();
                }
            }
            
            drawGrid() {
                const scale = 200 * this.camera.zoom;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                this.ctx.strokeStyle = '#2a2a3e';
                this.ctx.lineWidth = 1;
                
                const gridSize = 20;
                const gridSpacing = scale;
                
                this.ctx.beginPath();
                for (let i = -gridSize; i <= gridSize; i++) {
                    const x = centerX + i * gridSpacing;
                    const y = centerY + i * gridSpacing;
                    
                    if (i % 5 === 0) {
                        this.ctx.strokeStyle = '#4da6ff';
                    } else {
                        this.ctx.strokeStyle = '#2a2a3e';
                    }
                    
                    // Vertical lines
                    this.ctx.moveTo(x, centerY - gridSize * gridSpacing);
                    this.ctx.lineTo(x, centerY + gridSize * gridSpacing);
                    
                    // Horizontal lines
                    this.ctx.moveTo(centerX - gridSize * gridSpacing, y);
                    this.ctx.lineTo(centerX + gridSize * gridSpacing, y);
                }
                this.ctx.stroke();
            }
            
            drawBones() {
                try {
                    const boneCount = this.skeleton.getBoneCount();
                    
                    for (let i = 0; i < boneCount; i++) {
                        const pos = this.skeleton.getBonePosition(i);
                        const rot = this.skeleton.getBoneRotation(i);
                        const length = this.skeleton.getBoneLength(i);
                        const radius = this.skeleton.getBoneRadius(i);
                        
                        // Use bone rotation to determine direction
                        // Bones are oriented along their local Y-axis
                        // Apply quaternion rotation to (0, length, 0)
                        const localEnd = { x: 0, y: length, z: 0 };
                        
                        // Rotate localEnd by quaternion rot
                        const rotatedEnd = this.rotateVector(localEnd, rot);
                        
                        const endPos = {
                            x: pos.x + rotatedEnd.x,
                            y: pos.y + rotatedEnd.y,
                            z: pos.z + rotatedEnd.z
                        };
                        
                        this.drawBone(pos, endPos, radius);
                    }
                } catch (error) {
                    console.error('Error drawing bones:', error);
                }
            }
            
            drawJoints() {
                try {
                    const jointCount = this.skeleton.getJointCount();
                    
                    for (let i = 0; i < jointCount; i++) {
                        const boneIdx = this.skeleton.getJointChildBoneIndex(i);
                        if (boneIdx >= 0) {
                            const pos = this.skeleton.getBonePosition(boneIdx);
                            this.drawJoint(pos, 0.03);
                        }
                    }
                } catch (error) {
                    console.error('Error drawing joints:', error);
                }
            }
            
            drawCOMMarker() {
                try {
                    const com = this.skeleton.computeCenterOfMass();
                    this.drawCOMPoint(com);
                } catch (error) {
                    console.error('Error drawing center of mass:', error);
                }
            }
            
            onResize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
        }
        
        // ============================================================================
        // Pose Controller
        // ============================================================================
        
        class PoseController {
            constructor(skeleton) {
                this.skeleton = skeleton;
                this.jointMap = new Map();
                
                const jointCount = skeleton.getJointCount();
                for (let i = 0; i < jointCount; i++) {
                    const name = skeleton.getJointName(i);
                    this.jointMap.set(name, i);
                }
            }
            
            setPose(poseName) {
                const poses = {
                    'apose': {
                        'shoulder_R': [0, 30*DEG2RAD, 0],
                        'shoulder_L': [0, -30*DEG2RAD, 0]
                    },
                    'tpose': {
                        'shoulder_R': [0, 90*DEG2RAD, 0],
                        'shoulder_L': [0, -90*DEG2RAD, 0]
                    },
                    'sit': {
                        'hip_R': [-90*DEG2RAD, 0, 0],
                        'hip_L': [-90*DEG2RAD, 0, 0],
                        'knee_R': [90*DEG2RAD, 0, 0],
                        'knee_L': [90*DEG2RAD, 0, 0]
                    },
                    'squat': {
                        'hip_R': [-110*DEG2RAD, 0, 0],
                        'hip_L': [-110*DEG2RAD, 0, 0],
                        'knee_R': [130*DEG2RAD, 0, 0],
                        'knee_L': [130*DEG2RAD, 0, 0],
                        'ankle_R': [20*DEG2RAD, 0, 0],
                        'ankle_L': [20*DEG2RAD, 0, 0]
                    },
                    'reach': {
                        'shoulder_R': [0, 120*DEG2RAD, 0],
                        'shoulder_L': [0, 120*DEG2RAD, 0],
                        'elbow_R': [10*DEG2RAD, 0, 0],
                        'elbow_L': [10*DEG2RAD, 0, 0]
                    },
                    'wave': {
                        'shoulder_R': [0, 150*DEG2RAD, 0],
                        'elbow_R': [90*DEG2RAD, 0, 0]
                    }
                };
                
                const pose = poses[poseName];
                if (pose) {
                    for (const [jointName, angles] of Object.entries(pose)) {
                        const jointIdx = this.jointMap.get(jointName);
                        if (jointIdx !== undefined) {
                            this.skeleton.setJointTargetAngles(jointIdx, angles[0], angles[1], angles[2]);
                        }
                    }
                }
            }
            
            reset() {
                this.jointMap.forEach((idx) => {
                    this.skeleton.setJointTargetAngles(idx, 0, 0, 0);
                });
            }
        }
        
        // ============================================================================
        // Main Application
        // ============================================================================
        
        async function main() {
            let skeleton;
            
            // Initialize physics
            try {
                // Initialize WASM (optional); we use our JS model for interactive IK
                await initPhysics().catch(() => {});
                updateLoadStatus('Creating human skeleton model...');
                skeleton = createHumanSkeleton(1.7);
            } catch (error) {
                console.warn('Falling back to test skeleton:', error);
                updateLoadStatus('Using test skeleton (model failed)...');
                skeleton = createTestSkeleton();
            }
            
            updateLoadStatus('Initializing renderer...');
            // New canvas renderer from public/src
            const container = document.getElementById('canvas-container');
            const canvas = document.createElement('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvas.style.display = 'block';
            container.innerHTML = '';
            container.appendChild(canvas);

            const renderer = createCanvasRenderer(canvas);
            // Zoom out and move camera back for better framing
            renderer.camera.zoom = 0.9;
            renderer.camera.z = 2.0;
            renderer.camera.y = 1.2;
            
            // Enable click-drag interaction
            const { SkeletonInteractionController } = await import('../src/controllers/skeleton/interaction-controller.js');
            const interactor = new SkeletonInteractionController(renderer, skeleton);
            const poseController = new PoseController(skeleton);
            
            // Update info
            document.getElementById('bone-count').textContent = skeleton.getBoneCount();
            document.getElementById('joint-count').textContent = skeleton.getJointCount();
            
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 500);
            
            // Setup UI
            setupUI(skeleton, renderer, poseController);
            
            // Animation loop
            let lastTime = performance.now();
            let frameCount = 0;
            let lastFpsUpdate = lastTime;
            
            function animate() {
                requestAnimationFrame(animate);
                
                const currentTime = performance.now();
                const dt = Math.min((currentTime - lastTime) / 1000, 0.033);
                lastTime = currentTime;
                
                // Update physics
                const physicsStart = performance.now();
                skeleton.update(dt);
                const physicsTime = performance.now() - physicsStart;
                
                // Update renderer
                const renderStart = performance.now();
                renderer.render(skeleton);
                const renderTime = performance.now() - renderStart;
                
                // Update performance stats
                document.getElementById('perf-physics').textContent = physicsTime.toFixed(2) + 'ms';
                document.getElementById('perf-render').textContent = renderTime.toFixed(2) + 'ms';
                document.getElementById('perf-total').textContent = (physicsTime + renderTime).toFixed(2) + 'ms';
                
                // Update FPS
                frameCount++;
                if (frameCount % 30 === 0) {
                    const fps = Math.round(30000 / (currentTime - lastFpsUpdate));
                    document.getElementById('fps').textContent = fps;
                    lastFpsUpdate = currentTime;
                }
            }
            
            animate();
        }
        
        function setupUI(skeleton, renderer, poseController) {
            // Pose buttons
            document.getElementById('btn-apose').addEventListener('click', () => {
                poseController.setPose('apose');
            });
            
            document.getElementById('btn-tpose').addEventListener('click', () => {
                poseController.setPose('tpose');
            });
            
            document.getElementById('btn-sit').addEventListener('click', () => {
                poseController.setPose('sit');
            });
            
            document.getElementById('btn-squat').addEventListener('click', () => {
                poseController.setPose('squat');
            });
            
            document.getElementById('btn-reach').addEventListener('click', () => {
                poseController.setPose('reach');
            });
            
            document.getElementById('btn-wave').addEventListener('click', () => {
                poseController.setPose('wave');
            });
            
            // Physics controls
            document.getElementById('chk-physics').addEventListener('change', (e) => {
                skeleton.setPhysicsEnabled(e.target.checked);
            });
            
            document.getElementById('chk-gravity').addEventListener('change', (e) => {
                skeleton.setGravityEnabled(e.target.checked);
            });
            
            document.getElementById('slider-stiffness').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('val-stiffness').textContent = value;
                skeleton.setGlobalStiffness(value / 100);
            });
            
            document.getElementById('slider-damping').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('val-damping').textContent = value;
                skeleton.setGlobalDamping(value / 20);
            });
            
            // Visualization
            document.getElementById('chk-bones').addEventListener('change', (e) => {
                renderer.showBones = e.target.checked;
            });
            
            document.getElementById('chk-joints').addEventListener('change', (e) => {
                renderer.showJoints = e.target.checked;
            });
            
            document.getElementById('chk-com').addEventListener('change', (e) => {
                renderer.showCOM = e.target.checked;
            });
            
            document.getElementById('chk-limits').addEventListener('change', (e) => {
                renderer.showLimits = e.target.checked;
            });
            
            document.getElementById('chk-ik-targets').addEventListener('change', (e) => {
                renderer.showIKTargets = e.target.checked;
            });
            
            // Test buttons
            document.getElementById('btn-test-shoulder').addEventListener('click', () => {
                testJointRange(skeleton, poseController, 'shoulder_R', [0, 0, 0], [0, 180*DEG2RAD, 0], 2);
            });
            
            document.getElementById('btn-test-elbow').addEventListener('click', () => {
                testJointRange(skeleton, poseController, 'elbow_R', [0, 0, 0], [150*DEG2RAD, 0, 0], 3);
            });
            
            document.getElementById('btn-test-knee').addEventListener('click', () => {
                testJointRange(skeleton, poseController, 'knee_R', [0, 0, 0], [150*DEG2RAD, 0, 0], 3);
            });
            
            document.getElementById('btn-reset').addEventListener('click', () => {
                poseController.reset();
            });
        }
        
        function testJointRange(skeleton, poseController, jointName, startAngles, endAngles, speed) {
            let t = 0;
            const step = 0.02 * speed;
            
            const interval = setInterval(() => {
                t += step;
                
                if (t >= 1.0) {
                    clearInterval(interval);
                    setTimeout(() => poseController.reset(), 1000);
                    return;
                }
                
                const angles = [
                    startAngles[0] + (endAngles[0] - startAngles[0]) * t,
                    startAngles[1] + (endAngles[1] - startAngles[1]) * t,
                    startAngles[2] + (endAngles[2] - startAngles[2]) * t
                ];
                
                const jointMap = new Map();
                const jointCount = skeleton.getJointCount();
                for (let i = 0; i < jointCount; i++) {
                    const name = skeleton.getJointName(i);
                    jointMap.set(name, i);
                }
                
                const jointIdx = jointMap.get(jointName);
                if (jointIdx !== undefined) {
                    skeleton.setJointTargetAngles(jointIdx, angles[0], angles[1], angles[2]);
                }
            }, 50);
        }
        
        // Start the application
        main().catch(error => {
            console.error('Failed to initialize application:', error);
            document.getElementById('load-status').textContent = 'Error: ' + error.message;
        });
    </script>
</body>
</html>
