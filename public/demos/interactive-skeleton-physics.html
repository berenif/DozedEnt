<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Skeleton Physics - WebAssembly Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: hidden;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 12px;
            color: white;
            text-align: center;
            z-index: 1000;
        }
        
        #loading.hidden {
            display: none;
        }
        
        .spinner {
            border: 4px solid rgba(77, 166, 255, 0.3);
            border-top: 4px solid #4da6ff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            color: white;
            max-width: 320px;
            max-height: 90vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        #controls h2 {
            margin-bottom: 15px;
            font-size: 20px;
            color: #4da6ff;
            border-bottom: 2px solid #4da6ff;
            padding-bottom: 8px;
        }
        
        #controls h3 {
            margin-top: 15px;
            margin-bottom: 10px;
            font-size: 14px;
            color: #80c0ff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #b0d0ff;
        }
        
        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: linear-gradient(135deg, #4da6ff 0%, #3d85cc 100%);
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(77, 166, 255, 0.3);
        }
        
        button:hover:not(:disabled) {
            background: linear-gradient(135deg, #5bb6ff 0%, #4d95dc 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(77, 166, 255, 0.4);
        }
        
        button:active:not(:disabled) {
            transform: translateY(0);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 8px 0;
            -webkit-appearance: none;
            background: transparent;
        }
        
        input[type="range"]::-webkit-slider-track {
            background: rgba(77, 166, 255, 0.3);
            height: 4px;
            border-radius: 2px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            background: #4da6ff;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -6px;
        }
        
        input[type="checkbox"] {
            margin-right: 8px;
        }
        
        .value-display {
            display: inline-block;
            float: right;
            font-weight: 600;
            color: #4da6ff;
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 12px;
            color: white;
            font-size: 12px;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }
        
        #info div {
            margin: 5px 0;
        }
        
        .info-label {
            color: #80c0ff;
            font-weight: 600;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            margin: 8px 0;
            cursor: pointer;
            font-size: 13px;
        }
        
        .checkbox-label input {
            cursor: pointer;
        }

        .wasm-badge {
            display: inline-block;
            background: linear-gradient(135deg, #654ea3 0%, #eaafc8 100%);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: bold;
            letter-spacing: 1px;
            margin-left: 8px;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(77, 166, 255, 0.5);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(77, 166, 255, 0.7);
        }
    </style>
</head>
<body>
    <div id="loading">
        <h2>Loading Skeleton Physics</h2>
        <div class="spinner"></div>
        <p id="load-status">Initializing WebAssembly module...</p>
    </div>
    
    <div id="canvas-container"></div>
    
    <div id="controls">
        <h2>ðŸ¦´ Skeleton Physics <span class="wasm-badge">WASM</span></h2>
        
        <h3>Poses</h3>
        <button id="btn-apose">A-Pose (Rest)</button>
        <button id="btn-tpose">T-Pose</button>
        <button id="btn-sit">Sitting</button>
        <button id="btn-squat">Deep Squat</button>
        <button id="btn-reach">Reach Forward</button>
        <button id="btn-wave">Wave</button>
        
        <h3>Physics Settings</h3>
        <div class="control-group">
            <label class="checkbox-label">
                <input type="checkbox" id="chk-physics" checked>
                Enable Physics Simulation
            </label>
            <label class="checkbox-label">
                <input type="checkbox" id="chk-gravity" checked>
                Enable Gravity
            </label>
        </div>
        
        <div class="control-group">
            <label>
                Joint Stiffness <span class="value-display" id="val-stiffness">100</span>
            </label>
            <input type="range" id="slider-stiffness" min="10" max="500" value="100" step="10">
        </div>
        
        <div class="control-group">
            <label>
                Joint Damping <span class="value-display" id="val-damping">20</span>
            </label>
            <input type="range" id="slider-damping" min="5" max="100" value="20" step="5">
        </div>
        
        <h3>Visualization</h3>
        <div class="control-group">
            <label class="checkbox-label">
                <input type="checkbox" id="chk-bones" checked>
                Show Bones
            </label>
            <label class="checkbox-label">
                <input type="checkbox" id="chk-joints" checked>
                Show Joints
            </label>
            <label class="checkbox-label">
                <input type="checkbox" id="chk-limits">
                Show Joint Limits
            </label>
            <label class="checkbox-label">
                <input type="checkbox" id="chk-com">
                Show Center of Mass
            </label>
            <label class="checkbox-label">
                <input type="checkbox" id="chk-ik-targets">
                Show IK Targets
            </label>
        </div>
        
        <h3>Tests</h3>
        <button id="btn-test-shoulder">Test Shoulder Range</button>
        <button id="btn-test-elbow">Test Elbow</button>
        <button id="btn-test-knee">Test Knee</button>
        <button id="btn-reset">Reset Pose</button>
        
        <h3>Performance</h3>
        <div id="perf-info" style="font-size: 11px; color: #80c0ff;">
            <div>Physics: <span id="perf-physics">0.0ms</span></div>
            <div>Render: <span id="perf-render">0.0ms</span></div>
            <div>Total: <span id="perf-total">0.0ms</span></div>
        </div>
    </div>
    
    <div id="info">
        <div><span class="info-label">FPS:</span> <span id="fps">60</span></div>
        <div><span class="info-label">Bones:</span> <span id="bone-count">0</span></div>
        <div><span class="info-label">Joints:</span> <span id="joint-count">0</span></div>
        <div><span class="info-label">Engine:</span> <span style="color: #eaafc8;">WebAssembly</span></div>
        <div style="margin-top: 10px;"><span class="info-label">Controls:</span></div>
        <div>â€¢ Left click + drag: Rotate view</div>
        <div>â€¢ Right click + drag: Pan view</div>
        <div>â€¢ Scroll: Zoom</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        // ============================================================================
        // WASM MODULE LOADER (with fallback to pure JS)
        // ============================================================================
        
        const DEG2RAD = Math.PI / 180;
        const RAD2DEG = 180 / Math.PI;
        
        let WasmModule = null;
        let useWasm = false;
        
        // Update loading status
        function updateLoadStatus(message) {
            document.getElementById('load-status').textContent = message;
        }
        
        // Pure JavaScript implementation (fallback)
        class JSSkeletonPhysics {
            constructor() {
                this.bones = [];
                this.joints = [];
                this.boneMap = new Map();
                this.jointMap = new Map();
                this.gravity = { x: 0, y: -9.81, z: 0 };
                this.physicsEnabled = true;
                this.gravityEnabled = true;
                this.globalStiffness = 1.0;
                this.globalDamping = 1.0;
            }
            
            addBone(name, parentIndex, px, py, pz, length, radius, mass) {
                const bone = {
                    name,
                    parentIndex,
                    childIndices: [],
                    restPosition: { x: px, y: py, z: pz },
                    length,
                    radius,
                    mass,
                    position: { x: px, y: py, z: pz },
                    rotation: { x: 0, y: 0, z: 0, w: 1 },
                    localRotation: { x: 0, y: 0, z: 0, w: 1 },
                    velocity: { x: 0, y: 0, z: 0 },
                    angularVelocity: { x: 0, y: 0, z: 0 },
                    inertia: this.computeInertia(length, radius, mass)
                };
                
                const index = this.bones.length;
                this.bones.push(bone);
                this.boneMap.set(name, index);
                
                if (parentIndex >= 0 && parentIndex < this.bones.length) {
                    this.bones[parentIndex].childIndices.push(index);
                }
                
                return index;
            }
            
            computeInertia(length, radius, mass) {
                const r = radius;
                const h = length;
                const m = mass;
                const Ixx = (1/12) * m * (3*r*r + h*h);
                const Izz = (1/2) * m * r * r;
                return { x: Ixx, y: Ixx, z: Izz };
            }
            
            addJoint(name, parentIdx, childIdx, typeInt, 
                    minX, minY, minZ, maxX, maxY, maxZ, stiffness, damping) {
                const joint = {
                    name,
                    parentBoneIndex: parentIdx,
                    childBoneIndex: childIdx,
                    type: typeInt,
                    limits: {
                        min: { x: minX, y: minY, z: minZ },
                        max: { x: maxX, y: maxY, z: maxZ }
                    },
                    drive: { stiffness, damping },
                    currentAngles: { x: 0, y: 0, z: 0 },
                    targetAngles: { x: 0, y: 0, z: 0 }
                };
                
                const index = this.joints.length;
                this.joints.push(joint);
                this.jointMap.set(name, index);
                
                return index;
            }
            
            update(dt) {
                if (!this.physicsEnabled) return;
                
                // Apply physics
                for (let i = 1; i < this.bones.length; i++) {
                    const bone = this.bones[i];
                    
                    if (this.gravityEnabled) {
                        bone.velocity.y += this.gravity.y * dt;
                    }
                    
                    bone.velocity.x *= 0.98;
                    bone.velocity.y *= 0.98;
                    bone.velocity.z *= 0.98;
                    bone.angularVelocity.x *= 0.95;
                    bone.angularVelocity.y *= 0.95;
                    bone.angularVelocity.z *= 0.95;
                }
                
                // Apply joint constraints
                for (const joint of this.joints) {
                    if (joint.childBoneIndex < 0 || joint.childBoneIndex >= this.bones.length) {
                        continue;
                    }
                    
                    const bone = this.bones[joint.childBoneIndex];
                    const k = joint.drive.stiffness * this.globalStiffness;
                    const d = joint.drive.damping * this.globalDamping;
                    
                    const errorX = this.shortestAngle(joint.targetAngles.x - joint.currentAngles.x);
                    const errorY = this.shortestAngle(joint.targetAngles.y - joint.currentAngles.y);
                    const errorZ = this.shortestAngle(joint.targetAngles.z - joint.currentAngles.z);
                    
                    joint.currentAngles.x = this.clamp(joint.currentAngles.x, joint.limits.min.x, joint.limits.max.x);
                    joint.currentAngles.y = this.clamp(joint.currentAngles.y, joint.limits.min.y, joint.limits.max.y);
                    joint.currentAngles.z = this.clamp(joint.currentAngles.z, joint.limits.min.z, joint.limits.max.z);
                    
                    const torqueX = k * errorX - d * bone.angularVelocity.x;
                    const torqueY = k * errorY - d * bone.angularVelocity.y;
                    const torqueZ = k * errorZ - d * bone.angularVelocity.z;
                    
                    bone.angularVelocity.x += (torqueX / bone.inertia.x) * dt;
                    bone.angularVelocity.y += (torqueY / bone.inertia.y) * dt;
                    bone.angularVelocity.z += (torqueZ / bone.inertia.z) * dt;
                    
                    this.integrateRotation(bone, dt);
                }
                
                // Update transforms
                if (this.bones.length > 0) {
                    this.updateTransform(0);
                }
            }
            
            integrateRotation(bone, dt) {
                const angle = Math.sqrt(
                    bone.angularVelocity.x * bone.angularVelocity.x +
                    bone.angularVelocity.y * bone.angularVelocity.y +
                    bone.angularVelocity.z * bone.angularVelocity.z
                ) * dt;
                
                if (angle > 0.0001) {
                    const axis = {
                        x: bone.angularVelocity.x / angle * dt,
                        y: bone.angularVelocity.y / angle * dt,
                        z: bone.angularVelocity.z / angle * dt
                    };
                    
                    const halfAngle = angle * 0.5;
                    const s = Math.sin(halfAngle);
                    const deltaQuat = {
                        x: axis.x * s,
                        y: axis.y * s,
                        z: axis.z * s,
                        w: Math.cos(halfAngle)
                    };
                    
                    bone.localRotation = this.multiplyQuaternions(bone.localRotation, deltaQuat);
                    bone.localRotation = this.normalizeQuaternion(bone.localRotation);
                }
            }
            
            updateTransform(index) {
                const bone = this.bones[index];
                
                if (bone.parentIndex >= 0) {
                    const parent = this.bones[bone.parentIndex];
                    bone.position = this.rotateVector(bone.restPosition, parent.rotation);
                    bone.position.x += parent.position.x;
                    bone.position.y += parent.position.y;
                    bone.position.z += parent.position.z;
                    bone.rotation = this.multiplyQuaternions(parent.rotation, bone.localRotation);
                } else {
                    bone.position = { ...bone.restPosition };
                    bone.rotation = { ...bone.localRotation };
                }
                
                bone.rotation = this.normalizeQuaternion(bone.rotation);
                
                for (const childIdx of bone.childIndices) {
                    this.updateTransform(childIdx);
                }
            }
            
            rotateVector(v, q) {
                const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
                const vx = v.x, vy = v.y, vz = v.z;
                
                const ix = qw * vx + qy * vz - qz * vy;
                const iy = qw * vy + qz * vx - qx * vz;
                const iz = qw * vz + qx * vy - qy * vx;
                const iw = -qx * vx - qy * vy - qz * vz;
                
                return {
                    x: ix * qw + iw * -qx + iy * -qz - iz * -qy,
                    y: iy * qw + iw * -qy + iz * -qx - ix * -qz,
                    z: iz * qw + iw * -qz + ix * -qy - iy * -qx
                };
            }
            
            multiplyQuaternions(a, b) {
                return {
                    x: a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,
                    y: a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x,
                    z: a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w,
                    w: a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z
                };
            }
            
            normalizeQuaternion(q) {
                const len = Math.sqrt(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);
                if (len > 0.0001) {
                    return { x: q.x/len, y: q.y/len, z: q.z/len, w: q.w/len };
                }
                return { x: 0, y: 0, z: 0, w: 1 };
            }
            
            clamp(value, min, max) {
                return Math.max(min, Math.min(value, max));
            }
            
            shortestAngle(angle) {
                while (angle > Math.PI) angle -= 2 * Math.PI;
                while (angle < -Math.PI) angle += 2 * Math.PI;
                return angle;
            }
            
            computeCenterOfMass() {
                let totalMass = 0;
                const com = { x: 0, y: 0, z: 0 };
                
                for (const bone of this.bones) {
                    com.x += bone.position.x * bone.mass;
                    com.y += bone.position.y * bone.mass;
                    com.z += bone.position.z * bone.mass;
                    totalMass += bone.mass;
                }
                
                if (totalMass > 0.0001) {
                    com.x /= totalMass;
                    com.y /= totalMass;
                    com.z /= totalMass;
                }
                
                return com;
            }
            
            getBoneCount() { return this.bones.length; }
            getJointCount() { return this.joints.length; }
            getBonePosition(index) { return this.bones[index]?.position || { x: 0, y: 0, z: 0 }; }
            getBoneRotation(index) { return this.bones[index]?.rotation || { x: 0, y: 0, z: 0, w: 1 }; }
            getBoneName(index) { return this.bones[index]?.name || ''; }
            getBoneLength(index) { return this.bones[index]?.length || 0; }
            getBoneRadius(index) { return this.bones[index]?.radius || 0; }
            getJointName(index) { return this.joints[index]?.name || ''; }
            getJointChildBoneIndex(index) { return this.joints[index]?.childBoneIndex || -1; }
            
            setJointTargetAngles(index, x, y, z) {
                if (this.joints[index]) {
                    this.joints[index].targetAngles = { x, y, z };
                }
            }
            
            setPhysicsEnabled(enabled) { this.physicsEnabled = enabled; }
            setGravityEnabled(enabled) { this.gravityEnabled = enabled; }
            setGlobalStiffness(value) { this.globalStiffness = value; }
            setGlobalDamping(value) { this.globalDamping = value; }
            
            getPhysicsEnabled() { return this.physicsEnabled; }
            getGravityEnabled() { return this.gravityEnabled; }
            getGlobalStiffness() { return this.globalStiffness; }
            getGlobalDamping() { return this.globalDamping; }
        }
        
        // ============================================================================
        // Initialize skeleton physics (WASM or JS fallback)
        // ============================================================================
        
        async function initPhysics() {
            updateLoadStatus('Checking for WebAssembly support...');
            
            // Try to load WASM module
            try {
                updateLoadStatus('Loading WebAssembly module...');
                
                // Check if module file exists
                const response = await fetch('../wasm/skeleton-physics.js');
                if (response.ok) {
                    const createModule = await import('../wasm/skeleton-physics.js');
                    WasmModule = await createModule.default();
                    useWasm = true;
                    updateLoadStatus('WebAssembly loaded successfully!');
                    console.log('âœ“ Using WebAssembly physics engine');
                } else {
                    throw new Error('WASM module not found');
                }
            } catch (error) {
                console.warn('WASM not available, using JavaScript fallback:', error.message);
                updateLoadStatus('Using JavaScript physics engine...');
                useWasm = false;
            }
            
            return useWasm;
        }
        
        // ============================================================================
        // Skeleton builder
        // ============================================================================
        
        function createSkeleton() {
            const skeleton = useWasm ? new WasmModule.Skeleton() : new JSSkeletonPhysics();
            
            // Joint type enum
            const JointType = {
                FREE6DOF: 0,
                BALL: 1,
                HINGE: 2,
                TWIST: 3,
                SWING_TWIST: 4
            };
            
            // Add bones
            const pelvis = skeleton.addBone('pelvis', -1, 0, 1.0, 0, 0.12, 0.11, 9.5);
            const spine01 = skeleton.addBone('spine_01', pelvis, 0, 0.08, 0, 0.10, 0.07, 3.0);
            const spine02 = skeleton.addBone('spine_02', spine01, 0, 0.10, 0, 0.10, 0.07, 3.0);
            const spine03 = skeleton.addBone('spine_03', spine02, 0, 0.10, 0, 0.10, 0.07, 3.0);
            const chest = skeleton.addBone('chest', spine03, 0, 0.12, 0, 0.14, 0.10, 15.0);
            const neck = skeleton.addBone('neck', chest, 0, 0.12, 0, 0.08, 0.04, 1.5);
            const head = skeleton.addBone('head', neck, 0, 0.10, 0, 0.12, 0.08, 6.0);
            
            // Right arm
            const clavR = skeleton.addBone('clav_R', chest, 0.08, 0.10, 0, 0.14, 0.02, 0.4);
            const scapR = skeleton.addBone('scap_R', clavR, 0.14, 0, 0, 0.05, 0.06, 0.3);
            const upperArmR = skeleton.addBone('upperArm_R', scapR, 0.05, -0.02, 0, 0.28, 0.05, 2.1);
            const forearmR = skeleton.addBone('forearm_R', upperArmR, 0, -0.28, 0, 0.24, 0.04, 1.6);
            const handR = skeleton.addBone('hand_R', forearmR, 0, -0.24, 0, 0.08, 0.035, 0.8);
            
            // Left arm
            const clavL = skeleton.addBone('clav_L', chest, -0.08, 0.10, 0, 0.14, 0.02, 0.4);
            const scapL = skeleton.addBone('scap_L', clavL, -0.14, 0, 0, 0.05, 0.06, 0.3);
            const upperArmL = skeleton.addBone('upperArm_L', scapL, -0.05, -0.02, 0, 0.28, 0.05, 2.1);
            const forearmL = skeleton.addBone('forearm_L', upperArmL, 0, -0.28, 0, 0.24, 0.04, 1.6);
            const handL = skeleton.addBone('hand_L', forearmL, 0, -0.24, 0, 0.08, 0.035, 0.8);
            
            // Right leg
            const thighR = skeleton.addBone('thigh_R', pelvis, 0.10, -0.08, 0, 0.40, 0.06, 7.5);
            const shinR = skeleton.addBone('shin_R', thighR, 0, -0.40, 0, 0.38, 0.045, 3.8);
            const footR = skeleton.addBone('foot_R', shinR, 0, -0.38, 0.05, 0.10, 0.035, 0.8);
            const toeR = skeleton.addBone('toe_R', footR, 0, -0.02, 0.08, 0.05, 0.02, 0.2);
            
            // Left leg
            const thighL = skeleton.addBone('thigh_L', pelvis, -0.10, -0.08, 0, 0.40, 0.06, 7.5);
            const shinL = skeleton.addBone('shin_L', thighL, 0, -0.40, 0, 0.38, 0.045, 3.8);
            const footL = skeleton.addBone('foot_L', shinL, 0, -0.38, 0.05, 0.10, 0.035, 0.8);
            const toeL = skeleton.addBone('toe_L', footL, 0, -0.02, 0.08, 0.05, 0.02, 0.2);
            
            // Add joints
            // Spine
            skeleton.addJoint('spine01', pelvis, spine01, JointType.SWING_TWIST,
                -30*DEG2RAD, -30*DEG2RAD, -15*DEG2RAD, 30*DEG2RAD, 30*DEG2RAD, 15*DEG2RAD, 200, 30);
            skeleton.addJoint('spine02', spine01, spine02, JointType.SWING_TWIST,
                -30*DEG2RAD, -30*DEG2RAD, -15*DEG2RAD, 30*DEG2RAD, 30*DEG2RAD, 15*DEG2RAD, 200, 30);
            skeleton.addJoint('spine03', spine02, spine03, JointType.SWING_TWIST,
                -30*DEG2RAD, -30*DEG2RAD, -15*DEG2RAD, 30*DEG2RAD, 30*DEG2RAD, 15*DEG2RAD, 200, 30);
            skeleton.addJoint('chest', spine03, chest, JointType.SWING_TWIST,
                -30*DEG2RAD, -30*DEG2RAD, -15*DEG2RAD, 30*DEG2RAD, 30*DEG2RAD, 15*DEG2RAD, 220, 35);
            
            // Neck & head
            skeleton.addJoint('neck', chest, neck, JointType.BALL,
                -45*DEG2RAD, -60*DEG2RAD, -80*DEG2RAD, 60*DEG2RAD, 45*DEG2RAD, 80*DEG2RAD, 150, 25);
            skeleton.addJoint('head', neck, head, JointType.BALL,
                -20*DEG2RAD, -10*DEG2RAD, -30*DEG2RAD, 20*DEG2RAD, 10*DEG2RAD, 30*DEG2RAD, 120, 20);
            
            // Right arm
            skeleton.addJoint('clav_R', chest, clavR, JointType.BALL,
                -10*DEG2RAD, -45*DEG2RAD, -20*DEG2RAD, 15*DEG2RAD, 45*DEG2RAD, 20*DEG2RAD, 100, 15);
            skeleton.addJoint('scap_R', clavR, scapR, JointType.BALL,
                -20*DEG2RAD, -30*DEG2RAD, -60*DEG2RAD, 20*DEG2RAD, 30*DEG2RAD, 0*DEG2RAD, 80, 12);
            skeleton.addJoint('shoulder_R', scapR, upperArmR, JointType.BALL,
                -45*DEG2RAD, -180*DEG2RAD, -90*DEG2RAD, 30*DEG2RAD, 180*DEG2RAD, 70*DEG2RAD, 150, 20);
            skeleton.addJoint('elbow_R', upperArmR, forearmR, JointType.HINGE,
                -5*DEG2RAD, 0, 0, 150*DEG2RAD, 0, 0, 180, 25);
            skeleton.addJoint('wrist_R', forearmR, handR, JointType.BALL,
                -80*DEG2RAD, -20*DEG2RAD, -80*DEG2RAD, 70*DEG2RAD, 30*DEG2RAD, 80*DEG2RAD, 100, 15);
            
            // Left arm
            skeleton.addJoint('clav_L', chest, clavL, JointType.BALL,
                -10*DEG2RAD, -45*DEG2RAD, -20*DEG2RAD, 15*DEG2RAD, 45*DEG2RAD, 20*DEG2RAD, 100, 15);
            skeleton.addJoint('scap_L', clavL, scapL, JointType.BALL,
                -20*DEG2RAD, -30*DEG2RAD, -60*DEG2RAD, 20*DEG2RAD, 30*DEG2RAD, 0*DEG2RAD, 80, 12);
            skeleton.addJoint('shoulder_L', scapL, upperArmL, JointType.BALL,
                -45*DEG2RAD, -180*DEG2RAD, -70*DEG2RAD, 30*DEG2RAD, 180*DEG2RAD, 90*DEG2RAD, 150, 20);
            skeleton.addJoint('elbow_L', upperArmL, forearmL, JointType.HINGE,
                -5*DEG2RAD, 0, 0, 150*DEG2RAD, 0, 0, 180, 25);
            skeleton.addJoint('wrist_L', forearmL, handL, JointType.BALL,
                -80*DEG2RAD, -20*DEG2RAD, -80*DEG2RAD, 70*DEG2RAD, 30*DEG2RAD, 80*DEG2RAD, 100, 15);
            
            // Right leg
            skeleton.addJoint('hip_R', pelvis, thighR, JointType.BALL,
                -120*DEG2RAD, -30*DEG2RAD, -45*DEG2RAD, 20*DEG2RAD, 45*DEG2RAD, 35*DEG2RAD, 200, 30);
            skeleton.addJoint('knee_R', thighR, shinR, JointType.HINGE,
                0, 0, 0, 150*DEG2RAD, 0, 0, 220, 35);
            skeleton.addJoint('ankle_R', shinR, footR, JointType.HINGE,
                -50*DEG2RAD, 0, 0, 20*DEG2RAD, 0, 0, 150, 20);
            skeleton.addJoint('toe_R', footR, toeR, JointType.HINGE,
                -40*DEG2RAD, 0, 0, 65*DEG2RAD, 0, 0, 80, 10);
            
            // Left leg
            skeleton.addJoint('hip_L', pelvis, thighL, JointType.BALL,
                -120*DEG2RAD, -30*DEG2RAD, -35*DEG2RAD, 20*DEG2RAD, 45*DEG2RAD, 45*DEG2RAD, 200, 30);
            skeleton.addJoint('knee_L', thighL, shinL, JointType.HINGE,
                0, 0, 0, 150*DEG2RAD, 0, 0, 220, 35);
            skeleton.addJoint('ankle_L', shinL, footL, JointType.HINGE,
                -50*DEG2RAD, 0, 0, 20*DEG2RAD, 0, 0, 150, 20);
            skeleton.addJoint('toe_L', footL, toeL, JointType.HINGE,
                -40*DEG2RAD, 0, 0, 65*DEG2RAD, 0, 0, 80, 10);
            
            return skeleton;
        }
        
        // ============================================================================
        // THREE.js Renderer
        // ============================================================================
        
        class SkeletonRenderer {
            constructor(container, skeleton) {
                this.skeleton = skeleton;
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000, 0);
                container.appendChild(this.renderer.domElement);
                
                this.camera.position.set(2, 1.5, 3);
                this.camera.lookAt(0, 1, 0);
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight1.position.set(5, 10, 5);
                this.scene.add(dirLight1);
                
                const dirLight2 = new THREE.DirectionalLight(0x4da6ff, 0.4);
                dirLight2.position.set(-5, 5, -5);
                this.scene.add(dirLight2);
                
                // Ground
                const groundGeometry = new THREE.PlaneGeometry(20, 20);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a2e,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                this.scene.add(ground);
                
                const gridHelper = new THREE.GridHelper(20, 20, 0x4da6ff, 0x2a2a3e);
                this.scene.add(gridHelper);
                
                this.boneMeshes = [];
                this.jointMeshes = [];
                this.comMesh = null;
                
                this.showBones = true;
                this.showJoints = true;
                this.showCOM = false;
                
                this.createMeshes();
                this.setupControls();
                
                window.addEventListener('resize', () => this.onResize());
            }
            
            createMeshes() {
                const boneCount = this.skeleton.getBoneCount();
                
                for (let i = 0; i < boneCount; i++) {
                    const length = this.skeleton.getBoneLength(i);
                    const radius = this.skeleton.getBoneRadius(i);
                    
                    const geometry = new THREE.CapsuleGeometry(radius, length, 8, 16);
                    const material = new THREE.MeshStandardMaterial({
                        color: 0x4da6ff,
                        roughness: 0.5,
                        metalness: 0.3,
                        emissive: 0x1a3a5f,
                        emissiveIntensity: 0.2
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    this.scene.add(mesh);
                    this.boneMeshes.push(mesh);
                }
                
                const jointCount = this.skeleton.getJointCount();
                
                for (let i = 0; i < jointCount; i++) {
                    const geometry = new THREE.SphereGeometry(0.03, 16, 16);
                    const material = new THREE.MeshStandardMaterial({
                        color: 0xff6b6b,
                        emissive: 0xff6b6b,
                        emissiveIntensity: 0.5
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    this.scene.add(mesh);
                    this.jointMeshes.push(mesh);
                }
                
                // COM mesh
                const comGeom = new THREE.SphereGeometry(0.06, 16, 16);
                const comMat = new THREE.MeshStandardMaterial({
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.8
                });
                this.comMesh = new THREE.Mesh(comGeom, comMat);
                this.scene.add(this.comMesh);
            }
            
            setupControls() {
                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };
                let isRightDrag = false;
                
                this.renderer.domElement.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    isRightDrag = e.button === 2;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                });
                
                this.renderer.domElement.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    if (isRightDrag) {
                        const panSpeed = 0.002;
                        this.camera.position.x -= deltaX * panSpeed;
                        this.camera.position.y += deltaY * panSpeed;
                    } else {
                        const rotateSpeed = 0.005;
                        const radius = Math.sqrt(this.camera.position.x ** 2 + this.camera.position.z ** 2);
                        const angle = Math.atan2(this.camera.position.z, this.camera.position.x);
                        
                        this.camera.position.x = radius * Math.cos(angle - deltaX * rotateSpeed);
                        this.camera.position.z = radius * Math.sin(angle - deltaX * rotateSpeed);
                        this.camera.position.y += deltaY * rotateSpeed;
                        
                        this.camera.lookAt(0, 1, 0);
                    }
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                });
                
                this.renderer.domElement.addEventListener('mouseup', () => {
                    isDragging = false;
                });
                
                this.renderer.domElement.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomSpeed = 0.001;
                    const direction = new THREE.Vector3();
                    this.camera.getWorldDirection(direction);
                    
                    this.camera.position.add(direction.multiplyScalar(e.deltaY * zoomSpeed));
                });
                
                this.renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            update() {
                const boneCount = this.skeleton.getBoneCount();
                
                for (let i = 0; i < boneCount; i++) {
                    const pos = this.skeleton.getBonePosition(i);
                    const rot = this.skeleton.getBoneRotation(i);
                    
                    this.boneMeshes[i].position.set(pos.x, pos.y, pos.z);
                    this.boneMeshes[i].quaternion.set(rot.x, rot.y, rot.z, rot.w);
                    this.boneMeshes[i].visible = this.showBones;
                }
                
                const jointCount = this.skeleton.getJointCount();
                
                for (let i = 0; i < jointCount; i++) {
                    const boneIdx = this.skeleton.getJointChildBoneIndex(i);
                    if (boneIdx >= 0) {
                        const pos = this.skeleton.getBonePosition(boneIdx);
                        this.jointMeshes[i].position.set(pos.x, pos.y, pos.z);
                        this.jointMeshes[i].visible = this.showJoints;
                    }
                }
                
                const com = this.skeleton.computeCenterOfMass();
                this.comMesh.position.set(com.x, com.y, com.z);
                this.comMesh.visible = this.showCOM;
            }
            
            render() {
                this.renderer.render(this.scene, this.camera);
            }
            
            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        // ============================================================================
        // Pose Controller
        // ============================================================================
        
        class PoseController {
            constructor(skeleton) {
                this.skeleton = skeleton;
                this.jointMap = new Map();
                
                const jointCount = skeleton.getJointCount();
                for (let i = 0; i < jointCount; i++) {
                    const name = skeleton.getJointName(i);
                    this.jointMap.set(name, i);
                }
            }
            
            setPose(poseName) {
                const poses = {
                    'apose': {
                        'shoulder_R': [0, 30*DEG2RAD, 0],
                        'shoulder_L': [0, -30*DEG2RAD, 0]
                    },
                    'tpose': {
                        'shoulder_R': [0, 90*DEG2RAD, 0],
                        'shoulder_L': [0, -90*DEG2RAD, 0]
                    },
                    'sit': {
                        'hip_R': [-90*DEG2RAD, 0, 0],
                        'hip_L': [-90*DEG2RAD, 0, 0],
                        'knee_R': [90*DEG2RAD, 0, 0],
                        'knee_L': [90*DEG2RAD, 0, 0]
                    },
                    'squat': {
                        'hip_R': [-110*DEG2RAD, 0, 0],
                        'hip_L': [-110*DEG2RAD, 0, 0],
                        'knee_R': [130*DEG2RAD, 0, 0],
                        'knee_L': [130*DEG2RAD, 0, 0],
                        'ankle_R': [20*DEG2RAD, 0, 0],
                        'ankle_L': [20*DEG2RAD, 0, 0]
                    },
                    'reach': {
                        'shoulder_R': [0, 120*DEG2RAD, 0],
                        'shoulder_L': [0, 120*DEG2RAD, 0],
                        'elbow_R': [10*DEG2RAD, 0, 0],
                        'elbow_L': [10*DEG2RAD, 0, 0]
                    },
                    'wave': {
                        'shoulder_R': [0, 150*DEG2RAD, 0],
                        'elbow_R': [90*DEG2RAD, 0, 0]
                    }
                };
                
                const pose = poses[poseName];
                if (pose) {
                    for (const [jointName, angles] of Object.entries(pose)) {
                        const jointIdx = this.jointMap.get(jointName);
                        if (jointIdx !== undefined) {
                            this.skeleton.setJointTargetAngles(jointIdx, angles[0], angles[1], angles[2]);
                        }
                    }
                }
            }
            
            reset() {
                this.jointMap.forEach((idx) => {
                    this.skeleton.setJointTargetAngles(idx, 0, 0, 0);
                });
            }
        }
        
        // ============================================================================
        // Main Application
        // ============================================================================
        
        async function main() {
            // Initialize physics
            await initPhysics();
            
            updateLoadStatus('Creating skeleton...');
            const skeleton = createSkeleton();
            
            updateLoadStatus('Initializing renderer...');
            const renderer = new SkeletonRenderer(document.getElementById('canvas-container'), skeleton);
            const poseController = new PoseController(skeleton);
            
            // Update info
            document.getElementById('bone-count').textContent = skeleton.getBoneCount();
            document.getElementById('joint-count').textContent = skeleton.getJointCount();
            
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 500);
            
            // Setup UI
            setupUI(skeleton, renderer, poseController);
            
            // Animation loop
            let lastTime = performance.now();
            let frameCount = 0;
            let lastFpsUpdate = lastTime;
            
            function animate() {
                requestAnimationFrame(animate);
                
                const currentTime = performance.now();
                const dt = Math.min((currentTime - lastTime) / 1000, 0.033);
                lastTime = currentTime;
                
                // Update physics
                const physicsStart = performance.now();
                skeleton.update(dt);
                const physicsTime = performance.now() - physicsStart;
                
                // Update renderer
                const renderStart = performance.now();
                renderer.update();
                renderer.render();
                const renderTime = performance.now() - renderStart;
                
                // Update performance stats
                document.getElementById('perf-physics').textContent = physicsTime.toFixed(2) + 'ms';
                document.getElementById('perf-render').textContent = renderTime.toFixed(2) + 'ms';
                document.getElementById('perf-total').textContent = (physicsTime + renderTime).toFixed(2) + 'ms';
                
                // Update FPS
                frameCount++;
                if (frameCount % 30 === 0) {
                    const fps = Math.round(30000 / (currentTime - lastFpsUpdate));
                    document.getElementById('fps').textContent = fps;
                    lastFpsUpdate = currentTime;
                }
            }
            
            animate();
        }
        
        function setupUI(skeleton, renderer, poseController) {
            // Pose buttons
            document.getElementById('btn-apose').addEventListener('click', () => {
                poseController.setPose('apose');
            });
            
            document.getElementById('btn-tpose').addEventListener('click', () => {
                poseController.setPose('tpose');
            });
            
            document.getElementById('btn-sit').addEventListener('click', () => {
                poseController.setPose('sit');
            });
            
            document.getElementById('btn-squat').addEventListener('click', () => {
                poseController.setPose('squat');
            });
            
            document.getElementById('btn-reach').addEventListener('click', () => {
                poseController.setPose('reach');
            });
            
            document.getElementById('btn-wave').addEventListener('click', () => {
                poseController.setPose('wave');
            });
            
            // Physics controls
            document.getElementById('chk-physics').addEventListener('change', (e) => {
                skeleton.setPhysicsEnabled(e.target.checked);
            });
            
            document.getElementById('chk-gravity').addEventListener('change', (e) => {
                skeleton.setGravityEnabled(e.target.checked);
            });
            
            document.getElementById('slider-stiffness').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('val-stiffness').textContent = value;
                skeleton.setGlobalStiffness(value / 100);
            });
            
            document.getElementById('slider-damping').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('val-damping').textContent = value;
                skeleton.setGlobalDamping(value / 20);
            });
            
            // Visualization
            document.getElementById('chk-bones').addEventListener('change', (e) => {
                renderer.showBones = e.target.checked;
            });
            
            document.getElementById('chk-joints').addEventListener('change', (e) => {
                renderer.showJoints = e.target.checked;
            });
            
            document.getElementById('chk-com').addEventListener('change', (e) => {
                renderer.showCOM = e.target.checked;
            });
            
            // Test buttons
            document.getElementById('btn-test-shoulder').addEventListener('click', () => {
                testJointRange(skeleton, poseController, 'shoulder_R', [0, 0, 0], [0, 180*DEG2RAD, 0], 2);
            });
            
            document.getElementById('btn-test-elbow').addEventListener('click', () => {
                testJointRange(skeleton, poseController, 'elbow_R', [0, 0, 0], [150*DEG2RAD, 0, 0], 3);
            });
            
            document.getElementById('btn-test-knee').addEventListener('click', () => {
                testJointRange(skeleton, poseController, 'knee_R', [0, 0, 0], [150*DEG2RAD, 0, 0], 3);
            });
            
            document.getElementById('btn-reset').addEventListener('click', () => {
                poseController.reset();
            });
        }
        
        function testJointRange(skeleton, poseController, jointName, startAngles, endAngles, speed) {
            let t = 0;
            const step = 0.02 * speed;
            
            const interval = setInterval(() => {
                t += step;
                
                if (t >= 1.0) {
                    clearInterval(interval);
                    setTimeout(() => poseController.reset(), 1000);
                    return;
                }
                
                const angles = [
                    startAngles[0] + (endAngles[0] - startAngles[0]) * t,
                    startAngles[1] + (endAngles[1] - startAngles[1]) * t,
                    startAngles[2] + (endAngles[2] - startAngles[2]) * t
                ];
                
                const jointMap = new Map();
                const jointCount = skeleton.getJointCount();
                for (let i = 0; i < jointCount; i++) {
                    const name = skeleton.getJointName(i);
                    jointMap.set(name, i);
                }
                
                const jointIdx = jointMap.get(jointName);
                if (jointIdx !== undefined) {
                    skeleton.setJointTargetAngles(jointIdx, angles[0], angles[1], angles[2]);
                }
            }, 50);
        }
        
        // Start the application
        main().catch(error => {
            console.error('Failed to initialize application:', error);
            document.getElementById('load-status').textContent = 'Error: ' + error.message;
        });
    </script>
</body>
</html>
