/**
 * Enhanced Multiplayer Synchronization Tests
 * Comprehensive test suite for rollback netcode, desync detection, host migration,
 * and performance optimization systems
 */

import { describe, it, beforeEach, afterEach, expect, vi } from 'vitest'
import RollbackNetcode from '../../src/netcode/rollback-netcode.js'
import DesyncDetectionSystem from '../../src/netcode/desync-detection.js'
import HostMigrationSystem from '../../src/netcode/host-migration.js'
import NetworkDiagnostics from '../../src/netcode/network-diagnostics.js'
import RollbackPerformanceOptimizer from '../../src/netcode/rollback-performance-optimizer.js'

// Mock WASM module
const createMockWasmModule = () => ({
  saveState: vi.fn(() => ({ frame: 0, data: 'mock_state' })),
  loadState: vi.fn(),
  update: vi.fn(),
  getChecksum: vi.fn(() => 12345),
  getWasmState: vi.fn(() => new Uint8Array([1, 2, 3, 4])),
  setWasmState: vi.fn(),
  validateWasmState: vi.fn(() => true)
})

// Mock network callbacks
const createMockNetworkCallbacks = () => ({
  sendToPeer: vi.fn(),
  broadcastMessage: vi.fn(),
  getPeerConnection: vi.fn(() => ({
    iceConnectionState: 'connected',
    connectionState: 'connected',
    getStats: vi.fn(() => Promise.resolve(new Map()))
  }))
})

describe('Enhanced Rollback Netcode', () => {
  let rollbackNetcode
  let mockWasm
  let mockNetwork
  
  beforeEach(() => {
    mockWasm = createMockWasmModule()
    mockNetwork = createMockNetworkCallbacks()
    rollbackNetcode = new RollbackNetcode({
      maxRollbackFrames: 8,
      inputDelayFrames: 2,
      enableStateCompression: true,
      logLevel: 'error' // Suppress logs during tests
    })
  })
  
  afterEach(() => {
    rollbackNetcode.stop()
    vi.clearAllMocks()
  })
  
  describe('Initialization', () => {
    it('should initialize with WASM integration', () => {\n      rollbackNetcode.initialize({\n        saveState: mockWasm.saveState,\n        loadState: mockWasm.loadState,\n        advanceFrame: mockWasm.update,\n        getChecksum: mockWasm.getChecksum,\n        getWasmState: mockWasm.getWasmState,\n        setWasmState: mockWasm.setWasmState\n      }, 'player1', mockWasm)\n      \n      expect(rollbackNetcode.wasmIntegration.module).toBe(mockWasm)\n      expect(rollbackNetcode.localPlayerId).toBe('player1')\n      expect(rollbackNetcode.players.has('player1')).toBe(true)\n    })\n    \n    it('should initialize enhanced frame history', () => {\n      rollbackNetcode.initialize({\n        saveState: mockWasm.saveState,\n        loadState: mockWasm.loadState,\n        advanceFrame: mockWasm.update,\n        getChecksum: mockWasm.getChecksum\n      }, 'player1')\n      \n      expect(rollbackNetcode.frameHistory.length).toBeGreaterThan(8)\n      expect(rollbackNetcode.frameHistory[0]).toHaveProperty('enhancedChecksum')\n      expect(rollbackNetcode.frameHistory[0]).toHaveProperty('compressedState')\n    })\n  })\n  \n  describe('Enhanced State Management', () => {\n    beforeEach(() => {\n      rollbackNetcode.initialize({\n        saveState: mockWasm.saveState,\n        loadState: mockWasm.loadState,\n        advanceFrame: mockWasm.update,\n        getChecksum: mockWasm.getChecksum,\n        getWasmState: mockWasm.getWasmState\n      }, 'player1', mockWasm)\n    })\n    \n    it('should save frame state with enhanced checksums', () => {\n      rollbackNetcode.saveFrameState(5)\n      \n      const savedState = rollbackNetcode.frameHistory[5 % rollbackNetcode.frameHistory.length]\n      expect(savedState.frame).toBe(5)\n      expect(savedState.checksum).toBeDefined()\n      expect(savedState.enhancedChecksum).toBeDefined()\n      expect(mockWasm.saveState).toHaveBeenCalled()\n    })\n    \n    it('should compress large states', () => {\n      const largeState = { data: 'x'.repeat(2000) } // Large state\n      mockWasm.saveState.mockReturnValue(largeState)\n      \n      rollbackNetcode.saveFrameState(10)\n      \n      const savedState = rollbackNetcode.frameHistory[10 % rollbackNetcode.frameHistory.length]\n      expect(savedState.stateSize).toBeGreaterThan(1000)\n    })\n    \n    it('should find and decompress saved states', () => {\n      rollbackNetcode.saveFrameState(15)\n      \n      const foundState = rollbackNetcode.findSavedState(15)\n      expect(foundState).toBeDefined()\n      expect(foundState.frame).toBe(15)\n    })\n  })\n  \n  describe('Enhanced Sync Testing', () => {\n    beforeEach(() => {\n      rollbackNetcode.initialize({\n        saveState: mockWasm.saveState,\n        loadState: mockWasm.loadState,\n        advanceFrame: mockWasm.update,\n        getChecksum: mockWasm.getChecksum,\n        getWasmState: mockWasm.getWasmState\n      }, 'player1', mockWasm)\n      \n      rollbackNetcode.addPlayer('player2')\n      rollbackNetcode.onSendSyncTest = vi.fn()\n    })\n    \n    it('should perform enhanced sync test with multiple checksums', () => {\n      rollbackNetcode.currentFrame = 30\n      rollbackNetcode.performSyncTest()\n      \n      expect(rollbackNetcode.onSendSyncTest).toHaveBeenCalledWith(30, expect.objectContaining({\n        basic: expect.any(Number),\n        enhanced: expect.any(Number),\n        frame: 30,\n        timestamp: expect.any(Number)\n      }))\n    })\n    \n    it('should detect basic desync', () => {\n      const desyncHandler = vi.fn()\n      rollbackNetcode.onDesyncDetected = desyncHandler\n      \n      rollbackNetcode.currentFrame = 25\n      rollbackNetcode.saveFrameState(25)\n      \n      // Simulate receiving different checksum\n      rollbackNetcode.receiveSyncTest('player2', 25, {\n        basic: 99999, // Different from local\n        enhanced: 88888\n      })\n      \n      expect(desyncHandler).toHaveBeenCalled()\n    })\n    \n    it('should handle successful sync', () => {\n      rollbackNetcode.currentFrame = 20\n      rollbackNetcode.saveFrameState(20)\n      \n      const localChecksum = mockWasm.getChecksum()\n      \n      // Simulate receiving same checksum\n      rollbackNetcode.receiveSyncTest('player2', 20, {\n        basic: localChecksum,\n        enhanced: 0\n      })\n      \n      const player = rollbackNetcode.players.get('player2')\n      expect(player.desyncCount).toBe(0)\n    })\n  })\n  \n  describe('Network Quality Assessment', () => {\n    beforeEach(() => {\n      rollbackNetcode.initialize({\n        saveState: mockWasm.saveState,\n        loadState: mockWasm.loadState,\n        advanceFrame: mockWasm.update,\n        getChecksum: mockWasm.getChecksum\n      }, 'player1')\n    })\n    \n    it('should calculate connection quality', () => {\n      const player = {\n        desyncCount: 2,\n        inputLossCount: 1,\n        avgLatency: 75\n      }\n      \n      const quality = rollbackNetcode.calculateConnectionQuality(player)\n      expect(['excellent', 'good', 'fair', 'poor']).toContain(quality)\n    })\n    \n    it('should update network quality metrics', () => {\n      rollbackNetcode.addPlayer('player2', 2, { quality: 'good' })\n      rollbackNetcode.updateNetworkQuality()\n      \n      expect(['good', 'fair', 'poor']).toContain(rollbackNetcode.metrics.networkQuality)\n    })\n  })\n  \n  describe('Performance Metrics', () => {\n    beforeEach(() => {\n      rollbackNetcode.initialize({\n        saveState: mockWasm.saveState,\n        loadState: mockWasm.loadState,\n        advanceFrame: mockWasm.update,\n        getChecksum: mockWasm.getChecksum\n      }, 'player1')\n    })\n    \n    it('should track comprehensive metrics', () => {\n      rollbackNetcode.addPlayer('player2')\n      rollbackNetcode.metrics.rollbacks = 5\n      rollbackNetcode.metrics.desyncCount = 2\n      \n      const metrics = rollbackNetcode.getMetrics()\n      \n      expect(metrics).toHaveProperty('rollbacks', 5)\n      expect(metrics).toHaveProperty('desyncCount', 2)\n      expect(metrics).toHaveProperty('networkDiagnostics')\n      expect(metrics).toHaveProperty('playerMetrics')\n      expect(Array.isArray(metrics.playerMetrics)).toBe(true)\n    })\n  })\n})\n\ndescribe('Desync Detection System', () => {\n  let desyncDetection\n  let mockValidators\n  let mockRecoveryHandlers\n  \n  beforeEach(() => {\n    mockValidators = {\n      basic: vi.fn(() => 12345),\n      enhanced: vi.fn(() => 67890),\n      deep: vi.fn(() => ({ complex: 'state' })),\n      wasm: vi.fn(() => new Uint8Array([1, 2, 3, 4]))\n    }\n    \n    mockRecoveryHandlers = {\n      onDesyncDetected: vi.fn(),\n      onRecoveryStarted: vi.fn(),\n      onRecoveryCompleted: vi.fn(),\n      requestStateResync: vi.fn(() => Promise.resolve({ synced: 'state' })),\n      requestFullResync: vi.fn(() => Promise.resolve({ full: 'state' }))\n    }\n    \n    desyncDetection = new DesyncDetectionSystem({\n      desyncThreshold: 2,\n      enableDeepValidation: true,\n      enableWasmValidation: true,\n      logLevel: 'error'\n    })\n    \n    desyncDetection.initialize(mockValidators, mockRecoveryHandlers)\n  })\n  \n  describe('Multi-layer Checksum Validation', () => {\n    it('should record local checksums for all layers', () => {\n      desyncDetection.addPlayer('player1')\n      \n      const checksumData = desyncDetection.recordLocalChecksums(100)\n      \n      expect(checksumData.local.basic).toBe(12345)\n      expect(checksumData.local.enhanced).toBe(67890)\n      expect(checksumData.local.deep).toBeDefined()\n      expect(checksumData.local.wasm).toBeDefined()\n      expect(mockValidators.basic).toHaveBeenCalled()\n      expect(mockValidators.enhanced).toHaveBeenCalled()\n    })\n    \n    it('should validate remote checksums against local', () => {\n      desyncDetection.addPlayer('player1')\n      desyncDetection.recordLocalChecksums(50)\n      \n      // Simulate matching checksums\n      desyncDetection.recordRemoteChecksums('player1', 50, {\n        basic: 12345,\n        enhanced: 67890\n      })\n      \n      expect(mockRecoveryHandlers.onDesyncDetected).not.toHaveBeenCalled()\n    })\n    \n    it('should detect desync in any layer', () => {\n      desyncDetection.addPlayer('player1')\n      desyncDetection.recordLocalChecksums(75)\n      \n      // Simulate mismatched checksums\n      desyncDetection.recordRemoteChecksums('player1', 75, {\n        basic: 99999, // Different\n        enhanced: 67890 // Same\n      })\n      \n      expect(mockRecoveryHandlers.onDesyncDetected).toHaveBeenCalledWith(\n        expect.objectContaining({\n          playerId: 'player1',\n          frame: 75,\n          layers: expect.objectContaining({\n            basic: expect.objectContaining({ match: false }),\n            enhanced: expect.objectContaining({ match: true })\n          })\n        })\n      )\n    })\n  })\n  \n  describe('Automatic Recovery', () => {\n    beforeEach(() => {\n      desyncDetection.addPlayer('player1')\n    })\n    \n    it('should trigger recovery after threshold desyncs', async () => {\n      // Cause multiple desyncs to exceed threshold\n      for (let i = 0; i < 3; i++) {\n        desyncDetection.recordLocalChecksums(i)\n        desyncDetection.recordRemoteChecksums('player1', i, { basic: 99999 })\n      }\n      \n      // Wait for async recovery\n      await new Promise(resolve => setTimeout(resolve, 100))\n      \n      expect(mockRecoveryHandlers.onRecoveryStarted).toHaveBeenCalled()\n    })\n    \n    it('should attempt state resync first', async () => {\n      const playerTracker = desyncDetection.playerDesyncs.get('player1')\n      playerTracker.consecutiveDesyncs = 3\n      \n      await desyncDetection.triggerDesyncRecovery(playerTracker, {\n        playerId: 'player1',\n        frame: 100\n      })\n      \n      expect(mockRecoveryHandlers.requestStateResync).toHaveBeenCalledWith('player1', 100)\n      expect(mockRecoveryHandlers.onRecoveryCompleted).toHaveBeenCalledWith(true, 'state_resync')\n    })\n    \n    it('should fall back to full resync if state resync fails', async () => {\n      mockRecoveryHandlers.requestStateResync.mockRejectedValue(new Error('State resync failed'))\n      \n      const playerTracker = desyncDetection.playerDesyncs.get('player1')\n      playerTracker.consecutiveDesyncs = 3\n      \n      await desyncDetection.triggerDesyncRecovery(playerTracker, {\n        playerId: 'player1',\n        frame: 100\n      })\n      \n      expect(mockRecoveryHandlers.requestFullResync).toHaveBeenCalled()\n    })\n  })\n  \n  describe('Statistics and Quality Assessment', () => {\n    it('should track comprehensive statistics', () => {\n      desyncDetection.addPlayer('player1')\n      desyncDetection.addPlayer('player2')\n      \n      // Simulate some activity\n      desyncDetection.stats.totalDesyncs = 5\n      desyncDetection.stats.recoveryAttempts = 3\n      desyncDetection.stats.successfulRecoveries = 2\n      \n      const stats = desyncDetection.getStats()\n      \n      expect(stats.global.totalDesyncs).toBe(5)\n      expect(stats.global.successRate).toBe(2/3)\n      expect(stats.players).toHaveLength(2)\n    })\n    \n    it('should calculate connection quality based on desync history', () => {\n      const playerTracker = {\n        desyncCount: 10,\n        consecutiveDesyncs: 1\n      }\n      \n      desyncDetection.checksumHistory.set(1, {}) // Mock history size\n      const quality = desyncDetection.calculateConnectionQuality(playerTracker)\n      \n      expect(['excellent', 'good', 'fair', 'poor']).toContain(quality)\n    })\n  })\n})\n\ndescribe('Host Migration System', () => {\n  let hostMigration\n  let mockGameIntegration\n  let mockNetworkCallbacks\n  let mockEventHandlers\n  \n  beforeEach(() => {\n    mockGameIntegration = {\n      saveState: vi.fn(() => ({ migrated: 'state' })),\n      loadState: vi.fn(),\n      pauseGame: vi.fn(),\n      resumeGame: vi.fn(),\n      validateState: vi.fn(() => true),\n      getFrameNumber: vi.fn(() => 100),\n      rollbackToFrame: vi.fn()\n    }\n    \n    mockNetworkCallbacks = createMockNetworkCallbacks()\n    \n    mockEventHandlers = {\n      onMigrationStarted: vi.fn(),\n      onMigrationCompleted: vi.fn(),\n      onHostChanged: vi.fn(),\n      onMigrationFailed: vi.fn()\n    }\n    \n    hostMigration = new HostMigrationSystem({\n      migrationTimeout: 1000,\n      maxRetryAttempts: 2,\n      enableAutomaticMigration: true,\n      logLevel: 'error'\n    })\n    \n    hostMigration.initialize(mockGameIntegration, mockNetworkCallbacks, mockEventHandlers)\n  })\n  \n  describe('Host Selection', () => {\n    beforeEach(() => {\n      hostMigration.sessionState.localPlayerId = 'player1'\n      hostMigration.addPlayer('player2', {\n        connectionQuality: 'good',\n        latency: 50,\n        performance: 'excellent',\n        stability: 0.95\n      })\n      hostMigration.addPlayer('player3', {\n        connectionQuality: 'fair',\n        latency: 150,\n        performance: 'good',\n        stability: 0.8\n      })\n    })\n    \n    it('should calculate host scores correctly', () => {\n      const player2 = hostMigration.sessionState.players.get('player2')\n      const player3 = hostMigration.sessionState.players.get('player3')\n      \n      const score2 = hostMigration.calculateHostScore(player2)\n      const score3 = hostMigration.calculateHostScore(player3)\n      \n      expect(score2).toBeGreaterThan(score3) // Better player should have higher score\n      expect(score2).toBeLessThanOrEqual(1)\n      expect(score3).toBeGreaterThanOrEqual(0)\n    })\n    \n    it('should select best candidate as new host', () => {\n      const newHost = hostMigration.selectNewHost('oldHost')\n      \n      expect(newHost).toBeDefined()\n      expect(newHost.id).toBe('player2') // Should select the better player\n      expect(newHost.score).toBeGreaterThan(0)\n    })\n    \n    it('should select local player if no other candidates', () => {\n      hostMigration.sessionState.players.clear()\n      \n      const newHost = hostMigration.selectNewHost()\n      \n      expect(newHost.id).toBe('player1')\n      expect(newHost.criteria.local).toBe(true)\n    })\n  })\n  \n  describe('Migration Process', () => {\n    beforeEach(() => {\n      hostMigration.sessionState.localPlayerId = 'player1'\n      hostMigration.addPlayer('player2')\n    })\n    \n    it('should trigger migration on host disconnection', async () => {\n      hostMigration.removePlayer('currentHost')\n      \n      // Wait for async migration trigger\n      await new Promise(resolve => setTimeout(resolve, 100))\n      \n      expect(mockEventHandlers.onMigrationStarted).toHaveBeenCalled()\n    })\n    \n    it('should pause and resume game during migration', async () => {\n      await hostMigration.triggerHostMigration('test_migration')\n      \n      expect(mockGameIntegration.pauseGame).toHaveBeenCalled()\n      // Resume is called after migration completes\n    })\n    \n    it('should announce migration to all players', async () => {\n      await hostMigration.announceMigration('newHost', 'test_reason')\n      \n      expect(mockNetworkCallbacks.broadcastMessage).toHaveBeenCalledWith(\n        expect.objectContaining({\n          type: 'host_migration',\n          newHostId: 'newHost',\n          reason: 'test_reason'\n        })\n      )\n    })\n  })\n  \n  describe('Becoming New Host', () => {\n    it('should handle becoming new host', async () => {\n      hostMigration.sessionState.localPlayerId = 'player1'\n      \n      const success = await hostMigration.handleBecomeNewHost()\n      \n      expect(success).toBe(true)\n      expect(hostMigration.sessionState.isHost).toBe(true)\n      expect(hostMigration.sessionState.currentHost).toBe('player1')\n    })\n    \n    it('should validate received state before loading', async () => {\n      mockGameIntegration.validateState.mockReturnValue(false)\n      \n      await hostMigration.handleBecomeNewHost()\n      \n      expect(mockGameIntegration.validateState).toHaveBeenCalled()\n      // Should not load invalid state\n    })\n  })\n  \n  describe('Statistics', () => {\n    it('should track migration statistics', () => {\n      hostMigration.stats.totalMigrations = 5\n      hostMigration.stats.successfulMigrations = 4\n      hostMigration.stats.avgMigrationTime = 250\n      \n      const stats = hostMigration.getStats()\n      \n      expect(stats.migration.totalMigrations).toBe(5)\n      expect(stats.migration.successRate).toBe(0.8)\n      expect(stats.migration.avgMigrationTime).toBe(250)\n    })\n  })\n})\n\ndescribe('Network Diagnostics', () => {\n  let networkDiagnostics\n  let mockNetworkCallbacks\n  \n  beforeEach(() => {\n    mockNetworkCallbacks = createMockNetworkCallbacks()\n    \n    networkDiagnostics = new NetworkDiagnostics({\n      pingInterval: 100, // Faster for testing\n      enableAutomaticTesting: true,\n      logLevel: 'error'\n    })\n    \n    networkDiagnostics.initialize(mockNetworkCallbacks)\n  })\n  \n  afterEach(() => {\n    networkDiagnostics.shutdown()\n  })\n  \n  describe('Peer Management', () => {\n    it('should add peer with initial metrics', () => {\n      networkDiagnostics.addPeer('peer1', {\n        connectionType: 'p2p',\n        region: 'us-east'\n      })\n      \n      expect(networkDiagnostics.peerMetrics.has('peer1')).toBe(true)\n      \n      const metrics = networkDiagnostics.peerMetrics.get('peer1')\n      expect(metrics.connectionType).toBe('p2p')\n      expect(metrics.region).toBe('us-east')\n      expect(metrics.quality.overall).toBe('unknown')\n    })\n    \n    it('should start monitoring when peer is added', () => {\n      networkDiagnostics.addPeer('peer1')\n      \n      expect(networkDiagnostics.testing.pingIntervals.has('peer1')).toBe(true)\n    })\n    \n    it('should stop monitoring when peer is removed', () => {\n      networkDiagnostics.addPeer('peer1')\n      networkDiagnostics.removePeer('peer1')\n      \n      expect(networkDiagnostics.peerMetrics.has('peer1')).toBe(false)\n      expect(networkDiagnostics.testing.pingIntervals.has('peer1')).toBe(false)\n    })\n  })\n  \n  describe('Latency Measurement', () => {\n    beforeEach(() => {\n      networkDiagnostics.addPeer('peer1')\n    })\n    \n    it('should send ping messages', () => {\n      networkDiagnostics.sendPing('peer1')\n      \n      expect(mockNetworkCallbacks.sendToPeer).toHaveBeenCalledWith(\n        'peer1',\n        expect.objectContaining({\n          type: 'network_ping',\n          pingId: expect.any(String),\n          timestamp: expect.any(Number)\n        })\n      )\n    })\n    \n    it('should handle ping responses and calculate latency', () => {\n      const timestamp = performance.now() - 50 // 50ms ago\n      \n      networkDiagnostics.handlePingResponse('peer1', {\n        type: 'network_pong',\n        pingId: 'test_ping',\n        timestamp: timestamp\n      })\n      \n      const metrics = networkDiagnostics.peerMetrics.get('peer1')\n      expect(metrics.latency.current).toBeGreaterThan(40)\n      expect(metrics.latency.current).toBeLessThan(60)\n    })\n    \n    it('should respond to ping requests', () => {\n      networkDiagnostics.handlePingRequest('peer1', {\n        type: 'network_ping',\n        pingId: 'incoming_ping',\n        timestamp: performance.now()\n      })\n      \n      expect(mockNetworkCallbacks.sendToPeer).toHaveBeenCalledWith(\n        'peer1',\n        expect.objectContaining({\n          type: 'network_pong',\n          pingId: 'incoming_ping'\n        })\n      )\n    })\n  })\n  \n  describe('Quality Assessment', () => {\n    beforeEach(() => {\n      networkDiagnostics.addPeer('peer1')\n    })\n    \n    it('should calculate peer quality based on metrics', () => {\n      const metrics = networkDiagnostics.peerMetrics.get('peer1')\n      \n      // Set good metrics\n      metrics.latency.avg = 30\n      metrics.latency.jitter = 5\n      metrics.packetLoss.lossRate = 0.001\n      \n      networkDiagnostics.updatePeerQuality('peer1')\n      \n      expect(metrics.quality.overall).toBe('excellent')\n      expect(metrics.quality.score).toBeGreaterThan(90)\n    })\n    \n    it('should degrade quality with poor metrics', () => {\n      const metrics = networkDiagnostics.peerMetrics.get('peer1')\n      \n      // Set poor metrics\n      metrics.latency.avg = 300\n      metrics.latency.jitter = 100\n      metrics.packetLoss.lossRate = 0.1\n      \n      networkDiagnostics.updatePeerQuality('peer1')\n      \n      expect(metrics.quality.overall).toBe('poor')\n      expect(metrics.quality.score).toBeLessThan(50)\n    })\n  })\n  \n  describe('Global Metrics', () => {\n    it('should calculate global network metrics', () => {\n      networkDiagnostics.addPeer('peer1')\n      networkDiagnostics.addPeer('peer2')\n      \n      const peer1Metrics = networkDiagnostics.peerMetrics.get('peer1')\n      const peer2Metrics = networkDiagnostics.peerMetrics.get('peer2')\n      \n      peer1Metrics.latency.avg = 50\n      peer1Metrics.packetLoss.lossRate = 0.01\n      \n      peer2Metrics.latency.avg = 100\n      peer2Metrics.packetLoss.lossRate = 0.02\n      \n      networkDiagnostics.updateGlobalMetrics()\n      \n      expect(networkDiagnostics.globalMetrics.avgLatency).toBe(75)\n      expect(networkDiagnostics.globalMetrics.avgPacketLoss).toBe(0.015)\n    })\n  })\n  \n  describe('Diagnostics Report', () => {\n    it('should generate comprehensive diagnostics report', () => {\n      networkDiagnostics.addPeer('peer1')\n      \n      const report = networkDiagnostics.getDiagnosticsReport()\n      \n      expect(report).toHaveProperty('timestamp')\n      expect(report).toHaveProperty('global')\n      expect(report).toHaveProperty('peers')\n      expect(report.peers).toHaveLength(1)\n      expect(report.peers[0].peerId).toBe('peer1')\n    })\n    \n    it('should provide network recommendations', () => {\n      networkDiagnostics.addPeer('peer1')\n      \n      // Set poor conditions\n      networkDiagnostics.globalMetrics.avgLatency = 300\n      networkDiagnostics.globalMetrics.avgPacketLoss = 0.1\n      \n      const recommendations = networkDiagnostics.getNetworkRecommendations()\n      \n      expect(recommendations.length).toBeGreaterThan(0)\n      expect(recommendations[0]).toHaveProperty('type')\n      expect(recommendations[0]).toHaveProperty('priority')\n    })\n  })\n})\n\ndescribe('Rollback Performance Optimizer', () => {\n  let optimizer\n  \n  beforeEach(() => {\n    optimizer = new RollbackPerformanceOptimizer({\n      compressionAlgorithm: 'custom',\n      batchStrategy: 'adaptive',\n      enableAdaptiveOptimization: true,\n      logLevel: 'error'\n    })\n  })\n  \n  afterEach(() => {\n    optimizer.shutdown()\n  })\n  \n  describe('State Optimization', () => {\n    it('should optimize state for saving', () => {\n      const originalState = { data: 'test_data', frame: 100 }\n      \n      const optimizedState = optimizer.optimizeStateForSaving(originalState, 100)\n      \n      expect(optimizedState).toBeDefined()\n      expect(optimizer.metrics.frameProcessing.totalFrames).toBe(1)\n    })\n    \n    it('should compress large states', () => {\n      const largeState = { data: 'x'.repeat(2000) }\n      \n      const compressed = optimizer.strategies.compression.compress(largeState)\n      \n      expect(compressed).toHaveProperty('type', 'custom_compressed')\n      expect(compressed.compressedSize).toBeLessThan(compressed.originalSize)\n    })\n    \n    it('should decompress compressed states', () => {\n      const originalState = { test: 'data', number: 42 }\n      const compressed = optimizer.strategies.compression.compress(originalState)\n      const decompressed = optimizer.strategies.compression.decompress(compressed)\n      \n      expect(decompressed).toEqual(originalState)\n    })\n  })\n  \n  describe('Input Batching', () => {\n    it('should batch inputs when appropriate', () => {\n      const input1 = { type: 'move', x: 1, y: 0 }\n      const input2 = { type: 'move', x: 0, y: 1 }\n      \n      const result1 = optimizer.optimizeInputBatching(input1, 10)\n      const result2 = optimizer.optimizeInputBatching(input2, 11)\n      \n      expect(result1.immediate).toBe(false)\n      expect(optimizer.batchQueue.length).toBeGreaterThan(0)\n    })\n    \n    it('should flush batch when full', () => {\n      // Fill batch to capacity\n      const largeInput = { data: 'x'.repeat(4000) }\n      \n      const result = optimizer.optimizeInputBatching(largeInput, 20)\n      \n      // Should trigger flush due to size\n      expect(result.inputs.length).toBeGreaterThanOrEqual(0)\n    })\n  })\n  \n  describe('Delta Compression', () => {\n    it('should apply delta compression to similar states', () => {\n      const state1 = { x: 10, y: 20, health: 100 }\n      const state2 = { x: 11, y: 20, health: 100 } // Only x changed\n      \n      optimizer.deltaStates.set(99, state1)\n      \n      const deltaState = optimizer.applyDeltaCompression(state2, 100)\n      \n      if (deltaState.type === 'delta') {\n        expect(deltaState.delta).toHaveProperty('x', 11)\n        expect(deltaState.delta).not.toHaveProperty('y')\n        expect(deltaState.delta).not.toHaveProperty('health')\n      }\n    })\n    \n    it('should decompress delta states', () => {\n      const baseState = { x: 10, y: 20, health: 100 }\n      const deltaState = {\n        type: 'delta',\n        baseFrame: 99,\n        delta: { x: 15 },\n        frame: 100\n      }\n      \n      optimizer.deltaStates.set(99, baseState)\n      \n      const decompressed = optimizer.applyDeltaDecompression(deltaState, 100)\n      \n      expect(decompressed).toEqual({ x: 15, y: 20, health: 100 })\n    })\n  })\n  \n  describe('Adaptive Optimization', () => {\n    it('should adapt settings based on network quality', () => {\n      optimizer.adaptiveSettings.networkQuality = 'poor'\n      \n      optimizer.adaptCompressionSettings()\n      optimizer.adaptBatchingSettings()\n      \n      // Should increase compression and batching for poor network\n      expect(optimizer.config.maxBatchSize).toBeGreaterThan(8192)\n    })\n    \n    it('should calculate quality scores', () => {\n      const excellentScore = optimizer.calculateQualityScore('excellent', 20)\n      const poorScore = optimizer.calculateQualityScore('poor', 80)\n      \n      expect(excellentScore).toBeGreaterThan(poorScore)\n      expect(excellentScore).toBeLessThanOrEqual(1.0)\n      expect(poorScore).toBeGreaterThanOrEqual(0.0)\n    })\n  })\n  \n  describe('Performance Statistics', () => {\n    it('should track comprehensive performance stats', () => {\n      // Simulate some activity\n      optimizer.metrics.compression.totalStates = 100\n      optimizer.metrics.compression.compressedStates = 75\n      optimizer.metrics.batching.totalBatches = 20\n      \n      const stats = optimizer.getPerformanceStats()\n      \n      expect(stats).toHaveProperty('compression')\n      expect(stats).toHaveProperty('batching')\n      expect(stats).toHaveProperty('frameProcessing')\n      expect(stats).toHaveProperty('memory')\n      expect(stats).toHaveProperty('network')\n      expect(stats).toHaveProperty('adaptive')\n    })\n  })\n})\n\ndescribe('Integration Tests', () => {\n  let rollbackNetcode\n  let desyncDetection\n  let hostMigration\n  let networkDiagnostics\n  let optimizer\n  \n  beforeEach(() => {\n    // Initialize all systems\n    rollbackNetcode = new RollbackNetcode({ logLevel: 'error' })\n    desyncDetection = new DesyncDetectionSystem({ logLevel: 'error' })\n    hostMigration = new HostMigrationSystem({ logLevel: 'error' })\n    networkDiagnostics = new NetworkDiagnostics({ logLevel: 'error' })\n    optimizer = new RollbackPerformanceOptimizer({ logLevel: 'error' })\n  })\n  \n  afterEach(() => {\n    rollbackNetcode.stop()\n    desyncDetection.reset()\n    hostMigration.shutdown()\n    networkDiagnostics.shutdown()\n    optimizer.shutdown()\n  })\n  \n  it('should integrate rollback netcode with desync detection', () => {\n    const mockWasm = createMockWasmModule()\n    \n    rollbackNetcode.initialize({\n      saveState: mockWasm.saveState,\n      loadState: mockWasm.loadState,\n      advanceFrame: mockWasm.update,\n      getChecksum: mockWasm.getChecksum\n    }, 'player1')\n    \n    desyncDetection.initialize({\n      basic: mockWasm.getChecksum,\n      enhanced: () => 67890\n    }, {\n      onDesyncDetected: (desyncInfo) => {\n        // Trigger rollback on desync\n        if (rollbackNetcode.findSavedState) {\n          const goodFrame = rollbackNetcode.findSavedState(desyncInfo.frame - 5)\n          if (goodFrame) {\n            rollbackNetcode.rollback(goodFrame.frame)\n          }\n        }\n      }\n    })\n    \n    // Systems should work together\n    expect(rollbackNetcode.localPlayerId).toBe('player1')\n    expect(desyncDetection.validators.basic).toBe(mockWasm.getChecksum)\n  })\n  \n  it('should integrate performance optimizer with rollback netcode', () => {\n    const mockWasm = createMockWasmModule()\n    \n    rollbackNetcode.initialize({\n      saveState: (state) => optimizer.optimizeStateForSaving(mockWasm.saveState(), rollbackNetcode.currentFrame),\n      loadState: (state) => mockWasm.loadState(optimizer.optimizeStateForLoading(state, rollbackNetcode.currentFrame)),\n      advanceFrame: mockWasm.update,\n      getChecksum: mockWasm.getChecksum\n    }, 'player1')\n    \n    // Performance optimization should be applied\n    rollbackNetcode.saveFrameState(10)\n    \n    expect(optimizer.metrics.frameProcessing.totalFrames).toBeGreaterThan(0)\n  })\n  \n  it('should coordinate host migration with network diagnostics', async () => {\n    const mockCallbacks = createMockNetworkCallbacks()\n    \n    hostMigration.initialize(\n      { saveState: () => ({}), loadState: () => {} },\n      mockCallbacks\n    )\n    \n    networkDiagnostics.initialize(mockCallbacks, {\n      onQualityChanged: (peerId, quality) => {\n        hostMigration.updatePlayer(peerId, { connectionQuality: quality })\n      }\n    })\n    \n    // Add players to both systems\n    hostMigration.addPlayer('player1', { connectionQuality: 'good' })\n    networkDiagnostics.addPeer('player1')\n    \n    // Quality changes should propagate\n    networkDiagnostics.peerMetrics.get('player1').quality.overall = 'poor'\n    \n    expect(hostMigration.sessionState.players.has('player1')).toBe(true)\n    expect(networkDiagnostics.peerMetrics.has('player1')).toBe(true)\n  })\n})
