<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coordinate System Test - DozedEnt</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #2c5530, #1a3a1f);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .test-section {
            background: rgba(0,0,0,0.8);
            margin: 20px 0;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #4a4a4a;
        }
        
        .test-section h2 {
            color: #ffd700;
            margin-top: 0;
        }
        
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
        }
        
        .test-result.pass {
            background: rgba(0, 255, 0, 0.2);
            border-left: 4px solid #00ff00;
        }
        
        .test-result.fail {
            background: rgba(255, 0, 0, 0.2);
            border-left: 4px solid #ff0000;
        }
        
        .test-result.info {
            background: rgba(0, 150, 255, 0.2);
            border-left: 4px solid #0096ff;
        }
        
        canvas {
            border: 2px solid #4a4a4a;
            background: #87CEEB;
            margin: 10px 0;
        }
        
        .controls {
            margin: 10px 0;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        .coordinate-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        
        .coord-item {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        
        .coord-item .label {
            font-weight: bold;
            color: #ffd700;
        }
        
        .coord-item .value {
            font-family: monospace;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>üß™ DozedEnt Coordinate System Test</h1>
        
        <div class="test-section">
            <h2>üìä Test Results</h2>
            <div id="test-results"></div>
        </div>
        
        <div class="test-section">
            <h2>üéÆ Interactive Test Canvas</h2>
            <canvas id="testCanvas" width="800" height="600"></canvas>
            <div class="controls">
                <button onclick="runAllTests()">Run All Tests</button>
                <button onclick="testCoordinateTransforms()">Test Transforms</button>
                <button onclick="testCameraSystem()">Test Camera</button>
                <button onclick="clearCanvas()">Clear Canvas</button>
            </div>
        </div>
        
        <div class="test-section">
            <h2>üìç Current Coordinates</h2>
            <div class="coordinate-display">
                <div class="coord-item">
                    <div class="label">WASM Coordinates</div>
                    <div class="value" id="wasm-coords">(0.5, 0.5)</div>
                </div>
                <div class="coord-item">
                    <div class="label">World Coordinates</div>
                    <div class="value" id="world-coords">(1280, 720)</div>
                </div>
                <div class="coord-item">
                    <div class="label">Screen Coordinates</div>
                    <div class="value" id="screen-coords">(400, 300)</div>
                </div>
                <div class="coord-item">
                    <div class="label">Camera Position</div>
                    <div class="value" id="camera-coords">(0, 0)</div>
                </div>
            </div>
        </div>
        
        <div class="test-section">
            <h2>üîß Test Configuration</h2>
            <div class="controls">
                <label>
                    <input type="checkbox" id="enableDebug" checked> Enable Debug Visualization
                </label>
                <label>
                    <input type="checkbox" id="enableCameraFollow" checked> Enable Camera Follow
                </label>
                <label>
                    <input type="range" id="wasmX" min="0" max="1" step="0.01" value="0.5" oninput="updateTestPosition()"> WASM X: <span id="wasmXValue">0.5</span>
                </label>
                <label>
                    <input type="range" id="wasmY" min="0" max="1" step="0.01" value="0.5" oninput="updateTestPosition()"> WASM Y: <span id="wasmYValue">0.5</span>
                </label>
            </div>
        </div>
    </div>

    <script type="module">
        // Import the GameRenderer to test coordinate transformations
        import { GameRenderer } from './src/utils/game-renderer.js';
        
        // Test state
        let gameRenderer = null;
        let canvas = null;
        let ctx = null;
        let testResults = [];
        let currentWasmX = 0.5;
        let currentWasmY = 0.5;
        
        // Initialize test
        async function init() {
            canvas = document.getElementById('testCanvas');
            ctx = canvas.getContext('2d');
            
            // Create GameRenderer instance
            gameRenderer = new GameRenderer(ctx, canvas);
            
            // Make it globally available for testing
            window.gameRenderer = gameRenderer;
            
            console.log('üß™ Coordinate System Test Initialized');
            console.log('GameRenderer:', gameRenderer);
            console.log('World dimensions:', gameRenderer.world);
            
            // Run initial tests
            runAllTests();
            
            // Start update loop
            requestAnimationFrame(updateLoop);
        }
        
        // Update loop for interactive testing
        function updateLoop() {
            updateTestPosition();
            renderTestCanvas();
            requestAnimationFrame(updateLoop);
        }
        
        // Update test position based on sliders
        function updateTestPosition() {
            currentWasmX = parseFloat(document.getElementById('wasmX').value);
            currentWasmY = parseFloat(document.getElementById('wasmY').value);
            
            document.getElementById('wasmXValue').textContent = currentWasmX.toFixed(2);
            document.getElementById('wasmYValue').textContent = currentWasmY.toFixed(2);
            
            // Update coordinate displays
            updateCoordinateDisplays();
        }
        
        // Update coordinate displays
        function updateCoordinateDisplays() {
            const wasmCoords = { x: currentWasmX, y: currentWasmY };
            const worldCoords = gameRenderer.wasmToWorld(currentWasmX, currentWasmY);
            const screenCoords = {
                x: worldCoords.x - gameRenderer.camera.x,
                y: worldCoords.y - gameRenderer.camera.y
            };
            const cameraCoords = { x: gameRenderer.camera.x, y: gameRenderer.camera.y };
            
            document.getElementById('wasm-coords').textContent = `(${wasmCoords.x.toFixed(2)}, ${wasmCoords.y.toFixed(2)})`;
            document.getElementById('world-coords').textContent = `(${worldCoords.x.toFixed(0)}, ${worldCoords.y.toFixed(0)})`;
            document.getElementById('screen-coords').textContent = `(${screenCoords.x.toFixed(0)}, ${screenCoords.y.toFixed(0)})`;
            document.getElementById('camera-coords').textContent = `(${cameraCoords.x.toFixed(0)}, ${cameraCoords.y.toFixed(0)})`;
        }
        
        // Render test canvas
        function renderTestCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw world background
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw ground
            const gradient = ctx.createLinearGradient(0, canvas.height * 0.7, 0, canvas.height);
            gradient.addColorStop(0, '#98FB98');
            gradient.addColorStop(1, '#228B22');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, canvas.height * 0.7, canvas.width, canvas.height * 0.3);
            
            // Get current coordinates
            const worldCoords = gameRenderer.wasmToWorld(currentWasmX, currentWasmY);
            const screenCoords = {
                x: worldCoords.x - gameRenderer.camera.x,
                y: worldCoords.y - gameRenderer.camera.y
            };
            
            // Update camera to follow if enabled
            if (document.getElementById('enableCameraFollow').checked) {
                gameRenderer.updateCamera(worldCoords.x, worldCoords.y, 0.016);
            }
            
            // Draw player at current position
            ctx.save();
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(screenCoords.x, screenCoords.y, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw coordinate labels
            if (document.getElementById('enableDebug').checked) {
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px monospace';
                ctx.fillText(`WASM: (${currentWasmX.toFixed(2)}, ${currentWasmY.toFixed(2)})`, screenCoords.x + 15, screenCoords.y - 15);
                ctx.fillText(`World: (${worldCoords.x.toFixed(0)}, ${worldCoords.y.toFixed(0)})`, screenCoords.x + 15, screenCoords.y);
                ctx.fillText(`Screen: (${screenCoords.x.toFixed(0)}, ${screenCoords.y.toFixed(0)})`, screenCoords.x + 15, screenCoords.y + 15);
            }
            ctx.restore();
            
            // Draw world boundaries
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
        }
        
        // Clear canvas
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // Add test result
        function addTestResult(testName, passed, message, details = '') {
            const result = {
                name: testName,
                passed: passed,
                message: message,
                details: details,
                timestamp: new Date().toLocaleTimeString()
            };
            testResults.push(result);
            
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result ${passed ? 'pass' : 'fail'}`;
            resultDiv.innerHTML = `
                <strong>${testName}</strong> - ${passed ? '‚úÖ PASS' : '‚ùå FAIL'}<br>
                ${message}<br>
                ${details ? `<small>${details}</small>` : ''}
                <small style="float: right;">${result.timestamp}</small>
            `;
            
            document.getElementById('test-results').appendChild(resultDiv);
        }
        
        // Test coordinate transformations
        function testCoordinateTransforms() {
            addTestResult('Coordinate Transform Test', true, 'Starting coordinate transformation tests...');
            
            // Test 1: WASM to World transformation
            const testCases = [
                { wasmX: 0, wasmY: 0, expected: 'top-left' },
                { wasmX: 0.5, wasmY: 0.5, expected: 'center' },
                { wasmX: 1, wasmY: 1, expected: 'bottom-right' },
                { wasmX: 0.25, wasmY: 0.75, expected: 'quarter positions' }
            ];
            
            testCases.forEach(testCase => {
                const worldPos = gameRenderer.wasmToWorld(testCase.wasmX, testCase.wasmY);
                const isValid = worldPos.x >= 0 && worldPos.y >= 0 && 
                               worldPos.x <= gameRenderer.world.width && 
                               worldPos.y <= gameRenderer.world.height;
                
                addTestResult(
                    `WASM to World (${testCase.expected})`,
                    isValid,
                    `WASM(${testCase.wasmX}, ${testCase.wasmY}) ‚Üí World(${worldPos.x.toFixed(0)}, ${worldPos.y.toFixed(0)})`,
                    `Expected position in playable area: ${gameRenderer.world.width/3} to ${gameRenderer.world.width*2/3}`
                );
            });
            
            // Test 2: World to WASM transformation
            const worldTestCases = [
                { worldX: gameRenderer.world.width / 3, worldY: gameRenderer.world.height / 3, expected: 'playable top-left' },
                { worldX: gameRenderer.world.width / 2, worldY: gameRenderer.world.height / 2, expected: 'playable center' },
                { worldX: gameRenderer.world.width * 2/3, worldY: gameRenderer.world.height * 2/3, expected: 'playable bottom-right' }
            ];
            
            worldTestCases.forEach(testCase => {
                const wasmPos = gameRenderer.worldToWasm(testCase.worldX, testCase.worldY);
                const isValid = wasmPos.x >= 0 && wasmPos.y >= 0 && wasmPos.x <= 1 && wasmPos.y <= 1;
                
                addTestResult(
                    `World to WASM (${testCase.expected})`,
                    isValid,
                    `World(${testCase.worldX.toFixed(0)}, ${testCase.worldY.toFixed(0)}) ‚Üí WASM(${wasmPos.x.toFixed(2)}, ${wasmPos.y.toFixed(2)})`,
                    `Expected WASM coordinates in range [0,1]`
                );
            });
            
            // Test 3: Round-trip transformation
            const originalWasm = { x: 0.3, y: 0.7 };
            const worldPos = gameRenderer.wasmToWorld(originalWasm.x, originalWasm.y);
            const backToWasm = gameRenderer.worldToWasm(worldPos.x, worldPos.y);
            const roundTripError = Math.abs(originalWasm.x - backToWasm.x) + Math.abs(originalWasm.y - backToWasm.y);
            
            addTestResult(
                'Round-trip Transformation',
                roundTripError < 0.01,
                `WASM(${originalWasm.x}, ${originalWasm.y}) ‚Üí World ‚Üí WASM(${backToWasm.x.toFixed(3)}, ${backToWasm.y.toFixed(3)})`,
                `Round-trip error: ${roundTripError.toFixed(4)} (should be < 0.01)`
            );
        }
        
        // Test camera system
        function testCameraSystem() {
            addTestResult('Camera System Test', true, 'Starting camera system tests...');
            
            // Test 1: Camera bounds
            const bounds = gameRenderer.camera.bounds;
            const boundsValid = bounds.minX >= 0 && bounds.minY >= 0 && 
                               bounds.maxX <= gameRenderer.world.width && 
                               bounds.maxY <= gameRenderer.world.height;
            
            addTestResult(
                'Camera Bounds',
                boundsValid,
                `Camera bounds: min(${bounds.minX.toFixed(0)}, ${bounds.minY.toFixed(0)}) to max(${bounds.maxX.toFixed(0)}, ${bounds.maxY.toFixed(0)})`,
                `World size: ${gameRenderer.world.width}x${gameRenderer.world.height}`
            );
            
            // Test 2: Camera update
            const testWorldX = gameRenderer.world.width / 2;
            const testWorldY = gameRenderer.world.height / 2;
            const originalCameraX = gameRenderer.camera.x;
            const originalCameraY = gameRenderer.camera.y;
            
            gameRenderer.updateCamera(testWorldX, testWorldY, 0.016);
            
            const cameraMoved = Math.abs(gameRenderer.camera.x - originalCameraX) > 0 || 
                               Math.abs(gameRenderer.camera.y - originalCameraY) > 0;
            
            addTestResult(
                'Camera Update',
                cameraMoved,
                `Camera moved from (${originalCameraX.toFixed(0)}, ${originalCameraY.toFixed(0)}) to (${gameRenderer.camera.x.toFixed(0)}, ${gameRenderer.camera.y.toFixed(0)})`,
                `Target was (${testWorldX.toFixed(0)}, ${testWorldY.toFixed(0)})`
            );
            
            // Test 3: Camera centering
            const expectedCameraX = testWorldX - gameRenderer.camera.width / 2;
            const expectedCameraY = testWorldY - gameRenderer.camera.height / 2;
            const centeringError = Math.abs(gameRenderer.camera.x - expectedCameraX) + Math.abs(gameRenderer.camera.y - expectedCameraY);
            
            addTestResult(
                'Camera Centering',
                centeringError < 10,
                `Camera position (${gameRenderer.camera.x.toFixed(0)}, ${gameRenderer.camera.y.toFixed(0)})`,
                `Expected (${expectedCameraX.toFixed(0)}, ${expectedCameraY.toFixed(0)}), error: ${centeringError.toFixed(1)}`
            );
        }
        
        // Run all tests
        function runAllTests() {
            document.getElementById('test-results').innerHTML = '';
            testResults = [];
            
            addTestResult('Test Suite', true, 'Starting comprehensive coordinate system tests...');
            
            testCoordinateTransforms();
            testCameraSystem();
            
            // Summary
            const passed = testResults.filter(r => r.passed).length;
            const total = testResults.length;
            
            addTestResult(
                'Test Summary',
                passed === total,
                `${passed}/${total} tests passed`,
                passed === total ? 'All tests passed! ‚úÖ' : `${total - passed} tests failed ‚ùå`
            );
        }
        
        // Make functions globally available
        window.runAllTests = runAllTests;
        window.testCoordinateTransforms = testCoordinateTransforms;
        window.testCameraSystem = testCameraSystem;
        window.clearCanvas = clearCanvas;
        window.updateTestPosition = updateTestPosition;
        
        // Initialize when page loads
        init().catch(error => {
            console.error('Failed to initialize coordinate test:', error);
            addTestResult('Initialization', false, 'Failed to initialize test suite', error.message);
        });
    </script>
</body>
</html>
