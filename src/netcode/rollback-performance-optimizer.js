/**
 * Rollback Performance Optimizer
 * Optimizes rollback netcode performance through state compression, batching,
 * and adaptive algorithms based on network conditions
 */

import { createLogger } from '../utils/logger.js'

// Constants for performance optimization
const COMPRESSION_ALGORITHMS = {
  NONE: 'none',
  LZ4: 'lz4',
  GZIP: 'gzip',
  CUSTOM: 'custom'
}

const BATCH_STRATEGIES = {
  TIME_BASED: 'time_based',
  SIZE_BASED: 'size_based',
  ADAPTIVE: 'adaptive'
}

const FRAME_SKIP_STRATEGIES = {
  NONE: 'none',
  PREDICTIVE: 'predictive',
  QUALITY_BASED: 'quality_based'
}

export class RollbackPerformanceOptimizer {
  constructor(config = {}) {
    this.config = {
      // Compression settings
      compressionAlgorithm: config.compressionAlgorithm || COMPRESSION_ALGORITHMS.CUSTOM,
      compressionThreshold: config.compressionThreshold || 1024, // bytes
      compressionLevel: config.compressionLevel || 6, // 1-9
      
      // Batching settings
      batchStrategy: config.batchStrategy || BATCH_STRATEGIES.ADAPTIVE,
      maxBatchSize: config.maxBatchSize || 8192, // bytes
      maxBatchTime: config.maxBatchTime || 16, // ms
      minBatchSize: config.minBatchSize || 512, // bytes
      
      // Frame optimization
      frameSkipStrategy: config.frameSkipStrategy || FRAME_SKIP_STRATEGIES.QUALITY_BASED,
      maxFrameSkip: config.maxFrameSkip || 3,
      qualityThreshold: config.qualityThreshold || 0.7,
      
      // Memory optimization
      maxStateHistory: config.maxStateHistory || 60, // frames
      enableStatePooling: config.enableStatePooling !== false,
      enableDeltaCompression: config.enableDeltaCompression !== false,
      
      // Adaptive settings
      enableAdaptiveOptimization: config.enableAdaptiveOptimization !== false,
      performanceTargetFPS: config.performanceTargetFPS || 60,
      adaptationInterval: config.adaptationInterval || 5000, // ms
      
      ...config
    }
    
    this.logger = createLogger({ level: config.logLevel || 'info' })
    
    // Performance metrics
    this.metrics = {
      compression: {
        totalStates: 0,
        compressedStates: 0,
        originalBytes: 0,
        compressedBytes: 0,
        compressionRatio: 0,
        compressionTime: [],
        decompressionTime: []
      },
      
      batching: {
        totalBatches: 0,
        avgBatchSize: 0,
        avgBatchTime: 0,
        batchSizes: [],
        batchTimes: []
      },
      
      frameProcessing: {
        totalFrames: 0,
        skippedFrames: 0,
        avgFrameTime: 0,
        frameTimes: [],
        rollbacks: 0,
        rollbackTime: []
      },
      
      memory: {
        statePoolSize: 0,
        statePoolHits: 0,
        statePoolMisses: 0,
        memoryUsage: 0,
        gcCollections: 0
      },
      
      network: {
        bytesSaved: 0,
        latencyReduction: 0,
        qualityScore: 0
      }
    }
    
    // State management
    this.statePool = new Map() // Reusable state objects
    this.compressionCache = new Map() // Cached compressed states
    this.deltaStates = new Map() // Delta-compressed states
    this.batchQueue = []
    this.batchTimer = null
    
    // Adaptive optimization
    this.adaptiveSettings = {
      currentFPS: 60,
      targetFPS: this.config.performanceTargetFPS,
      networkQuality: 'good',
      cpuUsage: 0,
      memoryPressure: 0,
      lastAdaptation: 0
    }
    
    // Optimization strategies
    this.strategies = {
      compression: null,
      batching: null,
      frameSkipping: null
    }
    
    this.initializeStrategies()
    
    if (this.config.enableAdaptiveOptimization) {
      this.startAdaptiveOptimization()
    }
  }
  
  /**
   * Initialize optimization strategies
   */\n  initializeStrategies() {\n    // Initialize compression strategy\n    this.strategies.compression = this.createCompressionStrategy()\n    \n    // Initialize batching strategy\n    this.strategies.batching = this.createBatchingStrategy()\n    \n    // Initialize frame skipping strategy\n    this.strategies.frameSkipping = this.createFrameSkippingStrategy()\n    \n    this.logger.info('Performance optimization strategies initialized', {\n      compression: this.config.compressionAlgorithm,\n      batching: this.config.batchStrategy,\n      frameSkipping: this.config.frameSkipStrategy\n    })\n  }\n  \n  /**\n   * Create compression strategy\n   */\n  createCompressionStrategy() {\n    switch (this.config.compressionAlgorithm) {\n      case COMPRESSION_ALGORITHMS.LZ4:\n        return {\n          compress: this.compressLZ4.bind(this),\n          decompress: this.decompressLZ4.bind(this),\n          shouldCompress: (data) => this.getDataSize(data) > this.config.compressionThreshold\n        }\n        \n      case COMPRESSION_ALGORITHMS.GZIP:\n        return {\n          compress: this.compressGzip.bind(this),\n          decompress: this.decompressGzip.bind(this),\n          shouldCompress: (data) => this.getDataSize(data) > this.config.compressionThreshold\n        }\n        \n      case COMPRESSION_ALGORITHMS.CUSTOM:\n        return {\n          compress: this.compressCustom.bind(this),\n          decompress: this.decompressCustom.bind(this),\n          shouldCompress: (data) => this.getDataSize(data) > this.config.compressionThreshold\n        }\n        \n      default:\n        return {\n          compress: (data) => data,\n          decompress: (data) => data,\n          shouldCompress: () => false\n        }\n    }\n  }\n  \n  /**\n   * Create batching strategy\n   */\n  createBatchingStrategy() {\n    switch (this.config.batchStrategy) {\n      case BATCH_STRATEGIES.TIME_BASED:\n        return {\n          shouldBatch: () => true,\n          getBatchTimeout: () => this.config.maxBatchTime,\n          canAddToBatch: (batchSize, itemSize) => batchSize + itemSize <= this.config.maxBatchSize\n        }\n        \n      case BATCH_STRATEGIES.SIZE_BASED:\n        return {\n          shouldBatch: () => true,\n          getBatchTimeout: () => this.config.maxBatchTime * 2,\n          canAddToBatch: (batchSize, itemSize) => batchSize + itemSize <= this.config.maxBatchSize\n        }\n        \n      case BATCH_STRATEGIES.ADAPTIVE:\n        return {\n          shouldBatch: () => this.adaptiveSettings.networkQuality !== 'excellent',\n          getBatchTimeout: () => this.getAdaptiveBatchTimeout(),\n          canAddToBatch: (batchSize, itemSize) => batchSize + itemSize <= this.getAdaptiveBatchSize()\n        }\n        \n      default:\n        return {\n          shouldBatch: () => false,\n          getBatchTimeout: () => 0,\n          canAddToBatch: () => false\n        }\n    }\n  }\n  \n  /**\n   * Create frame skipping strategy\n   */\n  createFrameSkippingStrategy() {\n    switch (this.config.frameSkipStrategy) {\n      case FRAME_SKIP_STRATEGIES.PREDICTIVE:\n        return {\n          shouldSkipFrame: (frame, networkQuality) => {\n            return networkQuality === 'poor' && frame % 2 === 0\n          },\n          getSkipPattern: (quality) => quality === 'poor' ? 2 : 1\n        }\n        \n      case FRAME_SKIP_STRATEGIES.QUALITY_BASED:\n        return {\n          shouldSkipFrame: (frame, networkQuality, cpuUsage) => {\n            const qualityScore = this.calculateQualityScore(networkQuality, cpuUsage)\n            return qualityScore < this.config.qualityThreshold && frame % this.getSkipInterval(qualityScore) === 0\n          },\n          getSkipPattern: (quality) => this.getSkipInterval(this.calculateQualityScore(quality))\n        }\n        \n      default:\n        return {\n          shouldSkipFrame: () => false,\n          getSkipPattern: () => 1\n        }\n    }\n  }\n  \n  /**\n   * Optimize game state before saving\n   */\n  optimizeStateForSaving(state, frame) {\n    const startTime = performance.now()\n    let optimizedState = state\n    \n    try {\n      // Apply delta compression if enabled\n      if (this.config.enableDeltaCompression) {\n        optimizedState = this.applyDeltaCompression(state, frame)\n      }\n      \n      // Apply state compression if needed\n      if (this.strategies.compression.shouldCompress(optimizedState)) {\n        optimizedState = this.strategies.compression.compress(optimizedState)\n        this.updateCompressionMetrics(state, optimizedState, performance.now() - startTime)\n      }\n      \n      // Use state pooling if enabled\n      if (this.config.enableStatePooling) {\n        optimizedState = this.poolState(optimizedState)\n      }\n      \n      this.metrics.frameProcessing.totalFrames++\n      this.updateFrameProcessingMetrics(performance.now() - startTime)\n      \n      return optimizedState\n      \n    } catch (error) {\n      this.logger.error('State optimization failed', error)\n      return state // Return original state on error\n    }\n  }\n  \n  /**\n   * Optimize state for loading\n   */\n  optimizeStateForLoading(state, frame) {\n    const startTime = performance.now()\n    let optimizedState = state\n    \n    try {\n      // Decompress if needed\n      if (this.isCompressedState(state)) {\n        optimizedState = this.strategies.compression.decompress(state)\n        this.updateDecompressionMetrics(performance.now() - startTime)\n      }\n      \n      // Apply delta decompression if needed\n      if (this.config.enableDeltaCompression && this.isDeltaState(optimizedState)) {\n        optimizedState = this.applyDeltaDecompression(optimizedState, frame)\n      }\n      \n      return optimizedState\n      \n    } catch (error) {\n      this.logger.error('State loading optimization failed', error)\n      return state\n    }\n  }\n  \n  /**\n   * Optimize input batching\n   */\n  optimizeInputBatching(input, frame) {\n    if (!this.strategies.batching.shouldBatch()) {\n      return { inputs: [input], immediate: true }\n    }\n    \n    const inputSize = this.getDataSize(input)\n    const currentBatchSize = this.getCurrentBatchSize()\n    \n    if (this.strategies.batching.canAddToBatch(currentBatchSize, inputSize)) {\n      this.addToBatch(input, frame)\n      \n      // Set batch timer if not already set\n      if (!this.batchTimer) {\n        const timeout = this.strategies.batching.getBatchTimeout()\n        this.batchTimer = setTimeout(() => {\n          this.flushBatch()\n        }, timeout)\n      }\n      \n      return { inputs: [], immediate: false }\n    } else {\n      // Batch is full, flush it and start new batch\n      const batchedInputs = this.flushBatch()\n      this.addToBatch(input, frame)\n      \n      return { inputs: batchedInputs, immediate: false }\n    }\n  }\n  \n  /**\n   * Optimize rollback operation\n   */\n  optimizeRollback(targetFrame, currentFrame) {\n    const startTime = performance.now()\n    const rollbackFrames = currentFrame - targetFrame\n    \n    // Determine if we should use frame skipping during rollback\n    const shouldSkipFrames = this.strategies.frameSkipping.shouldSkipFrame(\n      rollbackFrames,\n      this.adaptiveSettings.networkQuality,\n      this.adaptiveSettings.cpuUsage\n    )\n    \n    let optimizationStrategy = {\n      useFrameSkipping: shouldSkipFrames,\n      skipInterval: shouldSkipFrames ? this.strategies.frameSkipping.getSkipPattern(this.adaptiveSettings.networkQuality) : 1,\n      useDeltaStates: this.config.enableDeltaCompression,\n      batchUpdates: rollbackFrames > 5\n    }\n    \n    // Track rollback metrics\n    this.metrics.frameProcessing.rollbacks++\n    this.metrics.frameProcessing.rollbackTime.push(performance.now() - startTime)\n    \n    if (this.metrics.frameProcessing.rollbackTime.length > 100) {\n      this.metrics.frameProcessing.rollbackTime.shift()\n    }\n    \n    return optimizationStrategy\n  }\n  \n  /**\n   * Apply delta compression to state\n   */\n  applyDeltaCompression(currentState, frame) {\n    const previousFrame = frame - 1\n    const previousState = this.deltaStates.get(previousFrame)\n    \n    if (!previousState) {\n      // No previous state, store full state\n      this.deltaStates.set(frame, currentState)\n      return currentState\n    }\n    \n    // Calculate delta\n    const delta = this.calculateStateDelta(previousState, currentState)\n    \n    // Store delta if it's smaller than full state\n    const deltaSize = this.getDataSize(delta)\n    const fullSize = this.getDataSize(currentState)\n    \n    if (deltaSize < fullSize * 0.7) {\n      const deltaState = {\n        type: 'delta',\n        baseFrame: previousFrame,\n        delta: delta,\n        frame: frame\n      }\n      \n      this.deltaStates.set(frame, deltaState)\n      return deltaState\n    } else {\n      // Delta not worth it, store full state\n      this.deltaStates.set(frame, currentState)\n      return currentState\n    }\n  }\n  \n  /**\n   * Apply delta decompression to state\n   */\n  applyDeltaDecompression(deltaState, frame) {\n    if (!this.isDeltaState(deltaState)) {\n      return deltaState\n    }\n    \n    const baseState = this.deltaStates.get(deltaState.baseFrame)\n    if (!baseState) {\n      this.logger.warn('Base state not found for delta decompression', {\n        frame,\n        baseFrame: deltaState.baseFrame\n      })\n      return deltaState\n    }\n    \n    return this.applyDeltaToState(baseState, deltaState.delta)\n  }\n  \n  /**\n   * Calculate delta between two states\n   */\n  calculateStateDelta(oldState, newState) {\n    const delta = {}\n    \n    // Simple delta calculation - in a real implementation,\n    // this would be more sophisticated\n    for (const key in newState) {\n      if (newState[key] !== oldState[key]) {\n        delta[key] = newState[key]\n      }\n    }\n    \n    return delta\n  }\n  \n  /**\n   * Apply delta to base state\n   */\n  applyDeltaToState(baseState, delta) {\n    const newState = { ...baseState }\n    \n    for (const key in delta) {\n      newState[key] = delta[key]\n    }\n    \n    return newState\n  }\n  \n  /**\n   * Custom compression implementation\n   */\n  compressCustom(data) {\n    try {\n      const jsonString = JSON.stringify(data)\n      \n      // Simple run-length encoding for repeated characters\n      let compressed = jsonString.replace(/(.)\\1{2,}/g, (match, char) => {\n        return `${char}${match.length}`\n      })\n      \n      // Remove common JSON patterns\n      compressed = compressed\n        .replace(/\"(\\w+)\":/g, '$1:') // Remove quotes from keys\n        .replace(/\\s+/g, '') // Remove whitespace\n      \n      return {\n        type: 'custom_compressed',\n        data: compressed,\n        originalSize: jsonString.length,\n        compressedSize: compressed.length\n      }\n    } catch (error) {\n      this.logger.error('Custom compression failed', error)\n      return data\n    }\n  }\n  \n  /**\n   * Custom decompression implementation\n   */\n  decompressCustom(compressedData) {\n    try {\n      if (!compressedData || compressedData.type !== 'custom_compressed') {\n        return compressedData\n      }\n      \n      let decompressed = compressedData.data\n      \n      // Reverse compression steps\n      decompressed = decompressed.replace(/(\\w+):/g, '\"$1\":') // Add quotes back\n      decompressed = decompressed.replace(/(.)([0-9]+)/g, (match, char, count) => {\n        return char.repeat(parseInt(count))\n      })\n      \n      return JSON.parse(decompressed)\n    } catch (error) {\n      this.logger.error('Custom decompression failed', error)\n      return compressedData\n    }\n  }\n  \n  /**\n   * LZ4 compression (simplified implementation)\n   */\n  compressLZ4(data) {\n    // This is a placeholder - in a real implementation,\n    // you would use a proper LZ4 library\n    return this.compressCustom(data)\n  }\n  \n  /**\n   * LZ4 decompression\n   */\n  decompressLZ4(data) {\n    return this.decompressCustom(data)\n  }\n  \n  /**\n   * GZIP compression\n   */\n  compressGzip(data) {\n    // This would use a GZIP library in a real implementation\n    return this.compressCustom(data)\n  }\n  \n  /**\n   * GZIP decompression\n   */\n  decompressGzip(data) {\n    return this.decompressCustom(data)\n  }\n  \n  /**\n   * Pool state objects for reuse\n   */\n  poolState(state) {\n    const stateKey = this.generateStateKey(state)\n    \n    if (this.statePool.has(stateKey)) {\n      this.metrics.memory.statePoolHits++\n      return this.statePool.get(stateKey)\n    } else {\n      this.metrics.memory.statePoolMisses++\n      this.statePool.set(stateKey, state)\n      \n      // Limit pool size\n      if (this.statePool.size > 1000) {\n        const oldestKey = this.statePool.keys().next().value\n        this.statePool.delete(oldestKey)\n      }\n      \n      return state\n    }\n  }\n  \n  /**\n   * Generate key for state pooling\n   */\n  generateStateKey(state) {\n    // Simple hash of state - in a real implementation,\n    // this would be more sophisticated\n    return JSON.stringify(state).split('').reduce((hash, char) => {\n      hash = ((hash << 5) - hash) + char.charCodeAt(0)\n      return hash & hash\n    }, 0).toString()\n  }\n  \n  /**\n   * Add input to current batch\n   */\n  addToBatch(input, frame) {\n    this.batchQueue.push({ input, frame, timestamp: performance.now() })\n  }\n  \n  /**\n   * Flush current batch\n   */\n  flushBatch() {\n    if (this.batchQueue.length === 0) {\n      return []\n    }\n    \n    const batchStartTime = performance.now()\n    const batch = [...this.batchQueue]\n    this.batchQueue = []\n    \n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer)\n      this.batchTimer = null\n    }\n    \n    // Update batching metrics\n    const batchTime = performance.now() - batchStartTime\n    const batchSize = batch.reduce((size, item) => size + this.getDataSize(item.input), 0)\n    \n    this.updateBatchingMetrics(batchSize, batchTime)\n    \n    return batch.map(item => item.input)\n  }\n  \n  /**\n   * Get current batch size\n   */\n  getCurrentBatchSize() {\n    return this.batchQueue.reduce((size, item) => size + this.getDataSize(item.input), 0)\n  }\n  \n  /**\n   * Get data size in bytes\n   */\n  getDataSize(data) {\n    if (!data) return 0\n    \n    if (data.byteLength !== undefined) {\n      return data.byteLength\n    }\n    \n    if (data.compressedSize !== undefined) {\n      return data.compressedSize\n    }\n    \n    // Estimate size from JSON string\n    try {\n      return JSON.stringify(data).length * 2 // Rough estimate for UTF-16\n    } catch {\n      return 1024 // Default estimate\n    }\n  }\n  \n  /**\n   * Check if state is compressed\n   */\n  isCompressedState(state) {\n    return state && (state.type === 'custom_compressed' || state.compressed === true)\n  }\n  \n  /**\n   * Check if state is delta-compressed\n   */\n  isDeltaState(state) {\n    return state && state.type === 'delta'\n  }\n  \n  /**\n   * Calculate quality score\n   */\n  calculateQualityScore(networkQuality, cpuUsage = 0) {\n    let score = 1.0\n    \n    switch (networkQuality) {\n      case 'excellent': score *= 1.0; break\n      case 'good': score *= 0.8; break\n      case 'fair': score *= 0.6; break\n      case 'poor': score *= 0.3; break\n      default: score *= 0.5\n    }\n    \n    // Factor in CPU usage\n    score *= Math.max(0.1, 1.0 - (cpuUsage / 100))\n    \n    return score\n  }\n  \n  /**\n   * Get skip interval based on quality\n   */\n  getSkipInterval(qualityScore) {\n    if (qualityScore > 0.8) return 1 // No skipping\n    if (qualityScore > 0.6) return 2 // Skip every other frame\n    if (qualityScore > 0.4) return 3 // Skip 2 out of 3 frames\n    return Math.min(this.config.maxFrameSkip, 4) // Skip more aggressively\n  }\n  \n  /**\n   * Get adaptive batch timeout\n   */\n  getAdaptiveBatchTimeout() {\n    const baseTimeout = this.config.maxBatchTime\n    \n    switch (this.adaptiveSettings.networkQuality) {\n      case 'excellent': return baseTimeout * 0.5\n      case 'good': return baseTimeout\n      case 'fair': return baseTimeout * 1.5\n      case 'poor': return baseTimeout * 2\n      default: return baseTimeout\n    }\n  }\n  \n  /**\n   * Get adaptive batch size\n   */\n  getAdaptiveBatchSize() {\n    const baseSize = this.config.maxBatchSize\n    \n    switch (this.adaptiveSettings.networkQuality) {\n      case 'excellent': return baseSize * 0.5\n      case 'good': return baseSize\n      case 'fair': return baseSize * 1.2\n      case 'poor': return baseSize * 1.5\n      default: return baseSize\n    }\n  }\n  \n  /**\n   * Start adaptive optimization\n   */\n  startAdaptiveOptimization() {\n    setInterval(() => {\n      this.adaptOptimizationSettings()\n    }, this.config.adaptationInterval)\n    \n    this.logger.info('Adaptive optimization started')\n  }\n  \n  /**\n   * Adapt optimization settings based on current conditions\n   */\n  adaptOptimizationSettings() {\n    const now = performance.now()\n    \n    // Update current conditions\n    this.updateCurrentConditions()\n    \n    // Adapt compression settings\n    this.adaptCompressionSettings()\n    \n    // Adapt batching settings\n    this.adaptBatchingSettings()\n    \n    // Adapt frame processing settings\n    this.adaptFrameProcessingSettings()\n    \n    this.adaptiveSettings.lastAdaptation = now\n    \n    this.logger.debug('Optimization settings adapted', {\n      networkQuality: this.adaptiveSettings.networkQuality,\n      currentFPS: this.adaptiveSettings.currentFPS,\n      cpuUsage: this.adaptiveSettings.cpuUsage\n    })\n  }\n  \n  /**\n   * Update current system conditions\n   */\n  updateCurrentConditions() {\n    // Calculate current FPS\n    const recentFrameTimes = this.metrics.frameProcessing.frameTimes.slice(-60)\n    if (recentFrameTimes.length > 0) {\n      const avgFrameTime = recentFrameTimes.reduce((a, b) => a + b, 0) / recentFrameTimes.length\n      this.adaptiveSettings.currentFPS = 1000 / avgFrameTime\n    }\n    \n    // Estimate CPU usage based on frame processing times\n    if (recentFrameTimes.length > 0) {\n      const maxFrameTime = Math.max(...recentFrameTimes)\n      this.adaptiveSettings.cpuUsage = Math.min(100, (maxFrameTime / 16.67) * 100) // 16.67ms = 60fps\n    }\n    \n    // Update memory pressure\n    this.adaptiveSettings.memoryPressure = this.estimateMemoryPressure()\n  }\n  \n  /**\n   * Adapt compression settings\n   */\n  adaptCompressionSettings() {\n    // Increase compression if network quality is poor\n    if (this.adaptiveSettings.networkQuality === 'poor') {\n      this.config.compressionThreshold = Math.max(512, this.config.compressionThreshold * 0.8)\n    } else if (this.adaptiveSettings.networkQuality === 'excellent') {\n      this.config.compressionThreshold = Math.min(2048, this.config.compressionThreshold * 1.2)\n    }\n  }\n  \n  /**\n   * Adapt batching settings\n   */\n  adaptBatchingSettings() {\n    // Adjust batch size based on network conditions\n    if (this.adaptiveSettings.networkQuality === 'poor') {\n      this.config.maxBatchSize = Math.min(16384, this.config.maxBatchSize * 1.2)\n      this.config.maxBatchTime = Math.min(50, this.config.maxBatchTime * 1.5)\n    } else if (this.adaptiveSettings.networkQuality === 'excellent') {\n      this.config.maxBatchSize = Math.max(4096, this.config.maxBatchSize * 0.8)\n      this.config.maxBatchTime = Math.max(8, this.config.maxBatchTime * 0.8)\n    }\n  }\n  \n  /**\n   * Adapt frame processing settings\n   */\n  adaptFrameProcessingSettings() {\n    // Adjust frame skipping based on performance\n    if (this.adaptiveSettings.currentFPS < this.adaptiveSettings.targetFPS * 0.9) {\n      // Performance is below target, enable more aggressive optimizations\n      this.config.maxFrameSkip = Math.min(5, this.config.maxFrameSkip + 1)\n    } else if (this.adaptiveSettings.currentFPS > this.adaptiveSettings.targetFPS * 1.1) {\n      // Performance is above target, reduce optimizations\n      this.config.maxFrameSkip = Math.max(1, this.config.maxFrameSkip - 1)\n    }\n  }\n  \n  /**\n   * Estimate memory pressure\n   */\n  estimateMemoryPressure() {\n    // Simple estimation based on pool sizes and GC frequency\n    const poolPressure = this.statePool.size / 1000\n    const cachePressure = this.compressionCache.size / 500\n    const deltaPressure = this.deltaStates.size / 200\n    \n    return Math.min(1.0, poolPressure + cachePressure + deltaPressure)\n  }\n  \n  /**\n   * Update compression metrics\n   */\n  updateCompressionMetrics(originalState, compressedState, compressionTime) {\n    this.metrics.compression.totalStates++\n    this.metrics.compression.compressedStates++\n    \n    const originalSize = this.getDataSize(originalState)\n    const compressedSize = this.getDataSize(compressedState)\n    \n    this.metrics.compression.originalBytes += originalSize\n    this.metrics.compression.compressedBytes += compressedSize\n    \n    if (this.metrics.compression.originalBytes > 0) {\n      this.metrics.compression.compressionRatio = this.metrics.compression.compressedBytes / this.metrics.compression.originalBytes\n    }\n    \n    this.metrics.compression.compressionTime.push(compressionTime)\n    if (this.metrics.compression.compressionTime.length > 100) {\n      this.metrics.compression.compressionTime.shift()\n    }\n    \n    // Track bytes saved\n    this.metrics.network.bytesSaved += Math.max(0, originalSize - compressedSize)\n  }\n  \n  /**\n   * Update decompression metrics\n   */\n  updateDecompressionMetrics(decompressionTime) {\n    this.metrics.compression.decompressionTime.push(decompressionTime)\n    if (this.metrics.compression.decompressionTime.length > 100) {\n      this.metrics.compression.decompressionTime.shift()\n    }\n  }\n  \n  /**\n   * Update batching metrics\n   */\n  updateBatchingMetrics(batchSize, batchTime) {\n    this.metrics.batching.totalBatches++\n    \n    this.metrics.batching.batchSizes.push(batchSize)\n    this.metrics.batching.batchTimes.push(batchTime)\n    \n    if (this.metrics.batching.batchSizes.length > 100) {\n      this.metrics.batching.batchSizes.shift()\n      this.metrics.batching.batchTimes.shift()\n    }\n    \n    // Update averages\n    this.metrics.batching.avgBatchSize = this.metrics.batching.batchSizes.reduce((a, b) => a + b, 0) / this.metrics.batching.batchSizes.length\n    this.metrics.batching.avgBatchTime = this.metrics.batching.batchTimes.reduce((a, b) => a + b, 0) / this.metrics.batching.batchTimes.length\n  }\n  \n  /**\n   * Update frame processing metrics\n   */\n  updateFrameProcessingMetrics(frameTime) {\n    this.metrics.frameProcessing.frameTimes.push(frameTime)\n    \n    if (this.metrics.frameProcessing.frameTimes.length > 100) {\n      this.metrics.frameProcessing.frameTimes.shift()\n    }\n    \n    this.metrics.frameProcessing.avgFrameTime = this.metrics.frameProcessing.frameTimes.reduce((a, b) => a + b, 0) / this.metrics.frameProcessing.frameTimes.length\n  }\n  \n  /**\n   * Update network quality\n   */\n  updateNetworkQuality(quality) {\n    this.adaptiveSettings.networkQuality = quality\n  }\n  \n  /**\n   * Get performance statistics\n   */\n  getPerformanceStats() {\n    const avgCompressionTime = this.metrics.compression.compressionTime.length > 0\n      ? this.metrics.compression.compressionTime.reduce((a, b) => a + b, 0) / this.metrics.compression.compressionTime.length\n      : 0\n    \n    const avgDecompressionTime = this.metrics.compression.decompressionTime.length > 0\n      ? this.metrics.compression.decompressionTime.reduce((a, b) => a + b, 0) / this.metrics.compression.decompressionTime.length\n      : 0\n    \n    const avgRollbackTime = this.metrics.frameProcessing.rollbackTime.length > 0\n      ? this.metrics.frameProcessing.rollbackTime.reduce((a, b) => a + b, 0) / this.metrics.frameProcessing.rollbackTime.length\n      : 0\n    \n    return {\n      compression: {\n        ...this.metrics.compression,\n        avgCompressionTime,\n        avgDecompressionTime,\n        compressionEfficiency: this.metrics.compression.compressionRatio\n      },\n      \n      batching: {\n        ...this.metrics.batching,\n        batchingEfficiency: this.metrics.batching.totalBatches > 0 \n          ? this.metrics.batching.avgBatchSize / this.config.maxBatchSize \n          : 0\n      },\n      \n      frameProcessing: {\n        ...this.metrics.frameProcessing,\n        avgRollbackTime,\n        frameSkipRate: this.metrics.frameProcessing.totalFrames > 0\n          ? this.metrics.frameProcessing.skippedFrames / this.metrics.frameProcessing.totalFrames\n          : 0\n      },\n      \n      memory: {\n        ...this.metrics.memory,\n        poolHitRate: (this.metrics.memory.statePoolHits + this.metrics.memory.statePoolMisses) > 0\n          ? this.metrics.memory.statePoolHits / (this.metrics.memory.statePoolHits + this.metrics.memory.statePoolMisses)\n          : 0\n      },\n      \n      network: {\n        ...this.metrics.network,\n        bandwidthSaved: this.metrics.network.bytesSaved\n      },\n      \n      adaptive: {\n        ...this.adaptiveSettings\n      }\n    }\n  }\n  \n  /**\n   * Reset all metrics\n   */\n  resetMetrics() {\n    this.metrics = {\n      compression: {\n        totalStates: 0,\n        compressedStates: 0,\n        originalBytes: 0,\n        compressedBytes: 0,\n        compressionRatio: 0,\n        compressionTime: [],\n        decompressionTime: []\n      },\n      \n      batching: {\n        totalBatches: 0,\n        avgBatchSize: 0,\n        avgBatchTime: 0,\n        batchSizes: [],\n        batchTimes: []\n      },\n      \n      frameProcessing: {\n        totalFrames: 0,\n        skippedFrames: 0,\n        avgFrameTime: 0,\n        frameTimes: [],\n        rollbacks: 0,\n        rollbackTime: []\n      },\n      \n      memory: {\n        statePoolSize: 0,\n        statePoolHits: 0,\n        statePoolMisses: 0,\n        memoryUsage: 0,\n        gcCollections: 0\n      },\n      \n      network: {\n        bytesSaved: 0,\n        latencyReduction: 0,\n        qualityScore: 0\n      }\n    }\n    \n    this.logger.info('Performance metrics reset')\n  }\n  \n  /**\n   * Cleanup and shutdown\n   */\n  shutdown() {\n    // Clear batch timer\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer)\n      this.batchTimer = null\n    }\n    \n    // Clear pools and caches\n    this.statePool.clear()\n    this.compressionCache.clear()\n    this.deltaStates.clear()\n    this.batchQueue = []\n    \n    this.logger.info('Rollback performance optimizer shutdown')\n  }\n}\n\nexport default RollbackPerformanceOptimizer
