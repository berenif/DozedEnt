<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rollback Netcode Demo - GGPO-style P2P Gaming</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
        }
        
        .container {
            width: 100%;
            max-width: 1400px;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr 250px;
            gap: 20px;
            height: 600px;
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .lobby-panel {
            overflow-y: auto;
        }
        
        .game-area {
            position: relative;
            display: flex;
            flex-direction: column;
        }
        
        .game-canvas {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .game-controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .stats-panel {
            font-size: 0.9em;
        }
        
        .stat-item {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }
        
        .stat-label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #ffd700;
        }
        
        .stat-value {
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
        }
        
        .btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .lobby-list {
            margin-top: 20px;
        }
        
        .lobby-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .lobby-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .lobby-name {
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .lobby-info {
            font-size: 0.85em;
            opacity: 0.8;
        }
        
        .hosting-options {
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }
        
        .hosting-option {
            margin: 10px 0;
        }
        
        .hosting-option input[type="radio"] {
            margin-right: 10px;
        }
        
        .hosting-option label {
            cursor: pointer;
        }
        
        .hosting-description {
            font-size: 0.85em;
            opacity: 0.8;
            margin-left: 25px;
            margin-top: 5px;
        }
        
        .create-lobby-form {
            margin-top: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }
        
        .form-group input {
            width: 100%;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
        }
        
        .form-group input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        .players-list {
            margin-top: 15px;
        }
        
        .player-item {
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .player-name {
            font-weight: 500;
        }
        
        .player-status {
            font-size: 0.85em;
            padding: 2px 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }
        
        .connection-status {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            font-size: 0.85em;
        }
        
        .status-connected {
            color: #4ade80;
        }
        
        .status-connecting {
            color: #fbbf24;
        }
        
        .status-disconnected {
            color: #f87171;
        }
        
        .rollback-indicator {
            position: absolute;
            bottom: 10px;
            left: 10px;
            padding: 5px 10px;
            background: rgba(255, 0, 0, 0.7);
            border-radius: 5px;
            font-size: 0.85em;
            display: none;
        }
        
        .rollback-indicator.active {
            display: block;
            animation: pulse 0.5s ease-in-out;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .input-display {
            position: absolute;
            bottom: 10px;
            right: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.9em;
        }
        
        .key-indicator {
            display: inline-block;
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            margin: 2px;
        }
        
        .key-indicator.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: #ffd700;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ Rollback Netcode Demo</h1>
            <p>GGPO-style deterministic simulation with WebRTC P2P networking</p>
        </div>
        
        <div class="main-content">
            <!-- Lobby Panel -->
            <div class="panel lobby-panel">
                <h2>Lobby</h2>
                
                <div class="hosting-options">
                    <h3>Hosting Mode</h3>
                    <div class="hosting-option">
                        <input type="radio" id="dedicatedHost" name="hostingMode" value="dedicated_host" checked>
                        <label for="dedicatedHost">Dedicated Host</label>
                        <div class="hosting-description">One player hosts the lobby and coordinates connections</div>
                    </div>
                    <div class="hosting-option">
                        <input type="radio" id="meshP2P" name="hostingMode" value="mesh_p2p">
                        <label for="meshP2P">Mesh P2P</label>
                        <div class="hosting-description">All players connect directly to each other</div>
                    </div>
                </div>
                
                <div class="create-lobby-form">
                    <div class="form-group">
                        <label for="lobbyName">Lobby Name</label>
                        <input type="text" id="lobbyName" placeholder="Enter lobby name..." value="Test Game">
                    </div>
                    <button class="btn" id="createLobbyBtn">Create Lobby</button>
                </div>
                
                <div class="lobby-list" id="lobbyList">
                    <h3>Available Lobbies</h3>
                    <div id="lobbiesContainer"></div>
                </div>
                
                <div class="players-list" id="playersList" style="display: none;">
                    <h3>Players</h3>
                    <div id="playersContainer"></div>
                    <button class="btn" id="startGameBtn" style="margin-top: 10px; width: 100%;">Start Game</button>
                    <button class="btn btn-secondary" id="leaveLobbyBtn" style="margin-top: 10px; width: 100%;">Leave Lobby</button>
                </div>
            </div>
            
            <!-- Game Area -->
            <div class="panel game-area">
                <div class="game-canvas">
                    <canvas id="gameCanvas"></canvas>
                    
                    <div class="connection-status" id="connectionStatus">
                        <span class="status-disconnected">‚óè Disconnected</span>
                    </div>
                    
                    <div class="rollback-indicator" id="rollbackIndicator">
                        ROLLBACK!
                    </div>
                    
                    <div class="input-display" id="inputDisplay">
                        <div>
                            <span class="key-indicator" id="keyW">W</span>
                            <span class="key-indicator" id="keyA">A</span>
                            <span class="key-indicator" id="keyS">S</span>
                            <span class="key-indicator" id="keyD">D</span>
                            <span class="key-indicator" id="keySpace">‚éµ</span>
                        </div>
                    </div>
                </div>
                
                <div class="game-controls">
                    <button class="btn btn-secondary" id="pauseBtn">Pause</button>
                    <button class="btn btn-secondary" id="resetBtn">Reset</button>
                </div>
            </div>
            
            <!-- Stats Panel -->
            <div class="panel stats-panel">
                <h2>Network Stats</h2>
                
                <div class="stat-item">
                    <div class="stat-label">Frame</div>
                    <div class="stat-value" id="statFrame">0</div>
                </div>
                
                <div class="stat-item">
                    <div class="stat-label">Rollbacks</div>
                    <div class="stat-value" id="statRollbacks">0</div>
                </div>
                
                <div class="stat-item">
                    <div class="stat-label">Avg Rollback</div>
                    <div class="stat-value" id="statAvgRollback">0 frames</div>
                </div>
                
                <div class="stat-item">
                    <div class="stat-label">Input Latency</div>
                    <div class="stat-value" id="statLatency">0 ms</div>
                </div>
                
                <div class="stat-item">
                    <div class="stat-label">Predictions</div>
                    <div class="stat-value" id="statPredictions">0</div>
                </div>
                
                <div class="stat-item">
                    <div class="stat-label">RTT</div>
                    <div class="stat-value" id="statRTT">- ms</div>
                </div>
                
                <div class="stat-item">
                    <div class="stat-label">Packet Loss</div>
                    <div class="stat-value" id="statPacketLoss">0%</div>
                </div>
                
                <div class="stat-item">
                    <div class="stat-label">Players</div>
                    <div class="stat-value" id="statPlayers">0</div>
                </div>
            </div>
        </div>
    </div>
    
    <script type="module">
        // Import the rollback netcode system
        import { RollbackLobby, HOSTING_MODE } from '../src/rollback-lobby.js'
        import RollbackNetcode from '../src/rollback-netcode.js'
        import { DeterministicGame } from '../src/deterministic-game.js'
        
        // Simple deterministic game implementation
        class SimpleGame extends DeterministicGame {
            constructor(config) {
                super(config)
                this.projectiles = []
            }
            
            onInitialize() {
                // Game-specific initialization
                console.log('Game initialized with', this.players.size, 'players')
            }
            
            onPlayerAction(playerId, player) {
                // Handle shooting
                const entity = this.entities.get(player.entityId)
                if (!entity) return
                
                const pos = this.positions.get(player.entityId)
                if (!pos) return
                
                // Create projectile
                const projectileId = this.nextEntityId++
                this.createEntity(projectileId, 'projectile', {
                    ownerId: playerId,
                    damage: 10,
                    radius: this.toFixed(4)
                })
                
                // Set projectile position and velocity
                this.positions.set(projectileId, { x: pos.x, y: pos.y })
                
                // Simple projectile direction based on last movement
                const vel = this.velocities.get(player.entityId)
                const speed = this.toFixed(10)
                if (vel && (vel.vx !== 0 || vel.vy !== 0)) {
                    const mag = this.fixedSqrt(this.fixedMul(vel.vx, vel.vx) + this.fixedMul(vel.vy, vel.vy))
                    this.velocities.set(projectileId, {
                        vx: this.fixedDiv(this.fixedMul(vel.vx, speed), mag),
                        vy: this.fixedDiv(this.fixedMul(vel.vy, speed), mag)
                    })
                } else {
                    this.velocities.set(projectileId, { vx: speed, vy: 0 })
                }
                
                this.projectiles.push(projectileId)
            }
            
            onCollision(entity1, entity2) {
                // Handle projectile hits
                if (entity1.type === 'projectile' && entity2.type === 'player') {
                    if (entity1.ownerId !== entity2.playerId) {
                        entity2.health -= entity1.damage
                        entity1.alive = false
                        
                        if (entity2.health <= 0) {
                            entity2.alive = false
                            // Respawn after delay
                            setTimeout(() => {
                                entity2.alive = true
                                entity2.health = 100
                                // Reset position
                                const pos = this.positions.get(entity2.id)
                                if (pos) {
                                    pos.x = this.toFixed(640)
                                    pos.y = this.toFixed(360)
                                }
                            }, 3000)
                        }
                    }
                } else if (entity2.type === 'projectile' && entity1.type === 'player') {
                    this.onCollision(entity2, entity1)
                }
            }
            
            updateGameLogic() {
                // Remove old projectiles
                this.projectiles = this.projectiles.filter(id => {
                    const entity = this.entities.get(id)
                    if (!entity || !entity.alive) return false
                    
                    const pos = this.positions.get(id)
                    if (!pos) return false
                    
                    // Remove if out of bounds
                    const x = this.fromFixed(pos.x)
                    const y = this.fromFixed(pos.y)
                    if (x < 0 || x > 1280 || y < 0 || y > 720) {
                        entity.alive = false
                        return false
                    }
                    
                    return true
                })
            }
            
            // Fixed-point math helpers (reference parent class methods)
            toFixed(n) { return Math.floor(n * (1 << 16)) }
            fromFixed(n) { return n / (1 << 16) }
            fixedMul(a, b) { return Math.floor((a * b) / (1 << 16)) }
            fixedDiv(a, b) { return Math.floor((a * (1 << 16)) / b) }
            fixedSqrt(n) {
                if (n < 0) return 0
                let x = n
                let y = (x + (1 << 16)) >> 1
                while (y < x) {
                    x = y
                    y = (x + this.fixedDiv(n, x)) >> 1
                }
                return x
            }
        }
        
        // Game state
        let lobby = null
        let game = null
        let canvas = null
        let ctx = null
        let animationFrame = null
        let isPaused = false
        
        // Input state
        const inputState = {
            left: false,
            right: false,
            up: false,
            down: false,
            action: false
        }
        
        // Initialize canvas
        function initCanvas() {
            canvas = document.getElementById('gameCanvas')
            ctx = canvas.getContext('2d')
            
            // Set canvas size
            canvas.width = 1280
            canvas.height = 720
            
            // Prevent context menu on right click
            canvas.addEventListener('contextmenu', e => e.preventDefault())
        }
        
        // Render game
        function render() {
            if (!ctx || !game) return
            
            // Clear canvas
            ctx.fillStyle = '#1a1a2e'
            ctx.fillRect(0, 0, canvas.width, canvas.height)
            
            // Get render state
            const state = game.getRenderState()
            
            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)'
            ctx.lineWidth = 1
            for (let x = 0; x <= canvas.width; x += 50) {
                ctx.beginPath()
                ctx.moveTo(x, 0)
                ctx.lineTo(x, canvas.height)
                ctx.stroke()
            }
            for (let y = 0; y <= canvas.height; y += 50) {
                ctx.beginPath()
                ctx.moveTo(0, y)
                ctx.lineTo(canvas.width, y)
                ctx.stroke()
            }
            
            // Draw entities
            for (const entity of state.entities) {
                if (entity.type === 'player') {
                    // Draw player
                    ctx.fillStyle = entity.health > 50 ? '#4ade80' : '#f87171'
                    ctx.beginPath()
                    ctx.arc(entity.x, entity.y, 16, 0, Math.PI * 2)
                    ctx.fill()
                    
                    // Draw health bar
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'
                    ctx.fillRect(entity.x - 20, entity.y - 30, 40, 4)
                    ctx.fillStyle = entity.health > 50 ? '#4ade80' : '#f87171'
                    ctx.fillRect(entity.x - 20, entity.y - 30, 40 * (entity.health / 100), 4)
                    
                    // Draw player ID
                    ctx.fillStyle = 'white'
                    ctx.font = '10px monospace'
                    ctx.textAlign = 'center'
                    ctx.fillText(entity.playerId.substr(0, 6), entity.x, entity.y - 35)
                } else if (entity.type === 'projectile') {
                    // Draw projectile
                    ctx.fillStyle = '#fbbf24'
                    ctx.beginPath()
                    ctx.arc(entity.x, entity.y, 4, 0, Math.PI * 2)
                    ctx.fill()
                }
            }
            
            // Draw scores
            ctx.fillStyle = 'white'
            ctx.font = '16px monospace'
            ctx.textAlign = 'left'
            let scoreY = 30
            for (const player of state.players) {
                ctx.fillText(`Player ${player.id.substr(0, 6)}: ${player.score} pts`, 10, scoreY)
                scoreY += 25
            }
            
            // Continue animation
            if (!isPaused) {
                animationFrame = requestAnimationFrame(render)
            }
        }
        
        // Update stats display
        function updateStats() {
            if (!lobby || !lobby.rollbackNetcode) return
            
            const metrics = lobby.rollbackNetcode.getMetrics()
            
            document.getElementById('statFrame').textContent = metrics.currentFrame
            document.getElementById('statRollbacks').textContent = metrics.rollbacks
            document.getElementById('statAvgRollback').textContent = metrics.avgRollbackFrames.toFixed(1) + ' frames'
            document.getElementById('statLatency').textContent = metrics.avgInputLatency.toFixed(1) + ' ms'
            document.getElementById('statPredictions').textContent = metrics.predictions
            document.getElementById('statPlayers').textContent = metrics.players
            
            // Get P2P stats if available
            if (lobby.p2pNetwork) {
                lobby.p2pNetwork.getStats().then(stats => {
                    let totalRTT = 0
                    let totalPacketLoss = 0
                    let connectedPeers = 0
                    
                    for (const [peerId, peerStats] of Object.entries(stats)) {
                        if (peerStats.connected) {
                            connectedPeers++
                            if (peerStats.rtt) totalRTT += peerStats.rtt
                            if (peerStats.packetLoss) totalPacketLoss += peerStats.packetLoss
                        }
                    }
                    
                    if (connectedPeers > 0) {
                        document.getElementById('statRTT').textContent = (totalRTT / connectedPeers).toFixed(1) + ' ms'
                        document.getElementById('statPacketLoss').textContent = (totalPacketLoss / connectedPeers).toFixed(1) + '%'
                    }
                })
            }
        }
        
        // Update lobby list
        function updateLobbyList() {
            const container = document.getElementById('lobbiesContainer')
            const lobbies = lobby ? lobby.getLobbies() : []
            
            if (lobbies.length === 0) {
                container.innerHTML = '<div style="opacity: 0.6; text-align: center; padding: 20px;">No lobbies available</div>'
            } else {
                container.innerHTML = lobbies.map(l => `
                    <div class="lobby-item" data-lobby-id="${l.id}">
                        <div class="lobby-name">${l.name}</div>
                        <div class="lobby-info">
                            ${l.currentPlayers}/${l.maxPlayers} players ‚Ä¢ 
                            ${l.hostingMode === 'mesh_p2p' ? 'Mesh P2P' : 'Dedicated Host'}
                        </div>
                    </div>
                `).join('')
                
                // Add click handlers
                container.querySelectorAll('.lobby-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const lobbyId = item.dataset.lobbyId
                        joinLobby(lobbyId)
                    })
                })
            }
        }
        
        // Update players list
        function updatePlayersList() {
            const container = document.getElementById('playersContainer')
            const players = lobby ? lobby.getPlayers() : []
            
            container.innerHTML = players.map(p => `
                <div class="player-item">
                    <span class="player-name">${p.name}</span>
                    <span class="player-status">${p.isHost ? 'Host' : (p.ready ? 'Ready' : 'Waiting')}</span>
                </div>
            `).join('')
        }
        
        // Create lobby
        async function createLobby() {
            const lobbyName = document.getElementById('lobbyName').value || 'Unnamed Lobby'
            const hostingMode = document.querySelector('input[name="hostingMode"]:checked').value
            
            try {
                // Create lobby with selected hosting mode
                lobby = new RollbackLobby('rollback-demo', {
                    hostingMode: hostingMode,
                    maxPlayers: 4,
                    logLevel: 'debug'
                })
                
                // Set up lobby callbacks
                lobby.onLobbyListUpdate = updateLobbyList
                lobby.onPlayerJoin = (playerId, playerName) => {
                    console.log('Player joined:', playerId, playerName)
                    updatePlayersList()
                }
                lobby.onPlayerLeave = (playerId) => {
                    console.log('Player left:', playerId)
                    updatePlayersList()
                }
                lobby.onGameStart = () => {
                    console.log('Game started!')
                    startGameLoop()
                }
                
                // Create the lobby
                const lobbyId = await lobby.createLobby(lobbyName, {
                    gameType: 'simple'
                })
                
                console.log('Lobby created:', lobbyId)
                
                // Update UI
                document.getElementById('lobbyList').style.display = 'none'
                document.getElementById('playersList').style.display = 'block'
                document.getElementById('startGameBtn').style.display = lobby.isHost ? 'block' : 'none'
                
                updatePlayersList()
                updateConnectionStatus('connected')
                
            } catch (error) {
                console.error('Failed to create lobby:', error)
                alert('Failed to create lobby: ' + error.message)
            }
        }
        
        // Join lobby
        async function joinLobby(lobbyId) {
            try {
                // Create lobby instance
                lobby = new RollbackLobby('rollback-demo', {
                    logLevel: 'debug'
                })
                
                // Set up callbacks
                lobby.onLobbyListUpdate = updateLobbyList
                lobby.onPlayerJoin = updatePlayersList
                lobby.onPlayerLeave = updatePlayersList
                lobby.onGameStart = () => {
                    console.log('Game started!')
                    startGameLoop()
                }
                
                // Join the lobby
                await lobby.joinLobby(lobbyId, 'Player')
                
                console.log('Joined lobby:', lobbyId)
                
                // Update UI
                document.getElementById('lobbyList').style.display = 'none'
                document.getElementById('playersList').style.display = 'block'
                document.getElementById('startGameBtn').style.display = 'none'
                
                updatePlayersList()
                updateConnectionStatus('connected')
                
            } catch (error) {
                console.error('Failed to join lobby:', error)
                alert('Failed to join lobby: ' + error.message)
            }
        }
        
        // Start game
        async function startGame() {
            if (!lobby || !lobby.isHost) return
            
            try {
                // Create game instance
                game = new SimpleGame({ seed: Date.now() })
                
                // Initialize game with players
                const playerIds = lobby.getPlayers().map(p => p.id)
                game.initialize(playerIds)
                
                // Start the game
                await lobby.startGame({
                    saveState: () => game.saveState(),
                    loadState: (state) => game.loadState(state),
                    advanceFrame: (inputs) => game.advanceFrame(inputs),
                    getChecksum: () => game.getChecksum()
                })
                
                // Override getLocalInput in rollback netcode
                lobby.rollbackNetcode.getLocalInput = () => {
                    return { ...inputState }
                }
                
                console.log('Game started!')
                startGameLoop()
                
            } catch (error) {
                console.error('Failed to start game:', error)
                alert('Failed to start game: ' + error.message)
            }
        }
        
        // Start game loop
        function startGameLoop() {
            if (!game) {
                // Create game instance for clients
                game = new SimpleGame({ seed: Date.now() })
                const playerIds = lobby.getPlayers().map(p => p.id)
                game.initialize(playerIds)
                
                // Set up game callbacks for client
                lobby.rollbackNetcode.initialize({
                    saveState: () => game.saveState(),
                    loadState: (state) => game.loadState(state),
                    advanceFrame: (inputs) => game.advanceFrame(inputs),
                    getChecksum: () => game.getChecksum()
                }, lobby.localPlayerId)
                
                // Override getLocalInput
                lobby.rollbackNetcode.getLocalInput = () => {
                    return { ...inputState }
                }
            }
            
            // Start rendering
            isPaused = false
            render()
            
            // Start stats update
            setInterval(updateStats, 100)
            
            // Listen for rollback events
            const originalRollback = lobby.rollbackNetcode.rollback
            lobby.rollbackNetcode.rollback = function(targetFrame) {
                originalRollback.call(this, targetFrame)
                
                // Show rollback indicator
                const indicator = document.getElementById('rollbackIndicator')
                indicator.classList.add('active')
                setTimeout(() => indicator.classList.remove('active'), 500)
            }
        }
        
        // Leave lobby
        function leaveLobby() {
            if (lobby) {
                lobby.leaveLobby()
                lobby = null
                game = null
            }
            
            // Reset UI
            document.getElementById('lobbyList').style.display = 'block'
            document.getElementById('playersList').style.display = 'none'
            updateConnectionStatus('disconnected')
            
            // Cancel animation
            if (animationFrame) {
                cancelAnimationFrame(animationFrame)
                animationFrame = null
            }
        }
        
        // Update connection status
        function updateConnectionStatus(status) {
            const statusEl = document.getElementById('connectionStatus')
            statusEl.innerHTML = status === 'connected' 
                ? '<span class="status-connected">‚óè Connected</span>'
                : status === 'connecting'
                ? '<span class="status-connecting">‚óè Connecting...</span>'
                : '<span class="status-disconnected">‚óè Disconnected</span>'
        }
        
        // Input handling
        document.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': case 'arrowup':
                    inputState.up = true
                    document.getElementById('keyW').classList.add('active')
                    break
                case 'a': case 'arrowleft':
                    inputState.left = true
                    document.getElementById('keyA').classList.add('active')
                    break
                case 's': case 'arrowdown':
                    inputState.down = true
                    document.getElementById('keyS').classList.add('active')
                    break
                case 'd': case 'arrowright':
                    inputState.right = true
                    document.getElementById('keyD').classList.add('active')
                    break
                case ' ':
                    inputState.action = true
                    document.getElementById('keySpace').classList.add('active')
                    e.preventDefault()
                    break
            }
        })
        
        document.addEventListener('keyup', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': case 'arrowup':
                    inputState.up = false
                    document.getElementById('keyW').classList.remove('active')
                    break
                case 'a': case 'arrowleft':
                    inputState.left = false
                    document.getElementById('keyA').classList.remove('active')
                    break
                case 's': case 'arrowdown':
                    inputState.down = false
                    document.getElementById('keyS').classList.remove('active')
                    break
                case 'd': case 'arrowright':
                    inputState.right = false
                    document.getElementById('keyD').classList.remove('active')
                    break
                case ' ':
                    inputState.action = false
                    document.getElementById('keySpace').classList.remove('active')
                    e.preventDefault()
                    break
            }
        })
        
        // Button handlers
        document.getElementById('createLobbyBtn').addEventListener('click', createLobby)
        document.getElementById('startGameBtn').addEventListener('click', startGame)
        document.getElementById('leaveLobbyBtn').addEventListener('click', leaveLobby)
        
        document.getElementById('pauseBtn').addEventListener('click', () => {
            isPaused = !isPaused
            document.getElementById('pauseBtn').textContent = isPaused ? 'Resume' : 'Pause'
            if (!isPaused) render()
        })
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            if (game && lobby && lobby.rollbackNetcode) {
                // Reset game state
                const playerIds = lobby.getPlayers().map(p => p.id)
                game.initialize(playerIds)
                lobby.rollbackNetcode.currentFrame = 0
            }
        })
        
        // Initialize
        initCanvas()
        
        // Periodically update lobby list
        setInterval(() => {
            if (lobby && !lobby.lobbyId) {
                updateLobbyList()
            }
        }, 2000)
    </script>
</body>
</html>