<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Demo - DozedEnt</title>
    <link rel="stylesheet" href="../src/css/common.css">
    <link rel="stylesheet" href="../src/css/working-multiplayer-demo.css">
</head>
<body>
    <div class="demo-container">
        <header class="demo-header">
            <div class="hero-intro">
                <h1>MULTIPLAYER DEMO</h1>
                <p class="subtitle">Link your fireteam, sync the labyrinth, and feel every strike in real time.</p>
            </div>
        </header>
    
    <div class="ui-toast-stack" id="toast-stack" aria-live="assertive" aria-atomic="true"></div>
    
    <div class="demo-controls">
        <div class="control-section" id="tile-room-management">
            <h3>ROOM FORGE</h3>
            <p class="section-hint">Select a realm, forge your gate, and rally allies.</p>
            <div class="field-group">
                <label for="network-provider" class="field-label">NETWORK PROVIDER</label>
                <select id="network-provider">
                    <option value="torrent">Torrent (BitTorrent)</option>
                    <option value="firebase">Firebase</option>
                    <option value="ipfs">IPFS</option>
                    <option value="mqtt" selected>MQTT</option>
                    <option value="nostr">Nostr</option>
                    <option value="supabase">Supabase</option>
                </select>
                <p class="field-hint">Each provider shifts how quickly explorers uncover your shard.</p>
            </div>
            <div class="field-group">
                <label for="room-id-input" class="field-label">ROOM ID</label>
                <input type="text" id="room-id-input" placeholder="Enter room ID to join" value="8x99xr">
            </div>
            <div class="button-row primary-actions">
                <button class="btn primary" onclick="createRoom()">CREATE ROOM</button>
                <button class="btn" onclick="joinRoom()">JOIN ROOM</button>
                <button class="btn danger" onclick="leaveRoom()">Leave Room</button>
            </div>
            <div class="rooms-toolbar">
                <div class="rooms-toolbar-left">Nearby Gateways</div>
                <div class="rooms-toolbar-right">
                    <button class="btn sm" onclick="discoverRooms()">DISCOVER</button>
                    <button class="btn sm" onclick="refreshRoomList()">REFRESH</button>
                </div>
            </div>
            <div class="room-list" id="room-list">
                <div class="room-item no-rooms">
                    <div class="room-name">No rooms discovered for MQTT</div>
                    <div class="room-details">
                        <span class="room-hint">Try "Discover Rooms" or "Refresh Room List"</span>
                    </div>
                </div>
            </div>
            <div class="rooms-hint">Tip: Tap a gateway to engulf the code, then press Join.</div>

        </div>
        
        <div class="control-section" id="tile-signal-status">
            <h3>SIGNAL STATUS</h3>
            <p class="section-hint">Monitor your link before the next descent.</p>
            <div class="status-grid">
                <div class="status-item">
                    <div class="status-label">ROOM ID</div>
                    <div class="status-value" id="room-id">Not Connected</div>
                </div>
                <div class="status-item">
                    <div class="status-label">CONNECTED PLAYERS</div>
                    <div class="status-value" id="peer-count">0</div>
                </div>
                <div class="status-item">
                    <div class="status-label">NETWORK PROVIDER</div>
                    <div class="status-value" id="connection-quality">Link idle - MQTT</div>
                </div>
                <div class="status-item">
                    <div class="status-label">YOUR PLAYER NAME</div>
                    <div class="status-value" id="peer-name">BoldChick</div>
                </div>
            </div>
        </div>
        
        <div class="control-section" id="tile-connected-players" style="display: none;">
            <h3>Squad Roster</h3>
            <p class="section-hint">Keep your allies in formation and ready for descent.</p>
            <div class="button-row subtle-actions">
                <button class="btn danger" onclick="leaveRoom()">Leave Room</button>
            </div>
            
            <!-- Enhanced Squad Roster with Chat Integration -->
            <div class="squad-roster-container" role="region" aria-labelledby="squad-title" aria-describedby="squad-description">
                <div class="squad-header">
                    <div class="squad-title" id="squad-title">
                        <span class="squad-icon" aria-hidden="true">‚öîÔ∏è</span>
                        <span class="squad-name">Active Squad</span>
                        <span class="squad-count" id="squad-count" aria-label="Squad member count">0/8</span>
                    </div>
                    <div class="squad-actions" role="toolbar" aria-label="Squad management actions">
                        <button class="btn-icon" onclick="refreshPeers()" title="Refresh Squad" aria-label="Refresh squad roster" type="button">
                            <span class="icon-refresh" aria-hidden="true">üîÑ</span>
                        </button>
                        <button class="btn-icon" onclick="pingAllPeers()" title="Ping All" aria-label="Ping all squad members" type="button">
                            <span class="icon-ping" aria-hidden="true">üì°</span>
                        </button>
                    </div>
                </div>
                
                <div class="squad-members" id="squad-members" role="list" aria-label="Squad members list">
                    <div class="squad-member empty" role="listitem" aria-label="No squad members connected">
                        <div class="member-avatar" aria-hidden="true">üë§</div>
                        <div class="member-info">
                            <div class="member-name">No allies connected</div>
                            <div class="member-status">Awaiting reinforcements</div>
                        </div>
                    </div>
                </div>
                
                <!-- Chat Message Integration -->
                <div class="chat-integration" role="region" aria-labelledby="chat-title" aria-describedby="chat-description">
                    <div class="chat-header">
                        <span class="chat-title" id="chat-title">Squad Communications</span>
                        <div class="chat-status" id="chat-status" role="status" aria-live="polite">
                            <span class="status-indicator" aria-hidden="true"></span>
                            <span class="status-text">Ready</span>
                        </div>
                    </div>
                    
                    <div class="chat-messages" id="chat-messages" role="log" aria-label="Squad chat messages" aria-live="polite" aria-atomic="false">
                        <div class="chat-message system" role="listitem">
                            <div class="message-avatar" aria-hidden="true">‚ö°</div>
                            <div class="message-content">
                                <div class="message-header">
                                    <span class="message-sender">System</span>
                                    <span class="message-time" aria-label="Message timestamp">Just now</span>
                                </div>
                                <div class="message-text">Squad communications established. All clear for battle chatter.</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="chat-input-container">
                        <div class="chat-input-wrapper">
                            <label for="chat-message" class="sr-only">Type your message to the squad</label>
                            <input type="text" id="chat-message" placeholder="Send message to squad..." maxlength="200" aria-describedby="chat-help">
                            <button class="btn-send" onclick="sendMessage()" title="Send Message" aria-label="Send message to squad" type="button">
                                <span class="send-icon" aria-hidden="true">üì§</span>
                            </button>
                        </div>
                        <div class="chat-quick-actions" role="toolbar" aria-label="Chat quick actions">
                            <button class="btn-quick" onclick="sendRandomMessage()" title="Send Random Message" aria-label="Send a random message to squad" type="button">
                                <span class="quick-icon" aria-hidden="true">üé≤</span>
                                Random
                            </button>
                            <button class="btn-quick" onclick="clearChat()" title="Clear Chat" aria-label="Clear all chat messages" type="button">
                                <span class="quick-icon" aria-hidden="true">üóëÔ∏è</span>
                                Clear
                            </button>
                            <button class="btn-quick" onclick="toggleChatMute()" title="Toggle Chat Mute" aria-label="Toggle chat mute" id="chat-mute-btn" type="button">
                                <span class="quick-icon" aria-hidden="true">üîá</span>
                                Mute
                            </button>
                        </div>
                        <div id="chat-help" class="sr-only">Press Enter to send message. Use quick actions for common commands.</div>
                    </div>
                </div>
            </div>
        </div>

        
        <div class="control-section" style="display: none;">
            <h3>üìä Network Diagnostics</h3>
            <button class="btn" onclick="showNetworkStats()">Show Network Stats</button>
            <button class="btn" onclick="testConnection()">Test Connection</button>
            <button class="btn" onclick="exportLogs()">Export Logs</button>
            <button class="btn danger" onclick="resetStats()">Reset Stats</button>
        </div>
    </div>
    
    <section class="log-panel">
        <h3>Expedition Log</h3>
        <p class="section-hint">Signals, discoveries, and warnings appear here in real time.</p>
        <div id="event-log" class="log-feed">
            <div class="log-entry info">
                <span class="log-icon info">+</span>
                <span class="timestamp">[00:10:17]</span>
                <span class="log-message">BroadcastChannel initialized for room discovery</span>
            </div>
            <div class="log-entry info">
                <span class="log-icon info">+</span>
                <span class="timestamp">[00:10:17]</span>
                <span class="log-message">Generated new peer name: "BoldChick"</span>
            </div>
            <div class="log-entry info">
                <span class="log-icon info">+</span>
                <span class="timestamp">[00:10:17]</span>
                <span class="log-message">Network manager initialized</span>
            </div>
        </div>
    </section>
    
    <script type="module">
        import NetworkProviderManager from '../src/netcode/network-provider-manager.js'
        import { peerNameGenerator } from '../src/utils/peer-name-generator.js'
        import { ProviderRoomStore } from '../src/utils/provider-room-store.js'
        import { AlertSystem, AlertTypes, initializeGlobalAlertSystem, showAlert, clearAllAlerts, showAlertStatus } from '../src/ui/alert-system.js'
        
        const networkProviderSelect = document.getElementById('network-provider')
        const journeySteps = Array.from(document.querySelectorAll('.journey-step'))
        const LOG_ICONS = { info: 'i', success: '+', warning: '!', error: 'x' }
        
        // Initialize global alert system
        const alertSystem = initializeGlobalAlertSystem({
            containerId: 'toast-stack',
            toastLifetime: 4800,
            alertCooldown: 2000,
            maxActiveAlerts: 3,
            enableSpamProtection: true,
            enableAccessibility: true
        })

        // Global variables
        let networkManager = null
        let room = null
        let sendMessage = null
        let sendPing = null
        let sendPeerInfo = null
        let getPeerInfo = null
        let sendRoomInfo = null
        let getRoomInfo = null
        let sendRoomDiscovery = null
        let getRoomDiscovery = null
        let currentPeerName = null
        let peerNames = new Map() // Map of peerId -> peerName
        const roomStore = new ProviderRoomStore()
        let selectedProviderId = networkProviderSelect.value
        let stats = {
            messagesSent: 0,
            messagesReceived: 0
        }

        // Persistent client identifier for de-duplication of our own rooms
        let selfClientId = null
        try {
            selfClientId = localStorage.getItem('self-client-id')
            if (!selfClientId) {
                selfClientId = (window.crypto && crypto.randomUUID) ? crypto.randomUUID() : Math.random().toString(36).slice(2)
                localStorage.setItem('self-client-id', selfClientId)
            }
        } catch (_) {
            selfClientId = Math.random().toString(36).slice(2)
        }

        // Suppress discovery immediately after leaving to avoid list flood
        let suppressDiscoveryUntil = 0

        // Track the most recently left room so it remains visible in the lobby
        let lastLeftRoomId = null
        let lastLeftRoomProviderId = null
        let lastLeftRoomInfo = null
        let lastLeftTime = 0
        
        // Room creation tracking
        let isInRoom = false // Track if player is currently in a room
        let isHostingRoom = false // Track if player is hosting (created) the current room
        let hasCreatedRoom = false // Track if player has created a room in this session
        let roomCreationCooldown = null // Track cooldown timer
        let cooldownEndTime = null // When the cooldown ends
        const ROOM_CREATION_COOLDOWN_DURATION = 30000 // 30 seconds cooldown
        
        // Room joining tracking
        let roomJoinCooldown = null // Track join cooldown timer
        let joinCooldownEndTime = null // When the join cooldown ends
        const ROOM_JOIN_COOLDOWN_DURATION = 10000 // 10 seconds cooldown for joining
        
        // Discovery state management
        let lastLobbyBroadcast = 0 // Prevent too frequent broadcasts
        let broadcastChannel = null // Global BroadcastChannel for room discovery

        networkProviderSelect.addEventListener('change', (event) => {
            handleProviderSelectionChange(event.target.value)
        })

        // Toggle tiles: show Room Management when not in a room,
        // show Connected Players when in a room
        function updateTileVisibility() {
            const roomTile = document.getElementById('tile-room-management')
            const playersTile = document.getElementById('tile-connected-players')
            if (!roomTile || !playersTile) return
            if (isInRoom) {
                roomTile.style.display = 'none'
                playersTile.style.display = ''
            } else {
                roomTile.style.display = ''
                playersTile.style.display = 'none'
            }
            updateJourneyProgress()
        }

        function escapeForHtml(value) {
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
        }

        function formatMessageForDisplay(value) {
            return escapeForHtml(value).replace(/\r?\n/g, '<br>')
        }

        function updateJourneyProgress() {
            if (!journeySteps.length) return

            const peerMap = networkManager && typeof networkManager.getPeers === 'function'
                ? networkManager.getPeers()
                : {}
            const remotePeerCount = peerMap ? Object.keys(peerMap).length : 0

            journeySteps.forEach(step => {
                step.classList.remove('is-active', 'is-complete')
            })

            const [firstStep, secondStep, thirdStep] = journeySteps

            if (firstStep) {
                firstStep.classList.add('is-complete')
            }

            if (secondStep) {
                if (isInRoom) {
                    secondStep.classList.add('is-complete')
                } else {
                    secondStep.classList.add('is-active')
                }
            }

            if (thirdStep) {
                if (isInRoom && remotePeerCount > 0) {
                    thirdStep.classList.add('is-complete')
                } else if (isInRoom) {
                    thirdStep.classList.add('is-active')
                }
            }
        }

        // Add log entry
        function addLog(message, type = 'info') {
            const log = document.getElementById('event-log')
            if (!log) return

            const entry = document.createElement('div')
            entry.className = `log-entry ${type}`
            entry.dataset.type = type
            entry.setAttribute('role', 'log')

            const icon = document.createElement('span')
            icon.className = `log-icon ${type}`
            icon.textContent = LOG_ICONS[type] || LOG_ICONS.info

            const time = document.createElement('span')
            time.className = 'timestamp'
            time.textContent = `[${new Date().toLocaleTimeString()}]`

            const messageNode = document.createElement('span')
            messageNode.className = 'log-message'
            messageNode.innerHTML = formatMessageForDisplay(message)

            entry.append(icon, time, messageNode)
            log.insertBefore(entry, log.firstChild)

            while (log.children.length > 50) {
                log.removeChild(log.lastChild)
            }
        }

        // Alert system is now handled by the imported AlertSystem class

        // Nearby rooms scanning visibility/enablement
        function updateNearbyRoomsUI() {
            const shouldHide = isInRoom

            const primarySelectors = ['.rooms-toolbar', '.rooms-hint']
            primarySelectors.forEach(selector => {
                document.querySelectorAll(selector).forEach(el => {
                    el.style.display = shouldHide ? 'none' : ''
                })
            })

            const roomListEl = document.getElementById('room-list')
            if (roomListEl) roomListEl.style.display = shouldHide ? 'none' : ''


            document.querySelectorAll("button[onclick='discoverRooms()'], button[onclick='refreshRoomList()']").forEach(btn => {
                btn.disabled = shouldHide
                btn.style.opacity = shouldHide ? '0.6' : '1'
                btn.style.cursor = shouldHide ? 'not-allowed' : 'pointer'
                if (shouldHide && document.activeElement === btn) {
                    btn.blur()
                }
            })
        }

        // Function to clear all active alerts
        window.clearAllAlerts = function() {
            clearAllAlerts()
            addLog('All alerts cleared', 'info')
        }
        
        // Function to show alert status
        window.showAlertStatus = function() {
            showAlertStatus()
        }
        
        // Network manager helpers
        function setupNetworkManagerIfNeeded() {
            if (networkManager) {return networkManager}
            networkManager = new NetworkProviderManager()
            networkManager.on('onProviderChanged', (providerId) => {
                selectedProviderId = providerId
                networkProviderSelect.value = providerId
                addLog(`Provider changed to: ${providerId}`, 'info')
                updateRoomList()
                updateStatus()
            })
            networkManager.on('onRoomCreated', (roomId, providerId) => {
                addLog(`Room created: ${roomId} with ${providerId}`, 'success')
                updateStatus()
            })
            networkManager.on('onRoomJoined', (roomId, providerId) => {
                addLog(`Joined room: ${roomId} with ${providerId}`, 'success')
                updateStatus()
            })
            networkManager.on('onRoomLeft', () => {
                addLog('Left room', 'info')
                updateStatus()
            })
            networkManager.on('onPeerJoined', (peerId) => {
                addLog(`Peer joined: ${peerId}`, 'success')
                // Broadcast our peer info to the new peer immediately
                if (sendPeerInfo && currentPeerName) {
                    const ourPeerId = room && room.getSelfId ? room.getSelfId() : 'self'
                    sendPeerInfo({ peerId: ourPeerId, peerName: currentPeerName })
                    addLog(`Sent peer info to new peer: ${peerId}`, 'info')
                }
                // Also request peer info from the new peer by sending our info again
                // This helps ensure bidirectional name exchange
                setTimeout(() => {
                    if (sendPeerInfo && currentPeerName) {
                        const ourPeerId = room && room.getSelfId ? room.getSelfId() : 'self'
                        sendPeerInfo({ peerId: ourPeerId, peerName: currentPeerName })
                        addLog(`Re-sent peer info to ensure name exchange with: ${peerId}`, 'info')
                    }
                }, 1000) // Wait 1 second then resend
                updatePeerList()
                updateStatus()
            })
            networkManager.on('onPeerLeft', (peerId) => {
                addLog(`Peer left: ${peerId}`, 'info')
                updatePeerList()
                updateStatus()
            })
            networkManager.on('onError', (error) => {
                addLog(`Network error: ${error.message}`, 'error')
                console.error('Network error:', error)
            })
            return networkManager
        }

        async function ensureProviderIsReady(providerId) {
            const manager = setupNetworkManagerIfNeeded()
            const currentProvider = manager.getCurrentProvider()
            if (!currentProvider || currentProvider.id !== providerId) {
                const success = await manager.initializeProvider(providerId)
                if (!success) {
                    throw new Error('Failed to initialize network provider')
                }
            }
            return manager
        }

        function handleProviderSelectionChange(providerId) {
            setupNetworkManagerIfNeeded()
            if (!providerId) {return}
            if (room) {
                addLog('Leaving current room before switching provider', 'info')
                window.leaveRoom()
            }
            selectedProviderId = providerId
            networkProviderSelect.value = providerId
            
            // Update BroadcastChannel for new provider
            if (broadcastChannel) {
                broadcastChannel.close()
            }
            if (typeof BroadcastChannel !== 'undefined') {
                try {
                    broadcastChannel = new BroadcastChannel(`room-discovery-${providerId}`)
                    broadcastChannel.addEventListener('message', (event) => {
                        if (event.data.type === 'room-broadcast') {
                            const stored = recordDiscoveredRoom(providerId, event.data.roomInfo)
                            if (stored) {
                                addLog(`Discovered room via BroadcastChannel: ${stored.name}`, 'info')
                                updateRoomList()
                            }
                        } else if (event.data.type === 'discovery-request') {
                            // Respond to discovery requests if we're in a room
                            if (room && sendRoomInfo && currentPeerName) {
                                const currentRoomId = document.getElementById('room-id').textContent
                                if (currentRoomId && currentRoomId !== 'Not Connected') {
                                    const peers = networkManager.getPeers()
                                    const roomInfo = {
                                        id: currentRoomId,
                                        roomId: currentRoomId,
                                        roomName: `Room ${currentRoomId}`,
                                        name: `Room ${currentRoomId}`,
                                        playerCount: Object.keys(peers).length + 1,
                                        maxPlayers: 8,
                                        hostName: currentPeerName,
                                        providerId: providerId,
                                        creatorId: selfClientId,
                                        broadcastTime: Date.now(),
                                        expiresAt: Date.now() + (60 * 1000)
                                    }
                                    broadcastChannel.postMessage({
                                        type: 'room-broadcast',
                                        roomInfo: roomInfo,
                                        timestamp: Date.now()
                                    })
                                    addLog(`Responded to discovery request with room: ${currentRoomId}`, 'info')
                                }
                            }
                        }
                    })
                    addLog(`BroadcastChannel updated for provider: ${providerId}`, 'info')
                } catch (error) {
                    addLog(`BroadcastChannel update failed: ${error.message}`, 'error')
                }
            }
            
            addLog(`Selected network provider: ${getProviderLabel(providerId)}`, 'info')
            updateRoomList()
            updateStatus()
        }

        function recordDiscoveredRoom(providerId, info) {
            if (!providerId) {return null}
            // Ignore discovery while suppressed or if it's our own broadcast
            const now = Date.now()
            if (now < suppressDiscoveryUntil) { return null }
            // Allow the most-recently-left room even if it's ours (for a short window)
            const isRecentlyLeft = info && lastLeftRoomId && info.id === lastLeftRoomId && (now - lastLeftTime) < 60000
            if (!isRecentlyLeft && info && (info.creatorId === selfClientId || info.hostPeerId === selfClientId)) { return null }
            const stored = roomStore.upsert(providerId, info)
            if (stored && providerId === selectedProviderId) {
                updateRoomList()
            }
            return stored
        }

        function getProviderLabel(providerId) {
            const option = Array.from(networkProviderSelect.options).find(opt => opt.value === providerId)
            return option ? option.textContent : providerId
        }

        function getCurrentProviderId() {
            const active = networkManager ? networkManager.getCurrentProvider() : null
            return active ? active.id : selectedProviderId
        }

// Room management functions
        window.createRoom = async function() {
            try {
                // Check if player is on cooldown from creating a room
                if (roomCreationCooldown && cooldownEndTime && Date.now() < cooldownEndTime) {
                    const remainingTime = Math.ceil((cooldownEndTime - Date.now()) / 1000)
                    const minutes = Math.floor(remainingTime / 60)
                    const seconds = remainingTime % 60
                    const timeString = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`
                    
                    const alertMessage = `üö´ ROOM CREATION TIMEOUT\n\nYou recently created a room and are in a cooldown period.\n\n‚è∞ Time remaining: ${timeString}\n\nThis timeout prevents room spam and ensures fair play.\nPlease wait before creating another room.`
                    showAlert(alertMessage, AlertTypes.ERROR)
                    addLog(`Room creation blocked - ${timeString} remaining in cooldown period`, 'error')
                    return
                }

                // Check if player has already created a room in this session (only if not in timeout)
                if (hasCreatedRoom && (!roomCreationCooldown || !cooldownEndTime || Date.now() >= cooldownEndTime)) {
                    addLog('You have already created a room in this session. Please leave your current room first.', 'error')
                    return
                }

                // Check if player is already in a room
                if (isInRoom) {
                    addLog('You are already in a room. Please leave your current room before creating a new one.', 'error')
                    return
                }

                const roomId = document.getElementById('room-id-input').value || 
                    Math.random().toString(36).substring(2, 8)

                const providerId = selectedProviderId
                const providerLabel = getProviderLabel(providerId)

                addLog(`Creating room: ${roomId} on ${providerLabel}`, 'info')

                await ensureProviderIsReady(providerId)

                // Create room using network manager
                room = await networkManager.createRoom(roomId)

                // Set up actions
                const [sendMessageAction, getMessageAction] = networkManager.createAction('message')
                const [sendPingAction, getPingAction] = networkManager.createAction('ping')
                const [sendPeerInfoAction, getPeerInfoAction] = networkManager.createAction('peerInfo')
                const [sendRoomInfoAction, getRoomInfoAction] = networkManager.createAction('roomInfo')
                const [sendRoomDiscoveryAction, getRoomDiscoveryAction] = networkManager.createAction('roomDisc')

                sendMessage = sendMessageAction
                sendPing = sendPingAction
                sendPeerInfo = sendPeerInfoAction
                getPeerInfo = getPeerInfoAction
                sendRoomInfo = sendRoomInfoAction
                getRoomInfo = getRoomInfoAction
                sendRoomDiscovery = sendRoomDiscoveryAction
                getRoomDiscovery = getRoomDiscoveryAction

                // Set up message handlers
                getMessageAction(message => {
                    stats.messagesReceived++
                    networkManager.updateMessageStats('received')
                    addLog(`Message from peer: ${message}`, 'info')
                    handleIncomingMessage(message)
                    updateStatus()
                })

                getPingAction(pingData => {
                    addLog(`Ping received: ${JSON.stringify(pingData)}`, 'info')
                })

                getPeerInfoAction(peerInfo => {
                    const { peerId, peerName } = peerInfo
                    peerNames.set(peerId, peerName)
                    addLog(`Peer info received: [${peerId.substring(0, 4)}] ${peerName}`, 'info')
                    updatePeerList()
                })

                getRoomInfoAction(roomInfo => {
                    const providerForRoom = roomInfo.providerId || getCurrentProviderId()
                    const stored = recordDiscoveredRoom(providerForRoom, roomInfo)
                    if (stored) {
                        addLog(`Room discovered: ${stored.name} (${stored.playerCount}/${stored.maxPlayers}) by ${stored.hostName}`, 'info')
                    }
                })

                getRoomDiscoveryAction(discoveryRequest => {
                    // Handle room discovery requests
                    if (discoveryRequest.type === 'request' && room && currentPeerName) {
                        const providerId = getCurrentProviderId()
                        const currentRoomId = document.getElementById('room-id').textContent
                        
                        if (currentRoomId && currentRoomId !== 'Not Connected') {
                            const peers = networkManager.getPeers()
                            const roomInfo = {
                                id: currentRoomId,
                                roomId: currentRoomId,
                                roomName: `Room ${currentRoomId}`,
                                name: `Room ${currentRoomId}`,
                                playerCount: Object.keys(peers).length + 1,
                                maxPlayers: 8,
                                hostName: currentPeerName,
                                providerId
                            }
                            // Send room info back to the requester
                            sendRoomInfo(roomInfo)
                            addLog(`Responded to room discovery request with room: ${currentRoomId}`, 'info')
                        }
                    }
                })

                document.getElementById('room-id').textContent = roomId
                addLog(`Room created successfully: ${roomId} on ${providerLabel}`, 'success')
                
                // Update room tracking variables
                isInRoom = true
                isHostingRoom = true
                hasCreatedRoom = true

                // Start cooldown timer
                cooldownEndTime = Date.now() + ROOM_CREATION_COOLDOWN_DURATION
                if (roomCreationCooldown) {
                    clearInterval(roomCreationCooldown)
                }
                roomCreationCooldown = setInterval(() => {
                    if (Date.now() >= cooldownEndTime) {
                        clearInterval(roomCreationCooldown)
                        roomCreationCooldown = null
                        cooldownEndTime = null
                        addLog('Room creation cooldown has ended', 'info')
                    }
                }, 1000)

                // Update UI visibility for hosting state
                updateButtonVisibility()
                updateNearbyRoomsUI()
                updateTileVisibility()

                // Broadcast room info to help with discovery
                if (sendRoomInfo && currentPeerName) {
                    const peers = networkManager.getPeers()
                    const roomInfo = {
                        id: roomId,
                        roomId: roomId,
                        roomName: `Room ${roomId}`,
                        name: `Room ${roomId}`,
                        playerCount: Object.keys(peers).length + 1,
                        maxPlayers: 8,
                        hostName: currentPeerName,
                        providerId,
                        creatorId: selfClientId
                    }
                    recordDiscoveredRoom(providerId, roomInfo)
                    sendRoomInfo(roomInfo)
                    
                    // Broadcast to lobby after a delay to avoid conflicts
                    setTimeout(() => broadcastToLobby(providerId, roomInfo), 5000)
                }

                // Broadcast our peer info
                if (sendPeerInfo && currentPeerName) {
                    const ourPeerId = room.getSelfId ? room.getSelfId() : 'self'
                    sendPeerInfo({ peerId: ourPeerId, peerName: currentPeerName })
                }

                updateStatus()

            } catch (error) {
                let errorMessage = error.message
                
                // Provide helpful guidance for MQTT CONNACK timeout issues
                if (errorMessage.includes('connack') || errorMessage.includes('Connection timeout')) {
                    errorMessage += '\n\nüí° MQTT Connection Tips:\n'
                    errorMessage += '‚Ä¢ This may be due to Node.js 20+ compatibility issues with MQTT.js\n'
                    errorMessage += '‚Ä¢ Try switching to a different network provider (Torrent, Firebase, IPFS)\n'
                    errorMessage += '‚Ä¢ Check your internet connection and firewall settings\n'
                    errorMessage += '‚Ä¢ MQTT brokers may be temporarily unavailable'
                }
                
                addLog(`Failed to create room: ${errorMessage}`, 'error')
            }
        }
        
        window.joinRoom = async function() {
            try {
                // Check if player is on cooldown from joining a room
                if (roomJoinCooldown && joinCooldownEndTime && Date.now() < joinCooldownEndTime) {
                    const remainingTime = Math.ceil((joinCooldownEndTime - Date.now()) / 1000)
                    const minutes = Math.floor(remainingTime / 60)
                    const seconds = remainingTime % 60
                    const timeString = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`
                    
                    const alertMessage = `üö´ ROOM JOIN TIMEOUT\n\nYou recently left a room and are in a cooldown period.\n\n‚è∞ Time remaining: ${timeString}\n\nThis timeout prevents room hopping and ensures stable connections.\nPlease wait before joining another room.`
                    showAlert(alertMessage, AlertTypes.ERROR)
                    addLog(`Room join blocked - ${timeString} remaining in cooldown period`, 'error')
                    return
                }

                const roomId = document.getElementById('room-id-input').value.trim()

                if (!roomId) {
                    showAlert('Please enter a room ID to join.\n\nYou can get room IDs from the "Available Rooms" list below.', AlertTypes.ERROR)
                    addLog('Please enter a room ID to join. You can get room IDs from the "Available Rooms" list below.', 'error')
                    return
                }

                const providerId = selectedProviderId
                const providerLabel = getProviderLabel(providerId)

                addLog(`Joining room: ${roomId} on ${providerLabel}`, 'info')

                if (room) {
                    addLog('Leaving current room before joining another room', 'info')
                    window.leaveRoom()
                }

                await ensureProviderIsReady(providerId)

                // Join room using network manager
                room = await networkManager.joinRoom(roomId)

                // Set up actions
                const [sendMessageAction, getMessageAction] = networkManager.createAction('message')
                const [sendPingAction, getPingAction] = networkManager.createAction('ping')
                const [sendPeerInfoAction, getPeerInfoAction] = networkManager.createAction('peerInfo')
                const [sendRoomInfoAction, getRoomInfoAction] = networkManager.createAction('roomInfo')
                const [sendRoomDiscoveryAction, getRoomDiscoveryAction] = networkManager.createAction('roomDisc')

                sendMessage = sendMessageAction
                sendPing = sendPingAction
                sendPeerInfo = sendPeerInfoAction
                getPeerInfo = getPeerInfoAction
                sendRoomInfo = sendRoomInfoAction
                getRoomInfo = getRoomInfoAction
                sendRoomDiscovery = sendRoomDiscoveryAction
                getRoomDiscovery = getRoomDiscoveryAction

                // Set up message handlers
                getMessageAction(message => {
                    stats.messagesReceived++
                    networkManager.updateMessageStats('received')
                    addLog(`Message from peer: ${message}`, 'info')
                    handleIncomingMessage(message)
                    updateStatus()
                })

                getPingAction(pingData => {
                    addLog(`Ping received: ${JSON.stringify(pingData)}`, 'info')
                })

                getPeerInfoAction(peerInfo => {
                    const { peerId, peerName } = peerInfo
                    peerNames.set(peerId, peerName)
                    addLog(`Peer info received: [${peerId.substring(0, 4)}] ${peerName}`, 'info')
                    updatePeerList()
                })

                getRoomInfoAction(roomInfo => {
                    const providerForRoom = roomInfo.providerId || getCurrentProviderId()
                    const stored = recordDiscoveredRoom(providerForRoom, roomInfo)
                    if (stored) {
                        addLog(`Room discovered: ${stored.name} (${stored.playerCount}/${stored.maxPlayers}) by ${stored.hostName}`, 'info')
                    }
                })

                getRoomDiscoveryAction(discoveryRequest => {
                    // Handle room discovery requests
                    if (discoveryRequest.type === 'request' && room && currentPeerName) {
                        const providerId = getCurrentProviderId()
                        const currentRoomId = document.getElementById('room-id').textContent
                        
                        if (currentRoomId && currentRoomId !== 'Not Connected') {
                            const peers = networkManager.getPeers()
                            const roomInfo = {
                                id: currentRoomId,
                                roomId: currentRoomId,
                                roomName: `Room ${currentRoomId}`,
                                name: `Room ${currentRoomId}`,
                                playerCount: Object.keys(peers).length + 1,
                                maxPlayers: 8,
                                hostName: currentPeerName,
                                providerId
                            }
                            // Send room info back to the requester
                            sendRoomInfo(roomInfo)
                            addLog(`Responded to room discovery request with room: ${currentRoomId}`, 'info')
                        }
                    }
                })

                document.getElementById('room-id').textContent = roomId
                addLog(`Joined room: ${roomId} on ${providerLabel}`, 'success')
                
                // Update room tracking variables
                isInRoom = true
                isHostingRoom = false // Joined an existing room, not hosting

                // Start join cooldown timer
                joinCooldownEndTime = Date.now() + ROOM_JOIN_COOLDOWN_DURATION
                if (roomJoinCooldown) {
                    clearInterval(roomJoinCooldown)
                }
                roomJoinCooldown = setInterval(() => {
                    if (Date.now() >= joinCooldownEndTime) {
                        clearInterval(roomJoinCooldown)
                        roomJoinCooldown = null
                        joinCooldownEndTime = null
                        addLog('Room join cooldown has ended', 'info')
                    }
                }, 1000)

                // Update UI visibility for room state
                updateButtonVisibility()
                updateNearbyRoomsUI()
                updateTileVisibility()

                const peers = networkManager.getPeers()
                recordDiscoveredRoom(providerId, {
                    id: roomId,
                    roomId: roomId,
                    roomName: `Room ${roomId}`,
                    name: `Room ${roomId}`,
                    playerCount: Object.keys(peers).length + 1,
                    maxPlayers: 8,
                    hostName: 'Unknown',
                    providerId
                })

                // Broadcast our peer info
                if (sendPeerInfo && currentPeerName) {
                    const ourPeerId = room.getSelfId ? room.getSelfId() : 'self'
                    sendPeerInfo({ peerId: ourPeerId, peerName: currentPeerName })
                }

                // Send room discovery request to find existing rooms
                if (sendRoomDiscovery) {
                    setTimeout(() => {
                        const discoveryRequest = {
                            type: 'request',
                            requesterId: currentPeerName || 'unknown',
                            timestamp: Date.now()
                        }
                        sendRoomDiscovery(discoveryRequest)
                        addLog('Sent initial room discovery request', 'info')
                    }, 1000) // Wait 1 second after joining
                }

                updateStatus()

            } catch (error) {
                let errorMessage = error.message
                
                // Provide helpful guidance for MQTT CONNACK timeout issues
                if (errorMessage.includes('connack') || errorMessage.includes('Connection timeout')) {
                    errorMessage += '\n\nüí° MQTT Connection Tips:\n'
                    errorMessage += '‚Ä¢ This may be due to Node.js 20+ compatibility issues with MQTT.js\n'
                    errorMessage += '‚Ä¢ Try switching to a different network provider (Torrent, Firebase, IPFS)\n'
                    errorMessage += '‚Ä¢ Check your internet connection and firewall settings\n'
                    errorMessage += '‚Ä¢ MQTT brokers may be temporarily unavailable'
                }
                
                addLog(`Failed to join room: ${errorMessage}`, 'error')
            }
        }
        
        window.leaveRoom = function() {
            if (networkManager) {
                // Capture room id before resetting UI
                const prevRoomId = document.getElementById('room-id').textContent
                networkManager.leaveRoom()
                room = null
                sendMessage = null
                sendPing = null
                sendPeerInfo = null
                getPeerInfo = null
                sendRoomDiscovery = null
                getRoomDiscovery = null
                peerNames.clear()
                
                // Reset room tracking variables
                isInRoom = false
                isHostingRoom = false
                // Note: hasCreatedRoom remains true to prevent creating multiple rooms in same session
                // Note: cooldown timer persists even after leaving room to prevent spam
                
                // Update UI visibility
                updateButtonVisibility()
                updateNearbyRoomsUI()
                updateTileVisibility()
                
                addLog('Left room', 'info')
                document.getElementById('room-id').textContent = 'Not Connected'
                updatePeerList()
                updateStatus()
                
                // Clear discovered rooms and suppress discovery briefly to avoid list flood
                try {
                    suppressDiscoveryUntil = Date.now() + 5000
                    // Capture the room we just left so it remains visible in lobby
                    const providerId = getCurrentProviderId() || selectedProviderId
                    const leftRoomId = (prevRoomId && prevRoomId !== 'Not Connected') ? prevRoomId : (document.getElementById('room-id-input').value || '')
                    const peers = networkManager ? networkManager.getPeers() : {}
                    const info = {
                        id: leftRoomId,
                        roomId: leftRoomId,
                        roomName: `Room ${leftRoomId}`,
                        name: `Room ${leftRoomId}`,
                        playerCount: Math.max(0, Object.keys(peers || {}).length),
                        maxPlayers: 8,
                        hostName: 'Unknown',
                        providerId,
                        creatorId: selfClientId,
                        broadcastTime: Date.now(),
                        expiresAt: Date.now() + (60 * 1000)
                    }

                    lastLeftRoomId = leftRoomId
                    lastLeftRoomProviderId = providerId
                    lastLeftRoomInfo = info
                    lastLeftTime = Date.now()

                    // Reset store to reduce clutter, then keep only the just-left room
                    roomStore.clearProvider(providerId)
                    roomStore.upsert(providerId, info)
                    updateRoomList()

                    // Replace localStorage cache with only the just-left room (short TTL)
                    const discoveryKey = `room-discovery-${providerId}`
                    localStorage.setItem(discoveryKey, JSON.stringify([{...info}]))
                } catch (_) {}
            }
        }
        
        
        // Chat functions
        window.sendMessage = function() {
            if (!sendMessage) {
                addLog('Not connected to a room', 'error')
                return
            }
            
            const message = document.getElementById('chat-message').value
            if (!message) {
                addLog('Please enter a message', 'error')
                return
            }
            
            try {
                const messageWithName = `[${currentPeerName}]: ${message}`
                sendMessage(messageWithName)
                stats.messagesSent++
                if (networkManager) {
                    networkManager.updateMessageStats('sent')
                }
                addLog(`Sent: ${messageWithName}`, 'info')
                
                // Add message to chat UI
                addChatMessage(currentPeerName, message, false, true)
                
                document.getElementById('chat-message').value = ''
                updateStatus()
            } catch (error) {
                addLog(`Failed to send message: ${error.message}`, 'error')
            }
        }
        
        window.sendRandomMessage = function() {
            if (!sendMessage) {
                addLog('Not connected to a room', 'error')
                return
            }
            
            const messages = [
                'Hello everyone!',
                'How is everyone doing?',
                'This is a test message',
                'WebRTC is working!',
                'P2P networking is awesome!',
                'Trystero is great!',
                'Anyone want to play?',
                'Connection is stable!',
                'Ready for battle!',
                'Squad formation complete!',
                'All systems operational!',
                'Let\'s do this!'
            ]
            
            const randomMessage = messages[Math.floor(Math.random() * messages.length)]
            const messageWithName = `[${currentPeerName}]: ${randomMessage}`
            sendMessage(messageWithName)
            stats.messagesSent++
            if (networkManager) {
                networkManager.updateMessageStats('sent')
            }
            addLog(`Sent random message: ${messageWithName}`, 'info')
            
            // Add message to chat UI
            addChatMessage(currentPeerName, randomMessage, false, true)
            
            updateStatus()
        }
        
        window.clearChat = function() {
            document.getElementById('event-log').innerHTML = ''
            const chatMessages = document.getElementById('chat-messages')
            chatMessages.innerHTML = `
                <div class="chat-message system">
                    <div class="message-avatar">‚ö°</div>
                    <div class="message-content">
                        <div class="message-header">
                            <span class="message-sender">System</span>
                            <span class="message-time">Just now</span>
                        </div>
                        <div class="message-text">Chat cleared. Squad communications ready.</div>
                    </div>
                </div>
            `
            addLog('Chat cleared', 'info')
        }
        
        // Peer management
        window.refreshPeers = function() {
            updatePeerList()
            addLog('Peer list refreshed', 'info')
        }
        
        window.pingAllPeers = function() {
            if (!sendPing) {
                addLog('Not connected to a room', 'error')
                return
            }
            
            const pingData = {
                timestamp: Date.now(),
                message: 'Ping from demo!'
            }
            
            sendPing(pingData)
            addLog('Ping sent to all peers', 'info')
        }
        
        // Network diagnostics
        window.showNetworkStats = function() {
            if (!networkManager) {
                addLog('Network manager not initialized', 'error')
                return
            }
            
            const networkStats = networkManager.getStats()
            const currentProvider = networkManager.getCurrentProvider()
            const selectedProviderLabel = getProviderLabel(selectedProviderId)
            
            addLog('=== Network Statistics ===', 'success')
            addLog(`Selected Provider: ${selectedProviderLabel}`)
            addLog(`Active Provider: ${currentProvider ? currentProvider.name : 'None (not initialized)'}`)
            addLog(`Messages sent: ${networkStats.messagesSent}`)
            addLog(`Messages received: ${networkStats.messagesReceived}`)
            addLog(`Connected peers: ${networkStats.peerCount}`)
            addLog(`Connections established: ${networkStats.connectionsEstablished}`)
            addLog(`Errors: ${networkStats.errors}`)
            addLog(`Room ID: ${document.getElementById('room-id').textContent}`)
            addLog(`In Room: ${isInRoom ? 'Yes' : 'No'}`)
            addLog(`Hosting Room: ${isHostingRoom ? 'Yes' : 'No'}`)
        }
        
        window.testConnection = function() {
            if (!networkManager || !room) {
                addLog('Not connected to a room', 'error')
                return
            }
            
            addLog('Testing connection...', 'info')
            pingAllPeers()
        }
        
        window.exportLogs = function() {
            const logs = Array.from(document.getElementById('event-log').children)
                .map(entry => entry.textContent)
                .join('\n')
            
            const blob = new Blob([logs], { type: 'text/plain' })
            const url = URL.createObjectURL(blob)
            const a = document.createElement('a')
            a.href = url
            a.download = 'multiplayer-demo-logs.txt'
            a.click()
            
            addLog('Logs exported', 'success')
        }
        
        window.resetStats = function() {
            stats = { messagesSent: 0, messagesReceived: 0 }
            if (networkManager) {
                networkManager.resetStats()
            }
            addLog('Statistics reset', 'info')
            updateStatus()
        }
        
        // Room discovery functions
        window.refreshRoomList = async function() {
            const providerId = selectedProviderId
            const providerLabel = getProviderLabel(providerId)
            
            addLog(`Refreshing room list for ${providerLabel}`, 'info')
            
            // Always show cached rooms first
            updateRoomList()
            
            // Suppress active discovery if we're within the suppression window
            if (Date.now() < suppressDiscoveryUntil) { return }
            
            // If we're connected to a room, use the existing discovery mechanism
            if (networkManager && room && sendRoomDiscovery) {
                const discoveryRequest = {
                    type: 'request',
                    requesterId: currentPeerName || 'unknown',
                    timestamp: Date.now()
                }
                sendRoomDiscovery(discoveryRequest)
                addLog('Sent room discovery request to connected peers', 'info')
            }
            
            // If we're connected to a room, broadcast our room info
            if (networkManager && room && sendRoomInfo && currentPeerName) {
                const currentProviderId = getCurrentProviderId()
                const currentRoomId = document.getElementById('room-id').textContent

                if (currentRoomId && currentRoomId !== 'Not Connected') {
                    const peers = networkManager.getPeers()
                const roomInfo = {
                    id: currentRoomId,
                    roomId: currentRoomId,
                    roomName: `Room ${currentRoomId}`,
                    name: `Room ${currentRoomId}`,
                    playerCount: Object.keys(peers).length + 1,
                    maxPlayers: 8,
                    hostName: currentPeerName,
                    providerId: currentProviderId,
                    creatorId: selfClientId
                }
                    recordDiscoveredRoom(currentProviderId, roomInfo)
                    sendRoomInfo(roomInfo)
                    addLog('Broadcasted current room info', 'info')
                }
            }
            
            // Try to discover rooms by joining a temporary discovery room
            if (!room && networkManager) {
                try {
                    addLog(`Attempting global room discovery for ${providerLabel}...`, 'info')
                    await performGlobalRoomDiscovery(providerId)
                } catch (error) {
                    addLog(`Global discovery failed: ${error.message}`, 'error')
                }
            }
        }
        
        // Global room discovery using alternative mechanisms (no room joining required)
        async function performGlobalRoomDiscovery(providerId) {
            if (!networkManager) {
                throw new Error('Network manager not initialized')
            }
            if (Date.now() < suppressDiscoveryUntil) { return }
            
            // Ensure the provider is initialized for discovery
            try {
                await ensureProviderIsReady(providerId)
            } catch (error) {
                addLog(`Provider initialization failed: ${error.message}`, 'error')
                return
            }
            
            try {
                addLog(`Starting global room discovery for ${providerId} using alternative methods`, 'info')
                
                // Method 1: Read from localStorage
                const discoveryKey = `room-discovery-${providerId}`
                const storedRooms = JSON.parse(localStorage.getItem(discoveryKey) || '[]')
                const now = Date.now()
                
                // Filter out expired rooms
                const activeRooms = storedRooms.filter(r => now < r.expiresAt)
                
                // Add discovered rooms to our store
                activeRooms.forEach(roomData => {
                    const stored = recordDiscoveredRoom(providerId, roomData)
                    if (stored) {
                        addLog(`Discovered room via localStorage: ${stored.name}`, 'info')
                    }
                })
                
                // Method 2: Listen for BroadcastChannel messages
                if (typeof BroadcastChannel !== 'undefined') {
                    try {
                        const channel = new BroadcastChannel(`room-discovery-${providerId}`)
                        
                        // Set up a temporary listener
                        const messageHandler = (event) => {
                            if (event.data.type === 'room-broadcast') {
                                const stored = recordDiscoveredRoom(providerId, event.data.roomInfo)
                                if (stored) {
                                    addLog(`Discovered room via BroadcastChannel: ${stored.name}`, 'info')
                                }
                            }
                        }
                        
                        channel.addEventListener('message', messageHandler)
                        
                        // Request room broadcasts from other tabs
                        channel.postMessage({
                            type: 'discovery-request',
                            requesterId: currentPeerName || 'unknown',
                            timestamp: now
                        })
                        
                        // Wait for responses
                        await new Promise(resolve => setTimeout(resolve, 2000))
                        
                        // Clean up
                        channel.removeEventListener('message', messageHandler)
                        channel.close()
                        
                    } catch (error) {
                        addLog(`BroadcastChannel discovery failed: ${error.message}`, 'info')
                    }
                }
                
                // Method 3: Use existing room connections for P2P discovery
                if (room && sendRoomDiscovery) {
                    try {
                        const discoveryRequest = {
                            type: 'request',
                            requesterId: currentPeerName || 'unknown',
                            timestamp: now
                        }
                        sendRoomDiscovery(discoveryRequest)
                        addLog('Sent P2P discovery request to connected peers', 'info')
                        
                        // Wait for responses
                        await new Promise(resolve => setTimeout(resolve, 2000))
                        
                    } catch (error) {
                        addLog(`P2P discovery failed: ${error.message}`, 'info')
                    }
                }
                
                // Update the room list with discoveries
                updateRoomList()
                addLog(`Global room discovery completed for ${providerId}`, 'success')
                
            } catch (error) {
                addLog(`Global discovery failed: ${error.message}`, 'error')
            }
        }
        
        window.discoverRooms = async function() {
            const providerId = selectedProviderId
            const providerLabel = getProviderLabel(providerId)
            
            if (!networkManager) {
                addLog('Network manager not initialized', 'error')
                return
            }
            
            if (room && sendRoomDiscovery) {
                // We're already in a room, use existing discovery
                const discoveryRequest = {
                    type: 'request',
                    requesterId: currentPeerName || 'unknown',
                    timestamp: Date.now()
                }
                sendRoomDiscovery(discoveryRequest)
                addLog('Sent room discovery request to connected peers', 'info')
            } else {
                // Not in a room, try global discovery
                try {
                    addLog(`Starting global room discovery for ${providerLabel}...`, 'info')
                    await performGlobalRoomDiscovery(providerId)
                    addLog('Global room discovery completed', 'success')
                } catch (error) {
                    addLog(`Global discovery failed: ${error.message}`, 'error')
                }
            }
        }
        
        
        window.selectRoom = function(roomId) {
            document.getElementById('room-id-input').value = roomId
            addLog(`Selected room: ${roomId}`, 'info')
        }
        
        window.joinSelectedRoom = function(roomId) {
            window.selectRoom(roomId)
            window.joinRoom()
        }
        
        // Button visibility management
        function updateButtonVisibility() {
            const joinButton = document.querySelector('button[onclick="joinRoom()"]');
            const leaveButton = document.querySelector('button[onclick="leaveRoom()"]');
            const createButton = document.querySelector('button[onclick="createRoom()"]');
            
            // Handle join and leave buttons based on room status
            if (isInRoom) {
                // Player is in a room - hide join button, show leave button
                if (joinButton) joinButton.style.display = 'none';
                if (leaveButton) leaveButton.style.display = 'inline-block';
            } else {
                // Player is not in a room - show join button, hide leave button
                if (joinButton) {
                    // Check if player is on join cooldown
                    if (roomJoinCooldown && joinCooldownEndTime && Date.now() < joinCooldownEndTime) {
                        const remainingTime = Math.ceil((joinCooldownEndTime - Date.now()) / 1000);
                        const minutes = Math.floor(remainingTime / 60);
                        const seconds = remainingTime % 60;
                        const timeString = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                        joinButton.textContent = `‚è∞ Join Timeout: ${timeString}`;
                        joinButton.style.display = 'inline-block';
                        joinButton.style.opacity = '0.6';
                        joinButton.style.cursor = 'not-allowed';
                        // Keep button enabled so clicking shows the timeout alert
                        joinButton.disabled = false;
                    } else {
                        // Normal join button
                        joinButton.textContent = 'Join Room';
                        joinButton.style.display = 'inline-block';
                        joinButton.style.opacity = '1';
                        joinButton.style.cursor = 'pointer';
                        joinButton.disabled = false;
                    }
                }
                if (leaveButton) leaveButton.style.display = 'none';
            }
            
            // Handle create button - hide when in room, show timeout status when not in room
            if (isInRoom) {
                // Hide create button when player is in a room
                if (createButton) {
                    createButton.style.display = 'none';
                }
            } else {
                // Show create button when not in room
                if (roomCreationCooldown && cooldownEndTime && Date.now() < cooldownEndTime) {
                    // Show cooldown status on create button
                    if (createButton) {
                        const remainingTime = Math.ceil((cooldownEndTime - Date.now()) / 1000);
                        const minutes = Math.floor(remainingTime / 60);
                        const seconds = remainingTime % 60;
                        const timeString = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                        createButton.textContent = `‚è∞ Timeout: ${timeString}`;
                        createButton.style.display = 'inline-block';
                        createButton.style.opacity = '0.6';
                        createButton.style.cursor = 'not-allowed';
                        // Keep button enabled so clicking shows the timeout alert
                        createButton.disabled = false;
                    }
                } else {
                    // Normal create button
                    if (createButton) {
                        createButton.textContent = 'Create Room';
                        createButton.style.display = 'inline-block';
                        createButton.style.opacity = '1';
                        createButton.style.cursor = 'pointer';
                        createButton.disabled = false;
                    }
                }
            }
        }

        // Enhanced Squad Roster Functions
        function updateSquadRoster() {
            const squadMembers = document.getElementById('squad-members')
            const squadCount = document.getElementById('squad-count')
            const peersObj = networkManager ? networkManager.getPeers() : {}
            const peers = Object.keys(peersObj)
            const totalMembers = peers.length + (isInRoom ? 1 : 0)

            // Update squad count
            squadCount.textContent = `${totalMembers}/8`

            if (peers.length === 0 && !isInRoom) {
                squadMembers.innerHTML = `
                    <div class="squad-member empty">
                        <div class="member-avatar">üë§</div>
                        <div class="member-info">
                            <div class="member-name">No allies connected</div>
                            <div class="member-status">Awaiting reinforcements</div>
                        </div>
                    </div>
                `
            } else {
                let membersHTML = ''

                // Add current player first
                if (isInRoom && currentPeerName) {
                    const ourPeerId = room && room.getSelfId ? room.getSelfId() : 'self'
                    const ourShortId = ourPeerId.substring(0, 4)
                    membersHTML += `
                        <div class="squad-member self" role="listitem" aria-label="Squad leader: ${currentPeerName}">
                            <div class="member-avatar" aria-hidden="true">üëë</div>
                            <div class="member-info">
                                <div class="member-name">${currentPeerName} (You)</div>
                                <div class="member-status">Squad Leader</div>
                            </div>
                        </div>
                    `
                }

                // Add other squad members
                peers.forEach(peerId => {
                    const shortId = peerId.substring(0, 4)
                    let peerName = peerNames.get(peerId)
                    
                    // If we don't have the peer name yet, request it and show a temporary name
                    if (!peerName) {
                        peerName = `Ally ${shortId}`
                        // Request peer info if we have the capability
                        if (sendPeerInfo && currentPeerName) {
                            // Send a request for peer info by sending our own info
                            const ourPeerId = room && room.getSelfId ? room.getSelfId() : 'self'
                            sendPeerInfo({ peerId: ourPeerId, peerName: currentPeerName })
                        }
                    }
                    
                    const status = getPeerStatus(peerId)
                    
                    membersHTML += `
                        <div class="squad-member" role="listitem" aria-label="Squad member: ${peerName}, status: ${status}">
                            <div class="member-avatar" aria-hidden="true">‚öîÔ∏è</div>
                            <div class="member-info">
                                <div class="member-name">${peerName}</div>
                                <div class="member-status">${status}</div>
                            </div>
                        </div>
                    `
                })

                squadMembers.innerHTML = membersHTML
            }

            updateJourneyProgress()
        }

        function getPeerStatus(peerId) {
            // This could be enhanced with actual connection quality data
            const statuses = [
                'Ready for battle',
                'Standing by',
                'Combat ready',
                'Awaiting orders',
                'In position'
            ]
            return statuses[Math.floor(Math.random() * statuses.length)]
        }

        // Enhanced Chat Functions
        function addChatMessage(sender, message, isSystem = false, isSelf = false) {
            const chatMessages = document.getElementById('chat-messages')
            const messageElement = document.createElement('div')
            const timestamp = new Date().toLocaleTimeString()
            
            let avatar = '‚öîÔ∏è'
            let senderClass = ''
            
            if (isSystem) {
                avatar = '‚ö°'
                senderClass = 'system'
            } else if (isSelf) {
                avatar = 'üëë'
                senderClass = 'self'
            }

            messageElement.className = `chat-message ${senderClass}`
            messageElement.setAttribute('role', 'listitem')
            messageElement.setAttribute('aria-label', `Message from ${sender}: ${message}`)
            messageElement.innerHTML = `
                <div class="message-avatar" aria-hidden="true">${avatar}</div>
                <div class="message-content">
                    <div class="message-header">
                        <span class="message-sender">${sender}</span>
                        <span class="message-time" aria-label="Message timestamp">${timestamp}</span>
                    </div>
                    <div class="message-text">${escapeForHtml(message)}</div>
                </div>
            `

            chatMessages.insertBefore(messageElement, chatMessages.firstChild)

            // Keep only last 50 messages
            while (chatMessages.children.length > 50) {
                chatMessages.removeChild(chatMessages.lastChild)
            }

            // Auto-scroll to show new message
            chatMessages.scrollTop = 0
        }

        function updateChatStatus(status) {
            const statusIndicator = document.querySelector('.status-indicator')
            const statusText = document.querySelector('.status-text')
            
            statusIndicator.className = 'status-indicator'
            statusText.textContent = status
            
            switch (status) {
                case 'Connected':
                    statusIndicator.classList.add('connected')
                    break
                case 'Disconnected':
                    statusIndicator.classList.add('disconnected')
                    break
                case 'Muted':
                    statusIndicator.classList.add('muted')
                    break
            }
        }

        // Chat mute functionality
        let chatMuted = false
        window.toggleChatMute = function() {
            chatMuted = !chatMuted
            const muteBtn = document.getElementById('chat-mute-btn')
            const muteIcon = muteBtn.querySelector('.quick-icon')
            
            if (chatMuted) {
                muteIcon.textContent = 'üîä'
                muteBtn.title = 'Unmute Chat'
                updateChatStatus('Muted')
                addChatMessage('System', 'Chat muted. You will not receive new messages.', true)
            } else {
                muteIcon.textContent = 'üîá'
                muteBtn.title = 'Toggle Chat Mute'
                updateChatStatus('Connected')
                addChatMessage('System', 'Chat unmuted. You will receive new messages.', true)
            }
        }

        // Enhanced message handling
        function handleIncomingMessage(message) {
            if (chatMuted) return
            
            // Parse message format: [sender]: message
            const match = message.match(/^\[([^\]]+)\]:\s*(.+)$/)
            if (match) {
                const [, sender, content] = match
                const isSelf = sender === currentPeerName
                addChatMessage(sender, content, false, isSelf)
            } else {
                // Fallback for non-formatted messages
                addChatMessage('Unknown', message)
            }
        }

        // Update functions
        function updatePeerList() {
            // Legacy function for backward compatibility
            updateSquadRoster()
        }

        function updateRoomList() {
            const roomList = document.getElementById('room-list')
            const rooms = roomStore.getRooms(selectedProviderId)
            const providerLabel = getProviderLabel(selectedProviderId)

            if (rooms.length === 0) {
                roomList.innerHTML = `
                    <div class="room-item no-rooms">
                        <div class="room-name">No rooms discovered for ${providerLabel}</div>
                        <div class="room-details">
                            <span class="room-hint">Try "Discover Rooms" or "Refresh Room List"</span>
                        </div>
                    </div>
                `
            } else {
                roomList.innerHTML = rooms.map(room => {
                    const isFull = room.playerCount >= room.maxPlayers
                    const statusClass = isFull ? 'full' : 'available'
                    const timeAgo = getTimeAgo(room.lastSeen)
                    return `
                        <div class="room-item ${statusClass}" onclick="selectRoom('${room.id}')">
                            <div class="room-row">
                                <div class="room-main">
                                    <div class="room-name">${room.name}</div>
                                    <div class="room-details">
                                        <span class="room-id">ID: ${room.id}</span>
                                        <span class="room-players">${room.playerCount}/${room.maxPlayers}</span>
                                        <span class="room-time">Seen: ${timeAgo}</span>
                                    </div>
                                </div>
                                <button class="btn sm join-btn" onclick="joinSelectedRoom('${room.id}'); event.stopPropagation();" ${isFull ? 'disabled' : ''}>Join</button>
                            </div>
                        </div>
                    `
                }).join('')
            }
        }
        
        function getTimeAgo(timestamp) {
            const now = Date.now()
            const diff = now - timestamp
            const seconds = Math.floor(diff / 1000)
            const minutes = Math.floor(seconds / 60)
            const hours = Math.floor(minutes / 60)
            
            if (seconds < 60) return `${seconds}s ago`
            if (minutes < 60) return `${minutes}m ago`
            if (hours < 24) return `${hours}h ago`
            return 'long ago'
        }
        
        // Broadcast room info using alternative mechanisms (no room joining required)
        async function broadcastToLobby(providerId, roomInfo) {
            if (!networkManager) return
            
            // Prevent too frequent broadcasts (max once per 5 seconds)
            const now = Date.now()
            if (now - lastLobbyBroadcast < 5000) {
                addLog(`Lobby broadcast throttled for ${providerId}`, 'info')
                return
            }
            
            lastLobbyBroadcast = now
            
            try {
                addLog(`Broadcasting room ${roomInfo.id} using alternative discovery`, 'info')
                
                // Method 1: Store room info in localStorage for cross-tab discovery
                const discoveryKey = `room-discovery-${providerId}`
                const existingRooms = JSON.parse(localStorage.getItem(discoveryKey) || '[]')
                
                // Remove old entries for this room
                const filteredRooms = existingRooms.filter(r => r.id !== roomInfo.id)
                
                // Add current room info with timestamp
                const roomWithTimestamp = {
                    ...roomInfo,
                    broadcastTime: now,
                    // Shorter TTL to reduce stale rooms in lobby
                    expiresAt: now + (60 * 1000) // 60 seconds
                }
                filteredRooms.push(roomWithTimestamp)
                
                // Keep only recent rooms (last 10 minutes)
                const recentRooms = filteredRooms.filter(r => now - r.broadcastTime < (10 * 60 * 1000))
                
                localStorage.setItem(discoveryKey, JSON.stringify(recentRooms))
                
                // Method 2: Use BroadcastChannel API for same-origin discovery
                if (typeof BroadcastChannel !== 'undefined') {
                    try {
                        const channel = new BroadcastChannel(`room-discovery-${providerId}`)
                        channel.postMessage({
                            type: 'room-broadcast',
                            roomInfo: { ...roomWithTimestamp, creatorId: selfClientId },
                            timestamp: now
                        })
                        channel.close()
                        addLog(`Broadcasted room ${roomInfo.id} via BroadcastChannel`, 'info')
                    } catch (error) {
                        addLog(`BroadcastChannel failed: ${error.message}`, 'info')
                    }
                }
                
                // Method 3: Use WebRTC DataChannel for P2P discovery (if available)
                if (room && room.makeAction) {
                    try {
                        // Create a temporary discovery action
                        const [sendDiscoveryAction] = room.makeAction('roomDiscovery')
                        sendDiscoveryAction({
                            type: 'room-announcement',
                            roomInfo: roomWithTimestamp,
                            timestamp: now
                        })
                        addLog(`Broadcasted room ${roomInfo.id} via P2P discovery`, 'info')
                    } catch (error) {
                        addLog(`P2P discovery failed: ${error.message}`, 'info')
                    }
                }
                
                addLog(`Successfully broadcasted room ${roomInfo.id} using multiple methods`, 'success')
                
            } catch (error) {
                addLog(`Failed to broadcast room: ${error.message}`, 'error')
            }
        }
        
        function updateStatus() {
            const currentProvider = networkManager && typeof networkManager.getCurrentProvider === 'function'
                ? networkManager.getCurrentProvider()
                : null
            const providerLabel = currentProvider ? currentProvider.name : (selectedProviderId ? getProviderLabel(selectedProviderId) : 'None')
            const peersObj = networkManager && typeof networkManager.getPeers === 'function'
                ? networkManager.getPeers()
                : {}
            const remotePeerCount = peersObj ? Object.keys(peersObj).length : 0
            const totalPlayers = remotePeerCount + (isInRoom ? 1 : 0)

            document.getElementById('peer-count').textContent = totalPlayers

            const connectionEl = document.getElementById('connection-quality')
            if (!room) {
                connectionEl.textContent = providerLabel ? `Link idle - ${providerLabel}` : 'Link idle'
            } else if (remotePeerCount > 0) {
                const allyLabel = remotePeerCount === 1 ? 'ally' : 'allies'
                connectionEl.textContent = `Synced with ${remotePeerCount} ${allyLabel}`
            } else {
                connectionEl.textContent = 'Gate open - awaiting allies'
            }

            const subline = document.querySelector('.status-subline')
            if (subline) {
                subline.textContent = room
                    ? `Active on ${providerLabel || 'Unknown provider'}`
                    : `Preparing link via ${providerLabel || 'No provider selected'}`
            }

            updateJourneyProgress()
        }

        // Peer name management functions
        window.generateNewPeerName = function() {
            const oldName = currentPeerName
            currentPeerName = peerNameGenerator.generateName()
            
            document.getElementById('peer-name').textContent = currentPeerName
            
            // Store our own name in the peerNames map
            if (room && room.getSelfId) {
                const ourPeerId = room.getSelfId()
                peerNames.set(ourPeerId, currentPeerName)
            }
            
            if (oldName) {
                peerNameGenerator.releaseName(oldName)
                addLog(`Peer name changed from "${oldName}" to "${currentPeerName}"`, 'info')
            } else {
                addLog(`Generated new peer name: "${currentPeerName}"`, 'success')
            }
            
            updateStatus()
            updatePeerList()
        }
        
        window.showPeerNameStats = function() {
            const stats = peerNameGenerator.getStats()
            addLog('=== Peer Name Statistics ===', 'success')
            addLog(`Total possible combinations: ${stats.totalPossible}`)
            addLog(`Names used: ${stats.usedCount}`)
            addLog(`Names available: ${stats.availableCount}`)
            addLog(`Usage: ${stats.usagePercentage}%`)
            addLog(`Current name: "${currentPeerName}"`)
        }
        
        // Debug function to clear cooldown (for testing)
        window.clearCooldown = function() {
            if (roomCreationCooldown) {
                clearInterval(roomCreationCooldown)
                roomCreationCooldown = null
                cooldownEndTime = null
                addLog('Room creation cooldown manually cleared', 'success')
                updateButtonVisibility()
            } else {
                addLog('No active creation cooldown to clear', 'info')
            }
        }
        
        // Debug function to clear join cooldown (for testing)
        window.clearJoinCooldown = function() {
            if (roomJoinCooldown) {
                clearInterval(roomJoinCooldown)
                roomJoinCooldown = null
                joinCooldownEndTime = null
                addLog('Room join cooldown manually cleared', 'success')
                updateButtonVisibility()
            } else {
                addLog('No active join cooldown to clear', 'info')
            }
        }
        
        // Function to check current timeout status
        window.checkTimeoutStatus = function() {
            const now = Date.now()
            let hasAnyTimeout = false
            let timeoutMessages = []
            
            // Check creation timeout
            if (roomCreationCooldown && cooldownEndTime && now < cooldownEndTime) {
                const remainingTime = Math.ceil((cooldownEndTime - now) / 1000)
                const minutes = Math.floor(remainingTime / 60)
                const seconds = remainingTime % 60
                const timeString = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`
                timeoutMessages.push(`Room Creation: ${timeString} remaining`)
                hasAnyTimeout = true
            }
            
            // Check join timeout
            if (roomJoinCooldown && joinCooldownEndTime && now < joinCooldownEndTime) {
                const remainingTime = Math.ceil((joinCooldownEndTime - now) / 1000)
                const minutes = Math.floor(remainingTime / 60)
                const seconds = remainingTime % 60
                const timeString = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`
                timeoutMessages.push(`Room Join: ${timeString} remaining`)
                hasAnyTimeout = true
            }
            
            if (hasAnyTimeout) {
                const statusMessage = `‚è∞ TIMEOUT STATUS\n\nYou are currently in timeout periods:\n\n${timeoutMessages.join('\n')}\n\nThese timeouts prevent spam and ensure stable connections.`
                showAlert(statusMessage, AlertTypes.ERROR)
                addLog(`Timeout status: ${timeoutMessages.join(', ')}`, 'info')
            } else {
                const statusMessage = `‚úÖ NO TIMEOUTS\n\nYou are not currently in any timeout periods.\n\nYou can create or join rooms freely.`
                showAlert(statusMessage, AlertTypes.INFO)
                addLog('No active timeouts - room operations allowed', 'info')
            }
        }
        
        // Initialize demo
        addLog('Working Multiplayer Demo initialized', 'success')
        addLog('Select a network provider and create/join a room to start', 'info')
        addLog('üí° Tip: "Create Room" generates a room ID if none provided. "Join Room" requires a specific room ID.', 'info')
        
        // Initialize chat status
        updateChatStatus('Ready')
        
        // Add keyboard support for chat input
        document.addEventListener('keydown', function(event) {
            const chatInput = document.getElementById('chat-message')
            if (event.key === 'Enter' && chatInput && document.activeElement === chatInput) {
                event.preventDefault()
                sendMessage()
            }
        })
        
        // Initialize network manager immediately
        setupNetworkManagerIfNeeded()
        addLog('Network manager initialized', 'success')
        
        // Generate initial peer name
        generateNewPeerName()
        
        // Set up BroadcastChannel for room discovery
        if (typeof BroadcastChannel !== 'undefined') {
            try {
                broadcastChannel = new BroadcastChannel(`room-discovery-${selectedProviderId}`)
                broadcastChannel.addEventListener('message', (event) => {
                    if (event.data.type === 'room-broadcast') {
                        const stored = recordDiscoveredRoom(selectedProviderId, event.data.roomInfo)
                        if (stored) {
                            addLog(`Discovered room via BroadcastChannel: ${stored.name}`, 'info')
                            updateRoomList()
                        }
                    } else if (event.data.type === 'discovery-request') {
                        // Respond to discovery requests if we're in a room
                        if (room && sendRoomInfo && currentPeerName) {
                            const currentRoomId = document.getElementById('room-id').textContent
                        if (currentRoomId && currentRoomId !== 'Not Connected') {
                            const peers = networkManager.getPeers()
                            const roomInfo = {
                                id: currentRoomId,
                                roomId: currentRoomId,
                                roomName: `Room ${currentRoomId}`,
                                name: `Room ${currentRoomId}`,
                                playerCount: Object.keys(peers).length + 1,
                                maxPlayers: 8,
                                hostName: currentPeerName,
                                providerId: selectedProviderId,
                                creatorId: selfClientId,
                                broadcastTime: Date.now(),
                                expiresAt: Date.now() + (60 * 1000)
                            }
                            broadcastChannel.postMessage({
                                type: 'room-broadcast',
                                roomInfo: roomInfo,
                                timestamp: Date.now()
                            })
                                addLog(`Responded to discovery request with room: ${currentRoomId}`, 'info')
                            }
                        }
                    }
                })
                addLog('BroadcastChannel initialized for room discovery', 'success')
            } catch (error) {
                addLog(`BroadcastChannel initialization failed: ${error.message}`, 'error')
            }
        }
        
        updateStatus()
        updateRoomList()
        updateButtonVisibility()
        updateNearbyRoomsUI()
        updateTileVisibility()
        
        // Auto-refresh status and room list
        setInterval(updateStatus, 2000)
        setInterval(updateButtonVisibility, 1000) // Update button visibility every second for cooldown countdown
        setInterval(() => {
            if (networkManager && room && sendRoomInfo && currentPeerName) {
                const providerId = getCurrentProviderId()
                const currentRoomId = document.getElementById('room-id').textContent

                if (currentRoomId && currentRoomId !== 'Not Connected') {
                    const peers = networkManager.getPeers()
                    const roomInfo = {
                        id: currentRoomId,
                        roomId: currentRoomId,
                        roomName: `Room ${currentRoomId}`,
                        name: `Room ${currentRoomId}`,
                        playerCount: Object.keys(peers).length + 1,
                        maxPlayers: 8,
                        hostName: currentPeerName,
                        providerId,
                        creatorId: selfClientId
                    }
                    recordDiscoveredRoom(providerId, roomInfo)
                    sendRoomInfo(roomInfo)
                    
                    // Also broadcast to lobby periodically (less frequently)
                    broadcastToLobby(providerId, roomInfo)
                }
            }
        }, 30000) // Broadcast every 30 seconds (reduced frequency)
        
        // Periodic peer info broadcast to ensure all peers know each other's names
        // More frequent initially, then reduce frequency
        let peerInfoBroadcastCount = 0
        setInterval(() => {
            if (networkManager && room && sendPeerInfo && currentPeerName) {
                const ourPeerId = room.getSelfId ? room.getSelfId() : 'self'
                sendPeerInfo({ peerId: ourPeerId, peerName: currentPeerName })
                peerInfoBroadcastCount++
                
                // Log less frequently to avoid spam
                if (peerInfoBroadcastCount % 6 === 0) { // Every 30 seconds
                    addLog(`Periodic peer info broadcast (${peerInfoBroadcastCount}th)`, 'info')
                }
            }
        }, 5000) // Broadcast peer info every 5 seconds
        
        // Clean up old room discoveries (shorter TTL when not in a room)
        setInterval(() => {
            const ttl = isInRoom ? 30000 : 10000
            const removed = roomStore.cleanup(ttl)
            if (removed) {
                updateRoomList()
            }
        }, 5000) // Clean up every 5 seconds
        
        // Clean up BroadcastChannel on page unload
        window.addEventListener('beforeunload', () => {
            if (broadcastChannel) {
                broadcastChannel.close()
            }
        })
    </script>
    </div> <!-- Close demo-container -->
</body>
</html>

