const e="Trystero",r=(e,r)=>Array(e).fill().map(r),t="0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",n=e=>{const a=(()=>{try{return"undefined"!=typeof globalThis&&globalThis.crypto&&"function"==typeof globalThis.crypto.getRandomValues?globalThis.crypto:null}catch(e){return null}})();if(a){const r=new Uint8Array(e);return a.getRandomValues(r),Array.from(r,e=>t[e%62]).join("")}const o=n.counter||0;n.counter=(o+1)%1e6;const s=Date.now()+o;return r(e,(e,r)=>t[Math.abs((s+1664525*r+1013904223)%62)%62]).join("")},a=n(20),o=Promise.all.bind(Promise),s="undefined"!=typeof window,{entries:i,fromEntries:c,keys:l}=Object,d=()=>{},u=r=>Error(`${e}: ${r}`),f=new TextEncoder,y=new TextDecoder,p=e=>f.encode(e),m=e=>y.decode(e),w=(...e)=>e.join("@"),g=JSON.stringify,h=JSON.parse,b={},v="AES-GCM",k={},T=async e=>k[e]||=Array.from(await(async(e,r)=>new Uint8Array(await crypto.subtle.digest(e,p(r))))("SHA-1",e)).map(e=>e.toString(36)).join(""),P=async(e,r)=>{const t=crypto.getRandomValues(new Uint8Array(16));return t.join(",")+"$"+(n=await crypto.subtle.encrypt({name:v,iv:t},await e,p(r)),btoa(String.fromCharCode.apply(null,new Uint8Array(n))));var n},A=async(e,r)=>{if(!r||"string"!=typeof r||!r.includes("$"))throw Error("Invalid encrypted data format");const[t,n]=r.split("$");if(!t||!n)throw Error("Missing IV or ciphertext in encrypted data");return m(await crypto.subtle.decrypt({name:v,iv:new Uint8Array(t.split(","))},await e,(e=>{const r=atob(e);return new Uint8Array(r.length).map((e,t)=>r.charCodeAt(t)).buffer})(n)))},S="icegatheringstatechange",D="offer";var $=(e,{rtcConfig:r,rtcPolyfill:t,turnConfig:n})=>{const a=new(t||RTCPeerConnection)({iceServers:I.concat(n||[]),...r}),s={};let i=!1,c=!1,l=null;const d=e=>{e.binaryType="arraybuffer",e.bufferedAmountLowThreshold=65535,e.onmessage=e=>s.data?.(e.data),e.onopen=()=>s.connect?.(),e.onclose=()=>s.close?.(),e.onerror=e=>s.error?.(e)},u=e=>Promise.race([new Promise(r=>{const t=()=>{"complete"===e.iceGatheringState&&(e.removeEventListener(S,t),r())};e.addEventListener(S,t),t()}),new Promise(e=>setTimeout(e,5e3))]).then(()=>({type:e.localDescription.type,sdp:e.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")}));return e?(l=a.createDataChannel("data"),d(l)):a.ondatachannel=({channel:e})=>{l=e,d(e)},a.onnegotiationneeded=async()=>{try{i=!0,await a.setLocalDescription();const e=await u(a);s.signal?.(e)}catch(e){s.error?.(e)}finally{i=!1}},a.onconnectionstatechange=()=>{["disconnected","failed","closed"].includes(a.connectionState)&&s.close?.()},a.ontrack=e=>{s.track?.(e.track,e.streams[0]),s.stream?.(e.streams[0])},a.onremovestream=e=>s.stream?.(e.stream),e&&(a.canTrickleIceCandidates||a.onnegotiationneeded()),{created:Date.now(),connection:a,get channel(){return l},get isDead(){return"closed"===a.connectionState},async signal(r){if("open"!==l?.readyState||r.sdp?.includes("a=rtpmap"))try{if(r.type===D){if(i||"stable"!==a.signalingState&&!c){if(e)return;await o([a.setLocalDescription({type:"rollback"}),a.setRemoteDescription(r)])}else await a.setRemoteDescription(r);await a.setLocalDescription();const t=await u(a);return s.signal?.(t),t}if("answer"===r.type){c=!0;try{await a.setRemoteDescription(r)}finally{c=!1}}}catch(e){s.error?.(e)}},sendData(e){if(!l||"open"!==l.readyState)throw Error("Data channel is not available or not open");l.send(e)},destroy(){l?.close(),a.close(),i=!1,c=!1},setHandlers(e){return Object.assign(s,e)},offerPromise:e?new Promise(e=>s.signal=r=>{r.type===D&&e(r)}):Promise.resolve(),addStream(e){return e.getTracks().forEach(r=>a.addTrack(r,e))},removeStream(e){return a.getSenders().filter(r=>e.getTracks().includes(r.track)).forEach(e=>a.removeTrack(e))},addTrack(e,r){return a.addTrack(e,r)},removeTrack(e){const r=a.getSenders().find(r=>r.track===e);r&&a.removeTrack(r)},replaceTrack(e,r){const t=a.getSenders().find(r=>r.track===e);if(t)return t.replaceTrack(r)}}};const I=[...r(3,(e,r)=>`stun:stun${r||""}.l.google.com:19302`),"stun:stun.cloudflare.com:3478"].map(e=>({urls:e})),L=["none","error","warn","info","debug"],E=(e={})=>{const{level:r="warn",prefix:t="Trystero"}=e||{},n=L.includes(r)?L.indexOf(r):L.indexOf("warn"),a=e=>L.indexOf(e)<=n&&n>0,o=e=>`[${t}:${e}]`;return{error(...e){return a("error")&&console.error(o("error"),...e)},warn(...e){return a("warn")&&console.warn(o("warn"),...e)},info(){return a("info")&&void 0},debug(...e){return a("debug")&&console.debug(o("debug"),...e)}}},C=Object.getPrototypeOf(Uint8Array),U=16369,_=255,O="bufferedamountlow",j=e=>"@_"+e;var x=(t,n,a,f)=>{const y=f||E({level:"none"}),w={},b={},v={},k={},T={},P={},A={},S={onPeerJoin:d,onPeerLeave:d,onPeerStream:d,onPeerTrack:d},D=(r,t)=>(r?Array.isArray(r)?r:[r]:l(w)).flatMap(r=>{const n=w[r];return n?t(r,n):(y.warn(`${e}: no peer with id ${r} found`),[])}),$=e=>{w[e]&&(w[e].destroy(),delete w[e],delete k[e],delete T[e],S.onPeerLeave(e),n(e))},I=e=>{if(b[e])return v[e];if(!e)throw u("action type argument is required");const t=p(e);if(t.byteLength>12)throw u(`action type string "${e}" (${t.byteLength}b) exceeds byte limit (12). Hint: choose a shorter name.`);const n=new Uint8Array(12);n.set(t);let a=0;return b[e]={onComplete:d,onProgress:d,setOnComplete(r){return b[e]={...b[e],onComplete:r}},setOnProgress(r){return b[e]={...b[e],onProgress:r}},async send(e,t,s,i){if(s&&"object"!=typeof s)throw u("action meta argument must be an object");const c=typeof e;if("undefined"===c)throw u("action data cannot be undefined");const l="string"!==c,d=e instanceof Blob,f=d||e instanceof ArrayBuffer||e instanceof C;if(s&&!f)throw u("action meta argument can only be used with binary data");const y=f?new Uint8Array(d?await e.arrayBuffer():e):p(l?g(e):e),m=s?p(g(s)):null,h=Math.ceil(y.byteLength/U)+(s?1:0)||1,b=r(h,(e,r)=>{const t=r===h-1,o=s&&0===r,i=new Uint8Array(15+(o?m.byteLength:t?y.byteLength-U*(h-(s?2:1)):U));return i.set(n),i.set([a],12),i.set([t|o<<1|f<<2|l<<3],13),i.set([Math.round((r+1)/h*_)],14),i.set(s?o?m:y.subarray((r-1)*U,r*U):y.subarray(r*U,(r+1)*U),15),i});return a=a+1&_,o(D(t,async(e,r)=>{const{channel:t}=r;let n=0;for(;n<h;){const a=b[n];if(t.bufferedAmount>t.bufferedAmountLowThreshold&&await new Promise(e=>{const r=()=>{t.removeEventListener(O,r),e()};t.addEventListener(O,r)}),!w[e])break;r.sendData(a),n++,i?.(a[14]/_,e,s)}}))}},v[e]||=[b[e].send,b[e].setOnComplete,b[e].setOnProgress]},L=async()=>{await z(""),await new Promise(e=>setTimeout(e,99)),i(w).forEach(([e,r])=>{r.destroy(),delete w[e]}),a()},[x,H]=I(j("ping")),[R,M]=I(j("pong")),[J,V]=I(j("signal")),[q,B]=I(j("stream")),[G,N]=I(j("track")),[z,K]=I(j("leave"));return t((r,t)=>{w[t]||(w[t]=r,r.setHandlers({data(r){return((r,t)=>{const n=new Uint8Array(t),a=m(n.subarray(0,12)).replaceAll("\0",""),[o]=n.subarray(12,13),[s]=n.subarray(13,14),[i]=n.subarray(14,15),c=n.subarray(15),l=!!(1&s),d=!!(2&s),u=!!(4&s),f=!!(8&s);if(!b[a])return void console.warn(`${e}: received message with unregistered type (${a})`);if(!w[r])return;k[r]||={},k[r][a]||={};const y=k[r][a][o]||={chunks:[]};if(d?y.meta=h(m(c)):y.chunks.push(c),b[a].onProgress(i/_,r,y.meta),!l)return;const p=new Uint8Array(y.chunks.reduce((e,r)=>e+r.byteLength,0));if(y.chunks.reduce((e,r)=>(p.set(r,e),e+r.byteLength),0),k[r]?.[a]&&delete k[r][a][o],u)b[a].onComplete(p,r,y.meta);else{const e=m(p);b[a].onComplete(f?h(e):e,r)}})(t,r)},stream(e){S.onPeerStream(e,t,P[t]),delete P[t]},track(e,r){S.onPeerTrack(e,r,t,A[t]),delete A[t]},signal(e){return J(e,t)},close(){return $(t)},error(e){y.error(e),$(t)}}),S.onPeerJoin(t))}),H((e,r)=>R("",r)),M((e,r)=>{T[r]?.(),delete T[r]}),V((e,r)=>w[r]?.signal(e)),B((e,r)=>P[r]=e),N((e,r)=>A[r]=e),K((e,r)=>$(r)),s&&addEventListener("beforeunload",L),{makeAction:I,leave:L,async ping(e){if(!e)throw u("ping() must be called with target peer ID");const r=Date.now();return x("",e),await new Promise(r=>T[e]=r),Date.now()-r},getPeers(){return c(i(w).map(([e,r])=>[e,r.connection]))},addStream(e,r,t){return D(r,async(r,n)=>{t&&await q(t,r),n.addStream(e)})},removeStream(e,r){return D(r,(r,t)=>t.removeStream(e))},addTrack(e,r,t,n){return D(t,async(t,a)=>{n&&await G(n,t),a.addTrack(e,r)})},removeTrack(e,r){return D(r,(r,t)=>t.removeTrack(e))},replaceTrack(e,r,t,n){return D(t,async(t,a)=>{n&&await G(n,t),a.replaceTrack(e,r)})},onPeerJoin(e){return S.onPeerJoin=e},onPeerLeave(e){return S.onPeerLeave=e},onPeerStream(e){return S.onPeerStream=e},onPeerTrack(e){return S.onPeerTrack=e}}};const H={},R={},M={},J={},V={},q={},B={},G={},N=async e=>{if(R[e])return R[e];const r=(await T(e)).slice(0,20);return R[e]=r,M[r]=e,r},z=async(e,r,t)=>e.send(g({action:"announce",info_hash:await N(r),peer_id:a,...t})),K=(r,t,n)=>console.warn(`${e}: torrent tracker ${n?"failure":"warning"} from ${r} - ${t}`),W=(({init:t,subscribe:n,announce:s})=>{const i={};let c,l,f,y=0,m=!1;return(b,k,S)=>{const D=(e=>{if(!e)throw u("requires a config map as the first argument");const r={...e};return r.logger=E(e.logger),r.rtcConfig||={},r})(b),{appId:I,logger:L}=D;if(i[I]?.[k])return i[I][k];const C={},U={},_=w(e,I,k),O=T(_),j=T(w(_,a)),H=(async(e,r,t)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},p(`${e}:${r}:${t}`)),{name:v},!1,["encrypt","decrypt"]))(D.password||"",I,k),R=e=>async r=>({type:r.type,sdp:await e(H,r.sdp)}),M=R(A),J=R(P),V=()=>$(!0,D),q=(e,r,t)=>{U[r]?U[r]!==e&&e.destroy():(U[r]=e,Q(e,r),C[r]?.forEach((e,r)=>{r!==t&&e.destroy()}),delete C[r])},B=(e,r)=>{U[r]===e&&delete U[r]},G=e=>(l.push(...r(e,V)),o(l.splice(0,e).map(e=>e.offerPromise.then(J).then(r=>({peer:e,offer:r}))))),N=(e,r)=>S?.({error:`incorrect password (${D.password}) when decrypting ${r}`,appId:I,peerId:e,roomId:k}),z=e=>async(r,t,n)=>{const[s,i]=await o([O,j]);if(r!==s&&r!==i)return;const{peerId:c,offer:l,answer:d,peer:u}="string"==typeof t?h(t):t;if(c!==a&&!U[c])if(!c||l||d){if(l){const r=C[c]?.[e];if(r&&a>c)return;const t=$(!1,D);let s;t.setHandlers({connect(){return q(t,c,e)},close(){return B(t,c)}});try{s=await M(l)}catch{return void N(c,"offer")}if(t.isDead)return;const[i,d]=await o([T(w(_,c)),t.signal(s)]);n(i,g({peerId:a,answer:await J(d)}))}else if(d){let r;try{r=await M(d)}catch(e){return void N(c,"answer")}if(u)u.setHandlers({connect(){return q(u,c,e)},close(){return B(u,c)}}),u.signal(r);else{const t=C[c]?.[e];t&&!t.isDead&&t.signal(r)}}}else{if(C[c]?.[e])return;const[[{peer:r,offer:t}],s]=await o([G(1),T(w(_,c))]);C[c]||=[],C[c][e]=r,setTimeout(()=>((e,r)=>{if(U[e])return;const t=C[e]?.[r];t&&(delete C[e][r],t.destroy())})(c,e),.9*K[e]),r.setHandlers({connect(){return q(r,c,e)},close(){return B(r,c)}}),n(s,g({peerId:a,offer:t}))}};if(!I&&!D.firebaseApp)throw u("config map is missing appId field");if(!k)throw u("roomId argument required");if(!m){const e=t(b);l=r(20,V),c=Array.isArray(e)?e:[e],m=!0,f=setInterval(()=>l=l.filter(e=>{const r=Date.now()-e.created<57333;return r||e.destroy(),r}),59052.99)}const K=c.map(()=>5333),W=[],F=c.map(async(e,r)=>n(await e,await O,await j,z(r),G));o([O,j]).then(([e,r])=>{const t=async(n,a)=>{const o=await s(n,e,r);"number"==typeof o&&(K[a]=o),W[a]=setTimeout(()=>t(n,a),K[a])};F.forEach(async(e,r)=>{await e,t(await c[r],r)})});let Q=d;return i[I]||={},y++,i[I][k]=x(e=>Q=e,e=>delete U[e],()=>{delete i[I][k],W.forEach(clearTimeout),F.forEach(async e=>(await e)()),y--,y<=0&&(f&&(clearInterval(f),f=null),l?.forEach(e=>e.destroy()),l=[],c=null,m=!1)},L)}})({init(e){return((e,r,t)=>(e.relayUrls||r).slice(0,e.relayUrls?e.relayUrls.length:e.relayRedundancy||t))(e,X,3).map(e=>{const r=((e,r)=>{const t={},n=()=>{const a=new WebSocket(e);a.onclose=()=>{b[e]??=3333,setTimeout(n,b[e]),b[e]*=2},a.onmessage=e=>r(e.data),t.socket=a,t.url=a.url,t.ready=new Promise(r=>a.onopen=()=>{r(t),b[e]=3333}),t.send=e=>{1===a.readyState&&a.send(e)}};return n(),t})(e,e=>{const r=h(e),n=r["failure reason"],a=r["warning message"],{interval:o}=r,s=M[r.info_hash];if(n)K(t,n,!0);else{if(a&&K(t,a),o&&1e3*o>q[t]&&V[t][s]){const e=Math.min(1e3*o,120333);clearInterval(J[t][s]),q[t]=e,J[t][s]=setInterval(V[t][s],e)}B[r.offer_id]||(r.offer||r.answer)&&(B[r.offer_id]=!0,G[t][s]?.(r))}}),{url:t}=r;return H[t]=r,G[t]={},r.ready})},subscribe(e,r,t,a,o){const{url:s}=e,l=async()=>{const t=c((await o(10)).map(e=>[n(20),e]));G[e.url][r]=n=>{if(n.offer)a(r,{offer:n.offer,peerId:n.peer_id},(t,a)=>z(e,r,{answer:h(a).answer,offer_id:n.offer_id,to_peer_id:n.peer_id}));else if(n.answer){const e=t[n.offer_id];e&&a(r,{answer:n.answer,peerId:n.peer_id,peer:e.peer})}},z(e,r,{numwant:10,offers:i(t).map(([e,{offer:r}])=>({offer_id:e,offer:r}))})};return q[s]=33333,V[s]||={},V[s][r]=l,J[s]||={},J[s][r]=setInterval(l,q[s]),l(),()=>{clearInterval(J[s][r]),delete G[s][r],delete V[s][r]}},announce(e){return q[e.url]}}),F=(Q=H,()=>c(i(Q).map(([e,r])=>[e,r.socket])));var Q;const X=["tracker.webtorrent.dev","tracker.openwebtorrent.com","tracker.btorrent.xyz","tracker.files.fm:7073/announce"].map(e=>"wss://"+e);export{X as defaultRelayUrls,F as getRelaySockets,W as joinRoom,a as selfId};