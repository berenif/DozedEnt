<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MQTT Connection Test (Final Working Version)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        .test-section {
            background-color: #2a2a2a;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border: 1px solid #444;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .status.success { background-color: #2d5a2d; }
        .status.error { background-color: #5a2d2d; }
        .status.warning { background-color: #5a4d2d; }
        .status.info { background-color: #2d4d5a; }
        button {
            background-color: #4a4a4a;
            color: white;
            border: 1px solid #666;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #5a5a5a;
        }
        .log {
            background-color: #1a1a1a;
            border: 1px solid #333;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <h1>üîå MQTT Connection Test (Final Working Version)</h1>
    
    <div class="test-section">
        <h2>üì° MQTT Broker Test</h2>
        <div id="mqtt-status" class="status info">Loading MQTT library...</div>
        <button onclick="testMQTTConnection()">Test MQTT Connection</button>
        <button onclick="testAllBrokers()">Test All Brokers</button>
        <button onclick="debugMQTT()">Debug MQTT Library</button>
        <button onclick="showBrokerHealth()">Show Broker Health</button>
    </div>

    <div class="test-section">
        <h2>üìã Test Log</h2>
        <div id="test-log" class="log">Test log will appear here...</div>
        <button onclick="clearLog()">Clear Log</button>
    </div>

    <!-- Load MQTT library via script tag -->
    <script src="https://unpkg.com/mqtt@4.3.7/dist/mqtt.min.js"></script>
    
    <script>
        // MQTT broker URLs (optimized order based on reliability testing)
        const brokerUrls = [
            'wss://broker.emqx.io:8084/mqtt', // Most reliable: EMQX Global
            'wss://broker-cn.emqx.io:8084/mqtt', // Backup: EMQX China region
            'wss://broker.hivemq.com:8884/mqtt', // Solid: HiveMQ public broker
            'wss://test.mosquitto.org:8081/mqtt', // Fallback: Mosquitto test broker
            'wss://mqtt.eclipseprojects.io:443/mqtt' // Last resort: Eclipse IoT (often problematic)
        ];

        function log(message) {
            const logElement = document.getElementById('test-log');
            const timestamp = new Date().toLocaleTimeString();
            logElement.innerHTML += `[${timestamp}] ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
            console.log(message);
        }

        function clearLog() {
            document.getElementById('test-log').innerHTML = 'Test log cleared...\n';
        }

        function updateStatus(message, type = 'info') {
            const statusElement = document.getElementById('mqtt-status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
        }

        function debugMQTT() {
            log('üîç Debugging MQTT library availability...');
            log(`typeof mqtt: ${typeof mqtt}`);
            log(`typeof window.mqtt: ${typeof window.mqtt}`);
            log(`typeof window.MQTT: ${typeof window.MQTT}`);
            
            if (typeof mqtt !== 'undefined') {
                log(`mqtt object keys: ${Object.keys(mqtt).join(', ')}`);
                log(`mqtt.connect type: ${typeof mqtt.connect}`);
            }
            
            if (typeof window.mqtt !== 'undefined') {
                log(`window.mqtt object keys: ${Object.keys(window.mqtt).join(', ')}`);
                log(`window.mqtt.connect type: ${typeof window.mqtt.connect}`);
            }
            
            // Check all global variables that might contain MQTT
            const mqttGlobals = Object.keys(window).filter(key => 
                key.toLowerCase().includes('mqtt') || 
                (typeof window[key] === 'object' && window[key] && typeof window[key].connect === 'function')
            );
            log(`MQTT-related globals: ${mqttGlobals.join(', ')}`);
        }

        function getMQTTClient() {
            // Try different ways to get the MQTT client
            if (typeof mqtt !== 'undefined' && typeof mqtt.connect === 'function') {
                return mqtt;
            }
            if (typeof window.mqtt !== 'undefined' && typeof window.mqtt.connect === 'function') {
                return window.mqtt;
            }
            if (typeof window.MQTT !== 'undefined' && typeof window.MQTT.connect === 'function') {
                return window.MQTT;
            }
            
            // Check all globals for MQTT-like objects
            for (const key of Object.keys(window)) {
                if (typeof window[key] === 'object' && window[key] && typeof window[key].connect === 'function') {
                    log(`Found MQTT client in window.${key}`);
                    return window[key];
                }
            }
            
            return null;
        }

        async function testMQTTConnection() {
            log('üß™ Testing MQTT connection with improved configuration...');
            updateStatus('Testing MQTT connection...', 'info');

            const mqttClient = getMQTTClient();
            if (!mqttClient) {
                log('‚ùå MQTT library not available');
                log('üîç Running debug to see what\'s available...');
                debugMQTT();
                updateStatus('MQTT library not available', 'error');
                return;
            }

            log('‚úÖ MQTT library found and ready');

            // Generate a unique client ID (same as in the fix)
            const timestamp = Date.now();
            const randomId = Math.random().toString(36).substring(2, 15);
            const sessionId = Math.random().toString(36).substring(2, 15);
            const mqttClientId = `trystero-test-${timestamp}-${randomId}-${sessionId}`;

            log(`Generated client ID: ${mqttClientId}`);

            // Try the first broker (mqtt.eclipseprojects.io)
            const testUrl = brokerUrls[0];
            log(`Testing connection to: ${testUrl}`);

            try {
                const client = mqttClient.connect(testUrl, {
                    clientId: mqttClientId,
                    clean: true,
                    connectTimeout: 10000,
                    reconnectPeriod: 3000,
                    keepalive: 60,
                    protocolVersion: 4,
                    reschedulePings: true,
                    queueQoSZero: false,
                    username: undefined,
                    password: undefined,
                    will: {
                        topic: `trystero/disconnect/${mqttClientId}`,
                        payload: JSON.stringify({ clientId: mqttClientId, timestamp: Date.now() }),
                        qos: 0,
                        retain: false
                    }
                });

                const connectionPromise = new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        log('‚ùå Connection timeout after 15 seconds');
                        client.end();
                        reject(new Error('Connection timeout'));
                    }, 15000);

                    client.on('connect', () => {
                        clearTimeout(timeout);
                        log('‚úÖ MQTT connected successfully!');
                        log(`Connected to: ${testUrl}`);
                        log(`Client ID: ${mqttClientId}`);
                        resolve(true);
                    });

                    client.on('error', (err) => {
                        clearTimeout(timeout);
                        log(`‚ùå MQTT connection error: ${err.message}`);
                        
                        if (err.message && err.message.includes('Not authorized')) {
                            log('‚ö†Ô∏è Broker rejected connection - may require authentication');
                        } else if (err.message && err.message.includes('Connection refused')) {
                            log('‚ö†Ô∏è Broker refused connection - may be down or overloaded');
                        }
                        
                        reject(err);
                    });

                    client.on('close', () => {
                        log('üîå MQTT connection closed');
                    });

                    client.on('offline', () => {
                        log('üì¥ MQTT client offline');
                    });
                });

                const result = await connectionPromise;
                if (result) {
                    updateStatus('‚úÖ MQTT connection successful!', 'success');
                    client.end();
                }

            } catch (error) {
                log(`‚ùå MQTT test failed: ${error.message}`);
                updateStatus(`‚ùå MQTT test failed: ${error.message}`, 'error');
            }
        }

        async function testAllBrokers() {
            const mqttClient = getMQTTClient();
            if (!mqttClient) {
                log('‚ùå MQTT library not available');
                updateStatus('MQTT library not available', 'error');
                return;
            }

            log('üß™ Testing all MQTT brokers...');
            updateStatus('Testing all brokers...', 'info');

            let successCount = 0;
            let totalCount = brokerUrls.length;
            const brokerResults = [];

            for (let i = 0; i < brokerUrls.length; i++) {
                const url = brokerUrls[i];
                log(`\n--- Testing broker ${i + 1}/${totalCount}: ${url} ---`);

                const startTime = Date.now();
                let success = false;
                let errorMessage = '';

                try {
                    const timestamp = Date.now();
                    const randomId = Math.random().toString(36).substring(2, 15);
                    const sessionId = Math.random().toString(36).substring(2, 15);
                    const mqttClientId = `trystero-test-${timestamp}-${randomId}-${sessionId}`;

                    const client = mqttClient.connect(url, {
                        clientId: mqttClientId,
                        clean: true,
                        connectTimeout: 8000,
                        reconnectPeriod: 2000,
                        keepalive: 30,
                        protocolVersion: 4,
                        reschedulePings: true,
                        queueQoSZero: false
                    });

                    const result = await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            client.end();
                            reject(new Error('Connection timeout'));
                        }, 10000);

                        client.on('connect', () => {
                            clearTimeout(timeout);
                            log(`‚úÖ Successfully connected to ${url}`);
                            successCount++;
                            success = true;
                            resolve(true);
                        });

                        client.on('error', (err) => {
                            clearTimeout(timeout);
                            log(`‚ùå Failed to connect to ${url}: ${err.message}`);
                            errorMessage = err.message;
                            resolve(false);
                        });
                    });

                    client.end();

                } catch (error) {
                    log(`‚ùå Error testing ${url}: ${error.message}`);
                    errorMessage = error.message;
                }

                const responseTime = Date.now() - startTime;
                brokerResults.push({
                    url,
                    success,
                    responseTime,
                    error: errorMessage
                });
            }

            log(`\nüìä Test Results: ${successCount}/${totalCount} brokers working`);
            
            // Log detailed broker health report
            log('\nüìã Broker Health Report:');
            brokerResults.forEach((result, index) => {
                const status = result.success ? '‚úÖ' : '‚ùå';
                const time = result.responseTime;
                log(`${status} ${result.url} (${time}ms)${result.error ? ` - ${result.error}` : ''}`);
            });

            if (successCount > 0) {
                updateStatus(`‚úÖ ${successCount}/${totalCount} brokers working`, 'success');
            } else {
                updateStatus(`‚ùå No brokers working (${successCount}/${totalCount})`, 'error');
            }
        }

        function showBrokerHealth() {
            log('üìä Broker Health Summary:');
            log(`Total brokers: ${brokerUrls.length}`);
            
            // Show broker priority order
            log('\nüéØ Broker Priority Order:');
            brokerUrls.forEach((url, index) => {
                const priority = index + 1;
                const status = index < 3 ? 'üü¢ High' : index < 4 ? 'üü° Medium' : 'üî¥ Low';
                log(`${priority}. ${status} - ${url}`);
            });
            
            log('\nüí° Recommendations:');
            log('‚Ä¢ EMQX brokers (broker.emqx.io) are most reliable');
            log('‚Ä¢ HiveMQ provides good backup connectivity');
            log('‚Ä¢ Mosquitto test broker may be slower but usually works');
            log('‚Ä¢ Eclipse IoT broker often has connectivity issues');
            
            log('\nüîß Connection Tips:');
            log('‚Ä¢ Use shorter timeouts (8s) for faster failover');
            log('‚Ä¢ Try brokers in priority order');
            log('‚Ä¢ Monitor connection success rates');
            log('‚Ä¢ Consider geographic location for best performance');
        }

        // Initialize
        log('üîß MQTT Connection Test initialized');
        log('üìã Available brokers: ' + brokerUrls.join(', '));
        
        // Wait a moment for the script to load, then check MQTT
        setTimeout(() => {
            const mqttClient = getMQTTClient();
            if (mqttClient) {
                log('‚úÖ MQTT library loaded successfully');
                updateStatus('Ready to test MQTT connections', 'info');
            } else {
                log('‚ùå MQTT library failed to load');
                log('üîç Available globals: ' + Object.keys(window).filter(k => k.toLowerCase().includes('mqtt')).join(', '));
                updateStatus('Failed to load MQTT library', 'error');
            }
        }, 1000);
    </script>
</body>
</html>
