const e=new TextDecoder,t=new TextEncoder,n=async(e,t)=>{if(r=e,"undefined"!=typeof Response&&r instanceof Response)try{const n="function"==typeof e.clone?e.clone():e;return await WebAssembly.instantiateStreaming(n,t)}catch(n){const r="function"==typeof e.clone?e.clone():e,o=await r.arrayBuffer();return await WebAssembly.instantiate(o,t)}var r;if((e=>"string"==typeof e&&/\.wasm($|\?|#)/.test(e))(e)){const r=await fetch(e);return await n(r,t)}if((e=>e instanceof ArrayBuffer||e instanceof Uint8Array)(e)){const n=e instanceof Uint8Array?e:new Uint8Array(e);return await WebAssembly.instantiate(n,t)}throw new TypeError("Unsupported WASM source; expected URL/Response/bytes")},r=e=>({env:{memory:e,abort(){throw Error("wasm abort")},abort_(){throw Error("wasm abort_")},__console_log(t,n){new Uint8Array(e.buffer,t,n)}}}),o=(t,n)=>t&&"object"==typeof t?t:(t=>{const n=()=>new Uint8Array(t.buffer),r=()=>new DataView(t.buffer),o="undefined"!=typeof globalThis&&globalThis.crypto&&"function"==typeof globalThis.crypto.getRandomValues?globalThis.crypto:null,s=Object.create(null);return s.fd_write=(t,o,s,a)=>{let i=0;const f=r(),c=n();let u=o>>>0;for(let n=0;n<s>>>0;n++){const n=f.getUint32(u,!0),r=f.getUint32(u+4,!0);u+=8;const o=c.subarray(n,n+r),s=e.decode(o);1===t||2===t&&console.error(s),i+=r}return f.setUint32(a>>>0,i>>>0,!0),0},s.proc_exit=e=>{throw Error("WASI proc_exit: "+e)},s.random_get=(e,t)=>{const r=n().subarray(e>>>0,(e>>>0)+(t>>>0));if(o)o.getRandomValues(r);else for(let e=0;e<r.length;e++)r[e]=256*Math.random()|0;return 0},s.clock_time_get=(e,t,n)=>{const o=1000000n*BigInt(Date.now()),s=r();if("function"==typeof s.setBigUint64)s.setBigUint64(n>>>0,o,!0);else{const e=Number(0xffffffffn&o),t=Number(o>>32n&0xffffffffn);s.setUint32(n>>>0,e,!0),s.setUint32((n>>>0)+4,t,!0)}return 0},s.args_sizes_get=(e,t)=>{const n=r();return n.setUint32(e>>>0,0,!0),n.setUint32(t>>>0,0,!0),0},s.args_get=()=>0,s.environ_sizes_get=(e,t)=>{const n=r();return n.setUint32(e>>>0,0,!0),n.setUint32(t>>>0,0,!0),0},s.environ_get=()=>0,s.fd_close=()=>0,s.fd_seek=(e,t,n,o,s)=>(r().setUint32(s>>>0,0,!0),r().setUint32((s>>>0)+4,0,!0),0),Object.freeze(s)})(n),s=async(e,t={})=>{const s=t?.env?.memory||new WebAssembly.Memory({initial:16}),a={...r(s),...t,env:{...r(s).env,...t.env||{}},wasi_snapshot_preview1:o(t.wasi_snapshot_preview1,s),wasi_unstable:o(t.wasi_unstable,s)},{instance:i,module:f}=await n(e,a);return{instance:i,module:f,memory:s,exports:i.exports}},a=({memory:n,exports:r})=>{const o=r.malloc;return"function"!=typeof o?{toWasm(){throw Error("malloc export not found")},fromWasm(){throw Error("memory export not found")}}:{toWasm(e){const r=t.encode(e),s=o(r.byteLength);return new Uint8Array(n.buffer,s,r.byteLength).set(r),{ptr:s,len:r.byteLength}},fromWasm(t,r){return e.decode(new Uint8Array(n.buffer,t,r))}}},i=async({source:e,imports:t,onReady:n})=>{const r=await s(e,t),o={start:r.exports.start||(()=>{}),update:r.exports.update||(()=>{}),handleMessage:r.exports.handleMessage||(()=>{}),exports:r.exports,memory:r.memory};return n?.(o),r.exports};export{a as createStringCodec,i as initWasmGame,s as loadWasm};