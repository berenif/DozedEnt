function e(e=0){return new Uint8Array(e)}function t(e=0){return new Uint8Array(e)}const r=268435456,n=34359738368,s=4398046511104,i=Math.pow(2,49),o=128,a=127;function c(e){if(e<128)return 1;if(e<16384)return 2;if(e<2097152)return 3;if(e<r)return 4;if(e<n)return 5;if(e<s)return 6;if(e<i)return 7;if(null!=Number.MAX_SAFE_INTEGER&&e>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function l(e,t,r=0){switch(c(e)){case 8:t[r++]=255&e|o,e/=128;case 7:t[r++]=255&e|o,e/=128;case 6:t[r++]=255&e|o,e/=128;case 5:t[r++]=255&e|o,e/=128;case 4:t[r++]=255&e|o,e>>>=7;case 3:t[r++]=255&e|o,e>>>=7;case 2:t[r++]=255&e|o,e>>>=7;case 1:t[r++]=255&e,e>>>=7;break;default:throw Error("unreachable")}return t}function u(e,t){let c=e[t],l=0;if(l+=c&a,c<o)return l;if(c=e[t+1],l+=(c&a)<<7,c<o)return l;if(c=e[t+2],l+=(c&a)<<14,c<o)return l;if(c=e[t+3],l+=(c&a)<<21,c<o)return l;if(c=e[t+4],l+=(c&a)*r,c<o)return l;if(c=e[t+5],l+=(c&a)*n,c<o)return l;if(c=e[t+6],l+=(c&a)*s,c<o)return l;if(c=e[t+7],l+=(c&a)*i,c<o)return l;throw new RangeError("Could not decode varint")}function h(e,r,n=0){return null==r&&(r=t(c(e))),r instanceof Uint8Array?l(e,r,n):function(e,t,r=0){switch(c(e)){case 8:t.set(r++,255&e|o),e/=128;case 7:t.set(r++,255&e|o),e/=128;case 6:t.set(r++,255&e|o),e/=128;case 5:t.set(r++,255&e|o),e/=128;case 4:t.set(r++,255&e|o),e>>>=7;case 3:t.set(r++,255&e|o),e>>>=7;case 2:t.set(r++,255&e|o),e>>>=7;case 1:t.set(r++,255&e),e>>>=7;break;default:throw Error("unreachable")}return t}(e,r,n)}function d(e,t=0){return e instanceof Uint8Array?u(e,t):function(e,t){let c=e.get(t),l=0;if(l+=c&a,c<o)return l;if(c=e.get(t+1),l+=(c&a)<<7,c<o)return l;if(c=e.get(t+2),l+=(c&a)<<14,c<o)return l;if(c=e.get(t+3),l+=(c&a)<<21,c<o)return l;if(c=e.get(t+4),l+=(c&a)*r,c<o)return l;if(c=e.get(t+5),l+=(c&a)*n,c<o)return l;if(c=e.get(t+6),l+=(c&a)*s,c<o)return l;if(c=e.get(t+7),l+=(c&a)*i,c<o)return l;throw new RangeError("Could not decode varint")}(e,t)}const p=new Float32Array([-0]),f=new Uint8Array(p.buffer);function g(e,t,r){p[0]=e,t[r]=f[0],t[r+1]=f[1],t[r+2]=f[2],t[r+3]=f[3]}const m=new Float64Array([-0]),y=new Uint8Array(m.buffer);function b(e,t,r){m[0]=e,t[r]=y[0],t[r+1]=y[1],t[r+2]=y[2],t[r+3]=y[3],t[r+4]=y[4],t[r+5]=y[5],t[r+6]=y[6],t[r+7]=y[7]}const w=BigInt(Number.MAX_SAFE_INTEGER),v=BigInt(Number.MIN_SAFE_INTEGER);class E{lo;hi;constructor(e,t){this.lo=0|e,this.hi=0|t}toNumber(e=!1){if(!e&&this.hi>>>31>0){const e=1+~this.lo>>>0;let t=~this.hi>>>0;return 0===e&&(t=t+1>>>0),-(e+4294967296*t)}return this.lo+4294967296*this.hi}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31!=0){const e=1+~this.lo>>>0;let t=~this.hi>>>0;return 0===e&&(t=t+1>>>0),-(BigInt(e)+(BigInt(t)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){const e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){const e=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){const e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,r=this.hi>>>24;return 0===r?0===t?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:r<128?9:10}static fromBigInt(e){if(0n===e)return S;if(e<w&&e>v)return this.fromNumber(Number(e));const t=e<0n;t&&(e=-e);let r=e>>32n,n=e-(r<<32n);return t&&(r=0n|~r,n=0n|~n,++n>A&&(n=0n,++r>A&&(r=0n))),new E(Number(n),Number(r))}static fromNumber(e){if(0===e)return S;const t=e<0;t&&(e=-e);let r=e>>>0,n=(e-r)/4294967296>>>0;return t&&(n=~n>>>0,r=~r>>>0,++r>4294967295&&(r=0,++n>4294967295&&(n=0))),new E(r,n)}static from(e){return"number"==typeof e?E.fromNumber(e):"bigint"==typeof e?E.fromBigInt(e):"string"==typeof e?E.fromBigInt(BigInt(e)):null!=e.low||null!=e.high?new E(e.low>>>0,e.high>>>0):S}}const S=new E(0,0);S.toBigInt=()=>0n,S.zzEncode=S.zzDecode=function(){return this},S.length=()=>1;const A=4294967296n;function I(e,t,r){const n=r;let s,i;for(let n=0;n<e.length;++n)s=e.charCodeAt(n),s<128?t[r++]=s:s<2048?(t[r++]=s>>6|192,t[r++]=63&s|128):55296==(64512&s)&&56320==(64512&(i=e.charCodeAt(n+1)))?(s=65536+((1023&s)<<10)+(1023&i),++n,t[r++]=s>>18|240,t[r++]=s>>12&63|128,t[r++]=s>>6&63|128,t[r++]=63&s|128):(t[r++]=s>>12|224,t[r++]=s>>6&63|128,t[r++]=63&s|128);return r-n}function C(e,t){return RangeError(`index out of range: ${e.pos} + ${t??1} > ${e.len}`)}function x(e,t){return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0}class k{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(e){this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128)return e;if((this.pos+=5)>this.len)throw this.pos=this.len,C(this,10);return e}int32(){return 0|this.uint32()}sint32(){const e=this.uint32();return e>>>1^-(1&e)}bool(){return 0!==this.uint32()}fixed32(){if(this.pos+4>this.len)throw C(this,4);return x(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw C(this,4);return 0|x(this.buf,this.pos+=4)}float(){if(this.pos+4>this.len)throw C(this,4);const e=(t=this.buf,r=this.pos,f[0]=t[r],f[1]=t[r+1],f[2]=t[r+2],f[3]=t[r+3],p[0]);var t,r;return this.pos+=4,e}double(){if(this.pos+8>this.len)throw C(this,4);const e=(t=this.buf,r=this.pos,y[0]=t[r],y[1]=t[r+1],y[2]=t[r+2],y[3]=t[r+3],y[4]=t[r+4],y[5]=t[r+5],y[6]=t[r+6],y[7]=t[r+7],m[0]);var t,r;return this.pos+=8,e}bytes(){const e=this.uint32(),t=this.pos,r=this.pos+e;if(r>this.len)throw C(this,e);return this.pos+=e,t===r?new Uint8Array(0):this.buf.subarray(t,r)}string(){const e=this.bytes();return function(e,t,r){if(r-t<1)return"";let n;const s=[];let i,o=0;for(;t<r;)i=e[t++],i<128?s[o++]=i:i>191&&i<224?s[o++]=(31&i)<<6|63&e[t++]:i>239&&i<365?(i=((7&i)<<18|(63&e[t++])<<12|(63&e[t++])<<6|63&e[t++])-65536,s[o++]=55296+(i>>10),s[o++]=56320+(1023&i)):s[o++]=(15&i)<<12|(63&e[t++])<<6|63&e[t++],o>8191&&((n??(n=[])).push(String.fromCharCode.apply(String,s)),o=0);return null!=n?(o>0&&n.push(String.fromCharCode.apply(String,s.slice(0,o))),n.join("")):String.fromCharCode.apply(String,s.slice(0,o))}(e,0,e.length)}skip(e){if("number"==typeof e){if(this.pos+e>this.len)throw C(this,e);this.pos+=e}else do{if(this.pos>=this.len)throw C(this)}while(128&this.buf[this.pos++]);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(e=7&this.uint32());)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){const e=new E(0,0);let t=0;if(!(this.len-this.pos>4)){for(;t<3;++t){if(this.pos>=this.len)throw C(this);if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(127&this.buf[this.pos++])<<7*t)>>>0,e}for(;t<4;++t)if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(127&this.buf[this.pos])<<28)>>>0,e.hi=(e.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return e;if(t=0,this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw C(this);if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw C(this,8);const e=x(this.buf,this.pos+=4),t=x(this.buf,this.pos+=4);return new E(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const e=u(this.buf,this.pos);return this.pos+=c(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function T(e,t,r){const n=function(e){return new k(e instanceof Uint8Array?e:e.subarray())}(e);return t.decode(n,void 0,r)}function P(e){if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw Error("Unknown type, must be binary type")}var _=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var s=0;s<e.length;s++){var i=e.charAt(s),o=i.charCodeAt(0);if(255!==r[o])throw new TypeError(i+" is ambiguous");r[o]=s}var a=e.length,c=e.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function h(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var n=0,s=0;e[t]===c;)n++,t++;for(var i=(e.length-t)*l+1>>>0,o=new Uint8Array(i);e[t];){var u=r[e.charCodeAt(t)];if(255===u)return;for(var h=0,d=i-1;(0!==u||h<s)&&-1!==d;d--,h++)u+=a*o[d]>>>0,o[d]=u%256>>>0,u=u/256>>>0;if(0!==u)throw Error("Non-zero carry");s=h,t++}if(" "!==e[t]){for(var p=i-s;p!==i&&0===o[p];)p++;for(var f=new Uint8Array(n+(i-p)),g=n;p!==i;)f[g++]=o[p++];return f}}}return{encode(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var r=0,n=0,s=0,i=t.length;s!==i&&0===t[s];)s++,r++;for(var o=(i-s)*u+1>>>0,l=new Uint8Array(o);s!==i;){for(var h=t[s],d=0,p=o-1;(0!==h||d<n)&&-1!==p;p--,d++)h+=256*l[p]>>>0,l[p]=h%a>>>0,h=h/a>>>0;if(0!==h)throw Error("Non-zero carry");n=d,s++}for(var f=o-n;f!==o&&0===l[f];)f++;for(var g=c.repeat(r);f<o;++f)g+=e.charAt(l[f]);return g},decodeUnsafe:h,decode(e){var r=h(e);if(r)return r;throw Error(`Non-${t} character`)}}},R=_;let L=class{name;prefix;baseEncode;constructor(e,t,r){this.name=e,this.prefix=t,this.baseEncode=r}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},D=class{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,r){this.name=e,this.prefix=t;const n=t.codePointAt(0);if(void 0===n)throw Error("Invalid prefix character");this.prefixCodePoint=n,this.baseDecode=r}decode(e){if("string"==typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return N(this,e)}};class M{decoders;constructor(e){this.decoders=e}or(e){return N(this,e)}decode(e){const t=e[0],r=this.decoders[t];if(null!=r)return r.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function N(e,t){return new M({...e.decoders??{[e.prefix]:e},...t.decoders??{[t.prefix]:t}})}class O{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,r,n){this.name=e,this.prefix=t,this.baseEncode=r,this.baseDecode=n,this.encoder=new L(e,t,r),this.decoder=new D(e,t,n)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function U({name:e,prefix:t,encode:r,decode:n}){return new O(e,t,r,n)}function F({name:e,prefix:t,alphabet:r}){const{encode:n,decode:s}=R(r,e);return U({prefix:t,name:e,encode:n,decode(e){return P(s(e))}})}function B({name:e,prefix:t,bitsPerChar:r,alphabet:n}){const s=function(e){const t={};for(let r=0;r<e.length;++r)t[e[r]]=r;return t}(n);return U({prefix:t,name:e,encode:e=>function(e,t,r){const n="="===t[t.length-1],s=(1<<r)-1;let i="",o=0,a=0;for(let n=0;n<e.length;++n)for(a=a<<8|e[n],o+=8;o>r;)o-=r,i+=t[s&a>>o];if(0!==o&&(i+=t[s&a<<r-o]),n)for(;i.length*r&7;)i+="=";return i}(e,n,r),decode:t=>function(e,t,r,n){let s=e.length;for(;"="===e[s-1];)--s;const i=new Uint8Array(s*r/8|0);let o=0,a=0,c=0;for(let l=0;l<s;++l){const s=t[e[l]];if(void 0===s)throw new SyntaxError(`Non-${n} character`);a=a<<r|s,o+=r,o>=8&&(o-=8,i[c++]=255&a>>o)}if(o>=r||255&a<<8-o)throw new SyntaxError("Unexpected end of data");return i}(t,s,r,e)})}const q=F({prefix:"9",name:"base10",alphabet:"0123456789"});var $=Object.freeze({__proto__:null,base10:q});const z=B({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),K=B({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var V=Object.freeze({__proto__:null,base16:z,base16upper:K});const H=B({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var j=Object.freeze({__proto__:null,base2:H});const G=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),W=G.reduce((e,t,r)=>(e[r]=t,e),[]),X=G.reduce((e,t,r)=>{const n=t.codePointAt(0);if(null==n)throw Error("Invalid character: "+t);return e[n]=r,e},[]);const Z=U({prefix:"ðŸš€",name:"base256emoji",encode(e){return e.reduce((e,t)=>e+=W[t],"")},decode(e){const t=[];for(const r of e){const e=r.codePointAt(0);if(null==e)throw Error("Invalid character: "+r);const n=X[e];if(null==n)throw Error("Non-base256emoji character: "+r);t.push(n)}return new Uint8Array(t)}});var Q=Object.freeze({__proto__:null,base256emoji:Z});const Y=B({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),J=B({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),ee=B({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),te=B({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),re=B({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),ne=B({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),se=B({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),ie=B({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),oe=B({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var ae=Object.freeze({__proto__:null,base32:Y,base32hex:re,base32hexpad:se,base32hexpadupper:ie,base32hexupper:ne,base32pad:ee,base32padupper:te,base32upper:J,base32z:oe});const ce=F({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),le=F({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var ue=Object.freeze({__proto__:null,base36:ce,base36upper:le});const he=F({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),de=F({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var pe=Object.freeze({__proto__:null,base58btc:he,base58flickr:de});const fe=B({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),ge=B({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),me=B({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),ye=B({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var be=Object.freeze({__proto__:null,base64:fe,base64pad:ge,base64url:me,base64urlpad:ye});const we=B({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var ve=Object.freeze({__proto__:null,base8:we});const Ee=U({prefix:"\0",name:"identity",encode(e){return t=e,(new TextDecoder).decode(t);var t},decode(e){return function(e){return(new TextEncoder).encode(e)}(e)}});var Se=Object.freeze({__proto__:null,identity:Ee});new TextEncoder,new TextDecoder;var Ae=function e(t,r,n){r=r||[];var s=n=n||0;for(;t>=xe;)r[n++]=255&t|Ie,t/=128;for(;t&Ce;)r[n++]=255&t|Ie,t>>>=7;return r[n]=0|t,e.bytes=n-s+1,r},Ie=128,Ce=-128,xe=2147483648;var ke=function e(t,r){var n,s=0,i=0,o=r=r||0,a=t.length;do{if(o>=a)throw e.bytes=0,new RangeError("Could not decode varint");n=t[o++],s+=i<28?(n&Pe)<<i:(n&Pe)*Math.pow(2,i),i+=7}while(n>=Te);return e.bytes=o-r,s},Te=128,Pe=127;var _e=Math.pow(2,63),Re={encode:Ae,decode:ke,encodingLength(e){return e<128?1:e<16384?2:e<2097152?3:e<268435456?4:e<34359738368?5:e<4398046511104?6:e<562949953421312?7:e<72057594037927940?8:e<_e?9:10}};function Le(e,t=0){return[Re.decode(e,t),Re.decode.bytes]}function De(e,t,r=0){return Re.encode(e,t,r),t}function Me(e){return Re.encodingLength(e)}function Ne(e,t){const r=t.byteLength,n=Me(e),s=n+Me(r),i=new Uint8Array(s+r);return De(e,i,0),De(r,i,n),i.set(t,s),new Ue(e,r,t,i)}function Oe(e){const t=P(e),[r,n]=Le(t),[s,i]=Le(t.subarray(n)),o=t.subarray(n+i);if(o.byteLength!==s)throw Error("Incorrect length");return new Ue(r,s,o,t)}class Ue{code;size;digest;bytes;constructor(e,t,r,n){this.code=e,this.size=t,this.digest=r,this.bytes=n}}const Fe=P;const Be={code:0,name:"identity",encode:Fe,digest(e,t){if(null!=t?.truncate&&t.truncate!==e.byteLength){if(t.truncate<0||t.truncate>e.byteLength)throw Error("Invalid truncate option, must be less than or equal to "+e.byteLength);e=e.subarray(0,t.truncate)}return Ne(0,Fe(e))}};class qe{name;code;encode;minDigestLength;maxDigestLength;constructor(e,t,r,n,s){this.name=e,this.code=t,this.encode=r,this.minDigestLength=n??20,this.maxDigestLength=s}digest(e,t){if(null!=t?.truncate){if(t.truncate<this.minDigestLength)throw Error("Invalid truncate option, must be greater than or equal to "+this.minDigestLength);if(null!=this.maxDigestLength&&t.truncate>this.maxDigestLength)throw Error("Invalid truncate option, must be less than or equal to "+this.maxDigestLength)}if(e instanceof Uint8Array){const r=this.encode(e);return r instanceof Uint8Array?$e(r,this.code,t?.truncate):r.then(e=>$e(e,this.code,t?.truncate))}throw Error("Unknown type, must be binary type")}}function $e(e,t,r){if(null!=r&&r!==e.byteLength){if(r>e.byteLength)throw Error("Invalid truncate option, must be less than or equal to "+e.byteLength);e=e.subarray(0,r)}return Ne(t,e)}const ze=function({name:e,code:t,encode:r,minDigestLength:n,maxDigestLength:s}){return new qe(e,t,r,n,s)}({name:"sha2-256",code:18,encode:function(e){return async t=>new Uint8Array(await crypto.subtle.digest(e,t))}("SHA-256")});function Ke(e,t){const{bytes:r,version:n}=e;return 0===n?function(e,t,r){const{prefix:n}=r;if(n!==he.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const s=t.get(n);if(null==s){const s=r.encode(e).slice(1);return t.set(n,s),s}return s}(r,He(e),t??he.encoder):function(e,t,r){const{prefix:n}=r,s=t.get(n);if(null==s){const s=r.encode(e);return t.set(n,s),s}return s}(r,He(e),t??Y.encoder)}const Ve=new WeakMap;function He(e){const t=Ve.get(e);if(null==t){const t=new Map;return Ve.set(e,t),t}return t}class je{code;version;multihash;bytes;"/";constructor(e,t,r,n){this.code=t,this.version=e,this.multihash=r,this.bytes=n,this["/"]=n}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==Ge)throw Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==We)throw Error("Cannot convert non sha2-256 multihash CID to CIDv0");return je.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,r=Ne(e,t);return je.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return je.equals(this,e)}static equals(e,t){const r=t;return null!=r&&e.code===r.code&&e.version===r.version&&function(e,t){if(e===t)return!0;{const r=t;return e.code===r.code&&e.size===r.size&&r.bytes instanceof Uint8Array&&((e,t)=>{if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let r=0;r<e.byteLength;r++)if(e[r]!==t[r])return!1;return!0})(e.bytes,r.bytes)}}(e.multihash,r.multihash)}toString(e){return Ke(this,e)}toJSON(){return{"/":Ke(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(null==e)return null;const t=e;if(t instanceof je)return t;if(null!=t["/"]&&t["/"]===t.bytes||t.asCID===t){const{version:e,code:r,multihash:n,bytes:s}=t;return new je(e,r,n,s??Xe(e,r,n.bytes))}if(!0===t[Ze]){const{version:e,multihash:r,code:n}=t,s=Oe(r);return je.create(e,n,s)}return null}static create(e,t,r){if("number"!=typeof t)throw Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw Error("Invalid digest");switch(e){case 0:if(t!==Ge)throw Error(`Version 0 CID must use dag-pb (code: ${Ge}) block encoding`);return new je(e,t,r,r.bytes);case 1:{const n=Xe(e,t,r.bytes);return new je(e,t,r,n)}default:throw Error("Invalid version")}}static createV0(e){return je.create(0,Ge,e)}static createV1(e,t){return je.create(1,e,t)}static decode(e){const[t,r]=je.decodeFirst(e);if(0!==r.length)throw Error("Incorrect length");return t}static decodeFirst(e){const t=je.inspectBytes(e),r=t.size-t.multihashSize,n=P(e.subarray(r,r+t.multihashSize));if(n.byteLength!==t.multihashSize)throw Error("Incorrect length");const s=n.subarray(t.multihashSize-t.digestSize),i=new Ue(t.multihashCode,t.digestSize,s,n);return[0===t.version?je.createV0(i):je.createV1(t.codec,i),e.subarray(t.size)]}static inspectBytes(e){let t=0;const r=()=>{const[r,n]=Le(e.subarray(t));return t+=n,r};let n=r(),s=Ge;if(18===n?(n=0,t=0):s=r(),0!==n&&1!==n)throw new RangeError("Invalid CID version "+n);const i=t,o=r(),a=r(),c=t+a;return{version:n,codec:s,multihashCode:o,digestSize:a,multihashSize:c-i,size:c}}static parse(e,t){const[r,n]=function(e,t){switch(e[0]){case"Q":{const r=t??he;return[he.prefix,r.decode(`${he.prefix}${e}`)]}case he.prefix:{const r=t??he;return[he.prefix,r.decode(e)]}case Y.prefix:{const r=t??Y;return[Y.prefix,r.decode(e)]}case ce.prefix:{const r=t??ce;return[ce.prefix,r.decode(e)]}default:if(null==t)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}}(e,t),s=je.decode(n);if(0===s.version&&"Q"!==e[0])throw Error("Version 0 CID string must not include multibase prefix");return He(s).set(r,e),s}}const Ge=112,We=18;function Xe(e,t,r){const n=Me(e),s=n+Me(t),i=new Uint8Array(s+r.byteLength);return De(e,i,0),De(t,i,n),i.set(r,s),i}const Ze=Symbol.for("@ipld/js-cid/CID"),Qe={...Se,...j,...ve,...$,...V,...ae,...ue,...pe,...be,...Q};function Ye(e,t,r,n){return{name:e,prefix:t,encoder:{name:e,prefix:t,encode:r},decoder:{decode:n}}}const Je=Ye("utf8","u",e=>"u"+new TextDecoder("utf8").decode(e),e=>(new TextEncoder).encode(e.substring(1))),et=Ye("ascii","a",e=>{let t="a";for(let r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t},e=>{const r=t((e=e.substring(1)).length);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return r}),tt={utf8:Je,"utf-8":Je,hex:Qe.base16,latin1:et,ascii:et,binary:et,...Qe};function rt(e,t="utf8"){const r=tt[t];if(null==r)throw Error(`Unsupported encoding "${t}"`);return r.decoder.decode(`${r.prefix}${e}`)}class nt{fn;len;next;val;constructor(e,t,r){this.fn=e,this.len=t,this.next=void 0,this.val=r}}function st(){}class it{head;tail;len;next;constructor(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}}const ot=function(){const e=8192;let r,n=e;return function(s){if(s<1||s>4096)return t(s);n+s>e&&(r=t(e),n=0);const i=r.subarray(n,n+=s);return 7&n&&(n=1+(7|n)),i}}();class at{len;head;tail;states;constructor(){this.len=0,this.head=new nt(st,0,0),this.tail=this.head,this.states=null}_push(e,t,r){return this.tail=this.tail.next=new nt(e,t,r),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new ut((e>>>=0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(ht,10,E.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){const t=E.fromBigInt(e);return this._push(ht,t.length(),t)}uint64Number(e){return this._push(l,c(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){const t=E.fromBigInt(e).zzEncode();return this._push(ht,t.length(),t)}sint64Number(e){const t=E.fromNumber(e).zzEncode();return this._push(ht,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push(ct,1,e?1:0)}fixed32(e){return this._push(dt,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){const t=E.fromBigInt(e);return this._push(dt,4,t.lo)._push(dt,4,t.hi)}fixed64Number(e){const t=E.fromNumber(e);return this._push(dt,4,t.lo)._push(dt,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(g,4,e)}double(e){return this._push(b,8,e)}bytes(e){const t=e.length>>>0;return 0===t?this._push(ct,1,0):this.uint32(t)._push(pt,t,e)}string(e){const t=function(e){let t=0,r=0;for(let n=0;n<e.length;++n)r=e.charCodeAt(n),r<128?t+=1:r<2048?t+=2:55296==(64512&r)&&56320==(64512&e.charCodeAt(n+1))?(++n,t+=4):t+=3;return t}(e);return 0!==t?this.uint32(t)._push(I,t,e):this._push(ct,1,0)}fork(){return this.states=new it(this),this.head=this.tail=new nt(st,0,0),this.len=0,this}reset(){return null!=this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new nt(st,0,0),this.len=0),this}ldelim(){const e=this.head,t=this.tail,r=this.len;return this.reset().uint32(r),0!==r&&(this.tail.next=e.next,this.tail=t,this.len+=r),this}finish(){let e=this.head.next;const r=(n=this.len,null!=globalThis.Buffer?t(n):ot(n));var n;let s=0;for(;null!=e;)e.fn(e.val,r,s),s+=e.len,e=e.next;return r}}function ct(e,t,r){t[r]=255&e}function lt(e,t,r){for(;e>127;)t[r++]=127&e|128,e>>>=7;t[r]=e}class ut extends nt{next;constructor(e,t){super(lt,e,t),this.next=void 0}}function ht(e,t,r){for(;0!==e.hi;)t[r++]=127&e.lo|128,e.lo=(e.lo>>>7|e.hi<<25)>>>0,e.hi>>>=7;for(;e.lo>127;)t[r++]=127&e.lo|128,e.lo=e.lo>>>7;t[r++]=e.lo}function dt(e,t,r){t[r]=255&e,t[r+1]=e>>>8&255,t[r+2]=e>>>16&255,t[r+3]=e>>>24}function pt(e,t,r){t.set(e,r)}function ft(e,t,r){t.set(e,r)}function gt(e,t,r){e.length<40?I(e,t,r):null!=t.utf8Write?t.utf8Write(e,r):t.set(rt(e),r)}function mt(e,t){const r=new at;return t.encode(e,r,{lengthDelimited:!1}),r.finish()}var yt,bt,wt,vt,Et,St,At,It,Ct,xt,kt,Tt,Pt,_t,Rt,Lt,Dt,Mt,Nt,Ot,Ut,Ft,Bt,qt,$t,zt,Kt,Vt,Ht,jt,Gt,Wt,Xt,Zt;function Qt(e,t,r,n){return{name:e,type:t,encode:r,decode:n}}function Yt(e){function t(t){if(null==e[t.toString()])throw Error("Invalid enum value");return e[t]}return Qt("enum",yt.VARINT,function(e,r){const n=t(e);r.int32(n)},function(e){return t(e.int32())})}function Jt(e,t){return Qt("message",yt.LENGTH_DELIMITED,e,t)}null!=globalThis.Buffer&&(at.prototype.bytes=function(e){const t=e.length>>>0;return this.uint32(t),t>0&&this._push(ft,t,e),this},at.prototype.string=function(e){const t=globalThis.Buffer.byteLength(e);return this.uint32(t),t>0&&this._push(gt,t,e),this}),(e=>{e[e.VARINT=0]="VARINT",e[e.BIT64=1]="BIT64",e[e.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",e[e.START_GROUP=3]="START_GROUP",e[e.END_GROUP=4]="END_GROUP",e[e.BIT32=5]="BIT32"})(yt||(yt={}));class er extends Error{code="ERR_MAX_LENGTH";name="MaxLengthError"}class tr extends Error{code="ERR_MAX_SIZE";name="MaxSizeError"}function rr(e){return!!e}(t=>{let r;t.codec=()=>(null==r&&(r=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.proof&&e.proof.byteLength>0&&(t.uint32(10),t.bytes(e.proof)),null!=e.merkleRoot&&e.merkleRoot.byteLength>0&&(t.uint32(18),t.bytes(e.merkleRoot)),null!=e.epoch&&e.epoch.byteLength>0&&(t.uint32(26),t.bytes(e.epoch)),null!=e.shareX&&e.shareX.byteLength>0&&(t.uint32(34),t.bytes(e.shareX)),null!=e.shareY&&e.shareY.byteLength>0&&(t.uint32(42),t.bytes(e.shareY)),null!=e.nullifier&&e.nullifier.byteLength>0&&(t.uint32(50),t.bytes(e.nullifier)),null!=e.rlnIdentifier&&e.rlnIdentifier.byteLength>0&&(t.uint32(58),t.bytes(e.rlnIdentifier)),!1!==r.lengthDelimited&&t.ldelim()},(t,r)=>{const n={proof:e(0),merkleRoot:e(0),epoch:e(0),shareX:e(0),shareY:e(0),nullifier:e(0),rlnIdentifier:e(0)},s=null==r?t.len:t.pos+r;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:n.proof=t.bytes();break;case 2:n.merkleRoot=t.bytes();break;case 3:n.epoch=t.bytes();break;case 4:n.shareX=t.bytes();break;case 5:n.shareY=t.bytes();break;case 6:n.nullifier=t.bytes();break;case 7:n.rlnIdentifier=t.bytes();break;default:t.skipType(7&e)}}return n})),r),t.encode=e=>mt(e,t.codec()),t.decode=(e,r)=>T(e,t.codec(),r)})(bt||(bt={})),(t=>{let r;t.codec=()=>(null==r&&(r=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.payload&&e.payload.byteLength>0&&(t.uint32(10),t.bytes(e.payload)),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(18),t.string(e.contentTopic)),null!=e.version&&(t.uint32(24),t.uint32(e.version)),null!=e.timestamp&&(t.uint32(80),t.sint64(e.timestamp)),null!=e.meta&&(t.uint32(90),t.bytes(e.meta)),null!=e.rateLimitProof&&(t.uint32(170),bt.codec().encode(e.rateLimitProof,t)),null!=e.ephemeral&&(t.uint32(248),t.bool(e.ephemeral)),!1!==r.lengthDelimited&&t.ldelim()},(t,r,n={})=>{const s={payload:e(0),contentTopic:""},i=null==r?t.len:t.pos+r;for(;t.pos<i;){const e=t.uint32();switch(e>>>3){case 1:s.payload=t.bytes();break;case 2:s.contentTopic=t.string();break;case 3:s.version=t.uint32();break;case 10:s.timestamp=t.sint64();break;case 11:s.meta=t.bytes();break;case 21:s.rateLimitProof=bt.codec().decode(t,t.uint32(),{limits:n.limits?.rateLimitProof});break;case 31:s.ephemeral=t.bool();break;default:t.skipType(7&e)}}return s})),r),t.encode=e=>mt(e,t.codec()),t.decode=(e,r)=>T(e,t.codec(),r)})(wt||(wt={})),(e=>{let t;(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(10),t.string(e.contentTopic)),!1!==r.lengthDelimited&&t.ldelim()},(e,t)=>{const r={contentTopic:""},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();if(t>>>3==1)r.contentTopic=e.string();else e.skipType(7&t)}return r})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(e.ContentFilter||(e.ContentFilter={})),e.codec=()=>(null==t&&(t=Jt((t,r,n={})=>{if(!1!==n.lengthDelimited&&r.fork(),null!=t.subscribe&&!1!==t.subscribe&&(r.uint32(8),r.bool(t.subscribe)),null!=t.topic&&""!==t.topic&&(r.uint32(18),r.string(t.topic)),null!=t.contentFilters)for(const n of t.contentFilters)r.uint32(26),e.ContentFilter.codec().encode(n,r);!1!==n.lengthDelimited&&r.ldelim()},(t,r,n={})=>{const s={subscribe:!1,topic:"",contentFilters:[]},i=null==r?t.len:t.pos+r;for(;t.pos<i;){const r=t.uint32();switch(r>>>3){case 1:s.subscribe=t.bool();break;case 2:s.topic=t.string();break;case 3:if(null!=n.limits?.contentFilters&&s.contentFilters.length===n.limits.contentFilters)throw new er('Decode error - map field "contentFilters" had too many elements');s.contentFilters.push(e.ContentFilter.codec().decode(t,t.uint32(),{limits:n.limits?.contentFilters$}));break;default:t.skipType(7&r)}}return s})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(vt||(vt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.messages)for(const r of e.messages)t.uint32(10),It.codec().encode(r,t);!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{const n={messages:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();if(t>>>3==1){if(null!=r.limits?.messages&&n.messages.length===r.limits.messages)throw new er('Decode error - map field "messages" had too many elements');n.messages.push(It.codec().decode(e,e.uint32(),{limits:r.limits?.messages$}))}else e.skipType(7&t)}return n})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(Et||(Et={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.requestId&&""!==e.requestId&&(t.uint32(10),t.string(e.requestId)),null!=e.request&&(t.uint32(18),vt.codec().encode(e.request,t)),null!=e.push&&(t.uint32(26),Et.codec().encode(e.push,t)),!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{const n={requestId:""},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.requestId=e.string();break;case 2:n.request=vt.codec().decode(e,e.uint32(),{limits:r.limits?.request});break;case 3:n.push=Et.codec().decode(e,e.uint32(),{limits:r.limits?.push});break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(St||(St={})),(t=>{let r;t.codec=()=>(null==r&&(r=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.proof&&e.proof.byteLength>0&&(t.uint32(10),t.bytes(e.proof)),null!=e.merkleRoot&&e.merkleRoot.byteLength>0&&(t.uint32(18),t.bytes(e.merkleRoot)),null!=e.epoch&&e.epoch.byteLength>0&&(t.uint32(26),t.bytes(e.epoch)),null!=e.shareX&&e.shareX.byteLength>0&&(t.uint32(34),t.bytes(e.shareX)),null!=e.shareY&&e.shareY.byteLength>0&&(t.uint32(42),t.bytes(e.shareY)),null!=e.nullifier&&e.nullifier.byteLength>0&&(t.uint32(50),t.bytes(e.nullifier)),null!=e.rlnIdentifier&&e.rlnIdentifier.byteLength>0&&(t.uint32(58),t.bytes(e.rlnIdentifier)),!1!==r.lengthDelimited&&t.ldelim()},(t,r)=>{const n={proof:e(0),merkleRoot:e(0),epoch:e(0),shareX:e(0),shareY:e(0),nullifier:e(0),rlnIdentifier:e(0)},s=null==r?t.len:t.pos+r;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:n.proof=t.bytes();break;case 2:n.merkleRoot=t.bytes();break;case 3:n.epoch=t.bytes();break;case 4:n.shareX=t.bytes();break;case 5:n.shareY=t.bytes();break;case 6:n.nullifier=t.bytes();break;case 7:n.rlnIdentifier=t.bytes();break;default:t.skipType(7&e)}}return n})),r),t.encode=e=>mt(e,t.codec()),t.decode=(e,r)=>T(e,t.codec(),r)})(At||(At={})),(t=>{let r;t.codec=()=>(null==r&&(r=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.payload&&e.payload.byteLength>0&&(t.uint32(10),t.bytes(e.payload)),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(18),t.string(e.contentTopic)),null!=e.version&&(t.uint32(24),t.uint32(e.version)),null!=e.timestamp&&(t.uint32(80),t.sint64(e.timestamp)),null!=e.meta&&(t.uint32(90),t.bytes(e.meta)),null!=e.rateLimitProof&&(t.uint32(170),At.codec().encode(e.rateLimitProof,t)),null!=e.ephemeral&&(t.uint32(248),t.bool(e.ephemeral)),!1!==r.lengthDelimited&&t.ldelim()},(t,r,n={})=>{const s={payload:e(0),contentTopic:""},i=null==r?t.len:t.pos+r;for(;t.pos<i;){const e=t.uint32();switch(e>>>3){case 1:s.payload=t.bytes();break;case 2:s.contentTopic=t.string();break;case 3:s.version=t.uint32();break;case 10:s.timestamp=t.sint64();break;case 11:s.meta=t.bytes();break;case 21:s.rateLimitProof=At.codec().decode(t,t.uint32(),{limits:n.limits?.rateLimitProof});break;case 31:s.ephemeral=t.bool();break;default:t.skipType(7&e)}}return s})),r),t.encode=e=>mt(e,t.codec()),t.decode=(e,r)=>T(e,t.codec(),r)})(It||(It={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(18),t.string(e.contentTopic)),!1!==r.lengthDelimited&&t.ldelim()},(e,t)=>{const r={contentTopic:""},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();if(t>>>3==2)r.contentTopic=e.string();else e.skipType(7&t)}return r})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(Ct||(Ct={})),(e=>{let t,r,n;(e=>{e.SUBSCRIBER_PING="SUBSCRIBER_PING",e.SUBSCRIBE="SUBSCRIBE",e.UNSUBSCRIBE="UNSUBSCRIBE",e.UNSUBSCRIBE_ALL="UNSUBSCRIBE_ALL"})(t=e.FilterSubscribeType||(e.FilterSubscribeType={})),(e=>{e[e.SUBSCRIBER_PING=0]="SUBSCRIBER_PING",e[e.SUBSCRIBE=1]="SUBSCRIBE",e[e.UNSUBSCRIBE=2]="UNSUBSCRIBE",e[e.UNSUBSCRIBE_ALL=3]="UNSUBSCRIBE_ALL"})(r||(r={})),(e=>{e.codec=()=>Yt(r)})(t=e.FilterSubscribeType||(e.FilterSubscribeType={})),e.codec=()=>(null==n&&(n=Jt((t,n,s={})=>{if(!1!==s.lengthDelimited&&n.fork(),null!=t.requestId&&""!==t.requestId&&(n.uint32(10),n.string(t.requestId)),null!=t.filterSubscribeType&&0!==r[t.filterSubscribeType]&&(n.uint32(16),e.FilterSubscribeType.codec().encode(t.filterSubscribeType,n)),null!=t.pubsubTopic&&(n.uint32(82),n.string(t.pubsubTopic)),null!=t.contentTopics)for(const e of t.contentTopics)n.uint32(90),n.string(e);!1!==s.lengthDelimited&&n.ldelim()},(r,n,s={})=>{const i={requestId:"",filterSubscribeType:t.SUBSCRIBER_PING,contentTopics:[]},o=null==n?r.len:r.pos+n;for(;r.pos<o;){const t=r.uint32();switch(t>>>3){case 1:i.requestId=r.string();break;case 2:i.filterSubscribeType=e.FilterSubscribeType.codec().decode(r);break;case 10:i.pubsubTopic=r.string();break;case 11:if(null!=s.limits?.contentTopics&&i.contentTopics.length===s.limits.contentTopics)throw new er('Decode error - map field "contentTopics" had too many elements');i.contentTopics.push(r.string());break;default:r.skipType(7&t)}}return i})),n),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(xt||(xt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.requestId&&""!==e.requestId&&(t.uint32(10),t.string(e.requestId)),null!=e.statusCode&&0!==e.statusCode&&(t.uint32(80),t.uint32(e.statusCode)),null!=e.statusDesc&&(t.uint32(90),t.string(e.statusDesc)),!1!==r.lengthDelimited&&t.ldelim()},(e,t)=>{const r={requestId:"",statusCode:0},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();switch(t>>>3){case 1:r.requestId=e.string();break;case 10:r.statusCode=e.uint32();break;case 11:r.statusDesc=e.string();break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(kt||(kt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.wakuMessage&&(t.uint32(10),_t.codec().encode(e.wakuMessage,t)),null!=e.pubsubTopic&&(t.uint32(18),t.string(e.pubsubTopic)),!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{const n={},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.wakuMessage=_t.codec().decode(e,e.uint32(),{limits:r.limits?.wakuMessage});break;case 2:n.pubsubTopic=e.string();break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(Tt||(Tt={})),(t=>{let r;t.codec=()=>(null==r&&(r=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.proof&&e.proof.byteLength>0&&(t.uint32(10),t.bytes(e.proof)),null!=e.merkleRoot&&e.merkleRoot.byteLength>0&&(t.uint32(18),t.bytes(e.merkleRoot)),null!=e.epoch&&e.epoch.byteLength>0&&(t.uint32(26),t.bytes(e.epoch)),null!=e.shareX&&e.shareX.byteLength>0&&(t.uint32(34),t.bytes(e.shareX)),null!=e.shareY&&e.shareY.byteLength>0&&(t.uint32(42),t.bytes(e.shareY)),null!=e.nullifier&&e.nullifier.byteLength>0&&(t.uint32(50),t.bytes(e.nullifier)),null!=e.rlnIdentifier&&e.rlnIdentifier.byteLength>0&&(t.uint32(58),t.bytes(e.rlnIdentifier)),!1!==r.lengthDelimited&&t.ldelim()},(t,r)=>{const n={proof:e(0),merkleRoot:e(0),epoch:e(0),shareX:e(0),shareY:e(0),nullifier:e(0),rlnIdentifier:e(0)},s=null==r?t.len:t.pos+r;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:n.proof=t.bytes();break;case 2:n.merkleRoot=t.bytes();break;case 3:n.epoch=t.bytes();break;case 4:n.shareX=t.bytes();break;case 5:n.shareY=t.bytes();break;case 6:n.nullifier=t.bytes();break;case 7:n.rlnIdentifier=t.bytes();break;default:t.skipType(7&e)}}return n})),r),t.encode=e=>mt(e,t.codec()),t.decode=(e,r)=>T(e,t.codec(),r)})(Pt||(Pt={})),(t=>{let r;t.codec=()=>(null==r&&(r=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.payload&&e.payload.byteLength>0&&(t.uint32(10),t.bytes(e.payload)),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(18),t.string(e.contentTopic)),null!=e.version&&(t.uint32(24),t.uint32(e.version)),null!=e.timestamp&&(t.uint32(80),t.sint64(e.timestamp)),null!=e.meta&&(t.uint32(90),t.bytes(e.meta)),null!=e.rateLimitProof&&(t.uint32(170),Pt.codec().encode(e.rateLimitProof,t)),null!=e.ephemeral&&(t.uint32(248),t.bool(e.ephemeral)),!1!==r.lengthDelimited&&t.ldelim()},(t,r,n={})=>{const s={payload:e(0),contentTopic:""},i=null==r?t.len:t.pos+r;for(;t.pos<i;){const e=t.uint32();switch(e>>>3){case 1:s.payload=t.bytes();break;case 2:s.contentTopic=t.string();break;case 3:s.version=t.uint32();break;case 10:s.timestamp=t.sint64();break;case 11:s.meta=t.bytes();break;case 21:s.rateLimitProof=Pt.codec().decode(t,t.uint32(),{limits:n.limits?.rateLimitProof});break;case 31:s.ephemeral=t.bool();break;default:t.skipType(7&e)}}return s})),r),t.encode=e=>mt(e,t.codec()),t.decode=(e,r)=>T(e,t.codec(),r)})(_t||(_t={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.pubsubTopic&&""!==e.pubsubTopic&&(t.uint32(10),t.string(e.pubsubTopic)),null!=e.message&&(t.uint32(18),Ut.codec().encode(e.message,t)),!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{const n={pubsubTopic:""},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.pubsubTopic=e.string();break;case 2:n.message=Ut.codec().decode(e,e.uint32(),{limits:r.limits?.message});break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(Rt||(Rt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.isSuccess&&!1!==e.isSuccess&&(t.uint32(8),t.bool(e.isSuccess)),null!=e.info&&(t.uint32(18),t.string(e.info)),null!=e.statusCode&&(t.uint32(80),t.uint32(e.statusCode)),null!=e.statusDesc&&(t.uint32(90),t.string(e.statusDesc)),null!=e.relayPeerCount&&(t.uint32(96),t.uint32(e.relayPeerCount)),!1!==r.lengthDelimited&&t.ldelim()},(e,t)=>{const r={isSuccess:!1},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();switch(t>>>3){case 1:r.isSuccess=e.bool();break;case 2:r.info=e.string();break;case 10:r.statusCode=e.uint32();break;case 11:r.statusDesc=e.string();break;case 12:r.relayPeerCount=e.uint32();break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(Lt||(Lt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.requestId&&""!==e.requestId&&(t.uint32(10),t.string(e.requestId)),null!=e.request&&(t.uint32(18),Rt.codec().encode(e.request,t)),null!=e.response&&(t.uint32(26),Lt.codec().encode(e.response,t)),!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{const n={requestId:""},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.requestId=e.string();break;case 2:n.request=Rt.codec().decode(e,e.uint32(),{limits:r.limits?.request});break;case 3:n.response=Lt.codec().decode(e,e.uint32(),{limits:r.limits?.response});break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(Dt||(Dt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.requestId&&""!==e.requestId&&(t.uint32(10),t.string(e.requestId)),null!=e.pubsubTopic&&(t.uint32(162),t.string(e.pubsubTopic)),null!=e.message&&(t.uint32(170),Ut.codec().encode(e.message,t)),!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{const n={requestId:""},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.requestId=e.string();break;case 20:n.pubsubTopic=e.string();break;case 21:n.message=Ut.codec().decode(e,e.uint32(),{limits:r.limits?.message});break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(Mt||(Mt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.requestId&&""!==e.requestId&&(t.uint32(10),t.string(e.requestId)),null!=e.statusCode&&0!==e.statusCode&&(t.uint32(80),t.uint32(e.statusCode)),null!=e.statusDesc&&(t.uint32(90),t.string(e.statusDesc)),null!=e.relayPeerCount&&(t.uint32(96),t.uint32(e.relayPeerCount)),!1!==r.lengthDelimited&&t.ldelim()},(e,t)=>{const r={requestId:"",statusCode:0},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();switch(t>>>3){case 1:r.requestId=e.string();break;case 10:r.statusCode=e.uint32();break;case 11:r.statusDesc=e.string();break;case 12:r.relayPeerCount=e.uint32();break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(Nt||(Nt={})),(t=>{let r;t.codec=()=>(null==r&&(r=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.proof&&e.proof.byteLength>0&&(t.uint32(10),t.bytes(e.proof)),null!=e.merkleRoot&&e.merkleRoot.byteLength>0&&(t.uint32(18),t.bytes(e.merkleRoot)),null!=e.epoch&&e.epoch.byteLength>0&&(t.uint32(26),t.bytes(e.epoch)),null!=e.shareX&&e.shareX.byteLength>0&&(t.uint32(34),t.bytes(e.shareX)),null!=e.shareY&&e.shareY.byteLength>0&&(t.uint32(42),t.bytes(e.shareY)),null!=e.nullifier&&e.nullifier.byteLength>0&&(t.uint32(50),t.bytes(e.nullifier)),null!=e.rlnIdentifier&&e.rlnIdentifier.byteLength>0&&(t.uint32(58),t.bytes(e.rlnIdentifier)),!1!==r.lengthDelimited&&t.ldelim()},(t,r)=>{const n={proof:e(0),merkleRoot:e(0),epoch:e(0),shareX:e(0),shareY:e(0),nullifier:e(0),rlnIdentifier:e(0)},s=null==r?t.len:t.pos+r;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:n.proof=t.bytes();break;case 2:n.merkleRoot=t.bytes();break;case 3:n.epoch=t.bytes();break;case 4:n.shareX=t.bytes();break;case 5:n.shareY=t.bytes();break;case 6:n.nullifier=t.bytes();break;case 7:n.rlnIdentifier=t.bytes();break;default:t.skipType(7&e)}}return n})),r),t.encode=e=>mt(e,t.codec()),t.decode=(e,r)=>T(e,t.codec(),r)})(Ot||(Ot={})),(t=>{let r;t.codec=()=>(null==r&&(r=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.payload&&e.payload.byteLength>0&&(t.uint32(10),t.bytes(e.payload)),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(18),t.string(e.contentTopic)),null!=e.version&&(t.uint32(24),t.uint32(e.version)),null!=e.timestamp&&(t.uint32(80),t.sint64(e.timestamp)),null!=e.meta&&(t.uint32(90),t.bytes(e.meta)),null!=e.rateLimitProof&&(t.uint32(170),Ot.codec().encode(e.rateLimitProof,t)),null!=e.ephemeral&&(t.uint32(248),t.bool(e.ephemeral)),!1!==r.lengthDelimited&&t.ldelim()},(t,r,n={})=>{const s={payload:e(0),contentTopic:""},i=null==r?t.len:t.pos+r;for(;t.pos<i;){const e=t.uint32();switch(e>>>3){case 1:s.payload=t.bytes();break;case 2:s.contentTopic=t.string();break;case 3:s.version=t.uint32();break;case 10:s.timestamp=t.sint64();break;case 11:s.meta=t.bytes();break;case 21:s.rateLimitProof=Ot.codec().decode(t,t.uint32(),{limits:n.limits?.rateLimitProof});break;case 31:s.ephemeral=t.bool();break;default:t.skipType(7&e)}}return s})),r),t.encode=e=>mt(e,t.codec()),t.decode=(e,r)=>T(e,t.codec(),r)})(Ut||(Ut={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.messageHash&&(t.uint32(10),t.bytes(e.messageHash)),null!=e.message&&(t.uint32(18),zt.codec().encode(e.message,t)),null!=e.pubsubTopic&&(t.uint32(26),t.string(e.pubsubTopic)),!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{const n={},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.messageHash=e.bytes();break;case 2:n.message=zt.codec().decode(e,e.uint32(),{limits:r.limits?.message});break;case 3:n.pubsubTopic=e.string();break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(Ft||(Ft={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.requestId&&""!==e.requestId&&(t.uint32(10),t.string(e.requestId)),null!=e.includeData&&!1!==e.includeData&&(t.uint32(16),t.bool(e.includeData)),null!=e.pubsubTopic&&(t.uint32(82),t.string(e.pubsubTopic)),null!=e.contentTopics)for(const r of e.contentTopics)t.uint32(90),t.string(r);if(null!=e.timeStart&&(t.uint32(96),t.sint64(e.timeStart)),null!=e.timeEnd&&(t.uint32(104),t.sint64(e.timeEnd)),null!=e.messageHashes)for(const r of e.messageHashes)t.uint32(162),t.bytes(r);null!=e.paginationCursor&&(t.uint32(410),t.bytes(e.paginationCursor)),null!=e.paginationForward&&!1!==e.paginationForward&&(t.uint32(416),t.bool(e.paginationForward)),null!=e.paginationLimit&&(t.uint32(424),t.uint64(e.paginationLimit)),!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{const n={requestId:"",includeData:!1,contentTopics:[],messageHashes:[],paginationForward:!1},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.requestId=e.string();break;case 2:n.includeData=e.bool();break;case 10:n.pubsubTopic=e.string();break;case 11:if(null!=r.limits?.contentTopics&&n.contentTopics.length===r.limits.contentTopics)throw new er('Decode error - map field "contentTopics" had too many elements');n.contentTopics.push(e.string());break;case 12:n.timeStart=e.sint64();break;case 13:n.timeEnd=e.sint64();break;case 20:if(null!=r.limits?.messageHashes&&n.messageHashes.length===r.limits.messageHashes)throw new er('Decode error - map field "messageHashes" had too many elements');n.messageHashes.push(e.bytes());break;case 51:n.paginationCursor=e.bytes();break;case 52:n.paginationForward=e.bool();break;case 53:n.paginationLimit=e.uint64();break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(Bt||(Bt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.requestId&&""!==e.requestId&&(t.uint32(10),t.string(e.requestId)),null!=e.statusCode&&(t.uint32(80),t.uint32(e.statusCode)),null!=e.statusDesc&&(t.uint32(90),t.string(e.statusDesc)),null!=e.messages)for(const r of e.messages)t.uint32(162),Ft.codec().encode(r,t);null!=e.paginationCursor&&(t.uint32(410),t.bytes(e.paginationCursor)),!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{const n={requestId:"",messages:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.requestId=e.string();break;case 10:n.statusCode=e.uint32();break;case 11:n.statusDesc=e.string();break;case 20:if(null!=r.limits?.messages&&n.messages.length===r.limits.messages)throw new er('Decode error - map field "messages" had too many elements');n.messages.push(Ft.codec().decode(e,e.uint32(),{limits:r.limits?.messages$}));break;case 51:n.paginationCursor=e.bytes();break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(qt||(qt={})),(t=>{let r;t.codec=()=>(null==r&&(r=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.proof&&e.proof.byteLength>0&&(t.uint32(10),t.bytes(e.proof)),null!=e.merkleRoot&&e.merkleRoot.byteLength>0&&(t.uint32(18),t.bytes(e.merkleRoot)),null!=e.epoch&&e.epoch.byteLength>0&&(t.uint32(26),t.bytes(e.epoch)),null!=e.shareX&&e.shareX.byteLength>0&&(t.uint32(34),t.bytes(e.shareX)),null!=e.shareY&&e.shareY.byteLength>0&&(t.uint32(42),t.bytes(e.shareY)),null!=e.nullifier&&e.nullifier.byteLength>0&&(t.uint32(50),t.bytes(e.nullifier)),null!=e.rlnIdentifier&&e.rlnIdentifier.byteLength>0&&(t.uint32(58),t.bytes(e.rlnIdentifier)),!1!==r.lengthDelimited&&t.ldelim()},(t,r)=>{const n={proof:e(0),merkleRoot:e(0),epoch:e(0),shareX:e(0),shareY:e(0),nullifier:e(0),rlnIdentifier:e(0)},s=null==r?t.len:t.pos+r;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:n.proof=t.bytes();break;case 2:n.merkleRoot=t.bytes();break;case 3:n.epoch=t.bytes();break;case 4:n.shareX=t.bytes();break;case 5:n.shareY=t.bytes();break;case 6:n.nullifier=t.bytes();break;case 7:n.rlnIdentifier=t.bytes();break;default:t.skipType(7&e)}}return n})),r),t.encode=e=>mt(e,t.codec()),t.decode=(e,r)=>T(e,t.codec(),r)})($t||($t={})),(t=>{let r;t.codec=()=>(null==r&&(r=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.payload&&e.payload.byteLength>0&&(t.uint32(10),t.bytes(e.payload)),null!=e.contentTopic&&""!==e.contentTopic&&(t.uint32(18),t.string(e.contentTopic)),null!=e.version&&(t.uint32(24),t.uint32(e.version)),null!=e.timestamp&&(t.uint32(80),t.sint64(e.timestamp)),null!=e.meta&&(t.uint32(90),t.bytes(e.meta)),null!=e.rateLimitProof&&(t.uint32(170),$t.codec().encode(e.rateLimitProof,t)),null!=e.ephemeral&&(t.uint32(248),t.bool(e.ephemeral)),!1!==r.lengthDelimited&&t.ldelim()},(t,r,n={})=>{const s={payload:e(0),contentTopic:""},i=null==r?t.len:t.pos+r;for(;t.pos<i;){const e=t.uint32();switch(e>>>3){case 1:s.payload=t.bytes();break;case 2:s.contentTopic=t.string();break;case 3:s.version=t.uint32();break;case 10:s.timestamp=t.sint64();break;case 11:s.meta=t.bytes();break;case 21:s.rateLimitProof=$t.codec().decode(t,t.uint32(),{limits:n.limits?.rateLimitProof});break;case 31:s.ephemeral=t.bool();break;default:t.skipType(7&e)}}return s})),r),t.encode=e=>mt(e,t.codec()),t.decode=(e,r)=>T(e,t.codec(),r)})(zt||(zt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.enr&&(t.uint32(10),t.bytes(e.enr)),!1!==r.lengthDelimited&&t.ldelim()},(e,t)=>{const r={},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();if(t>>>3==1)r.enr=e.bytes();else e.skipType(7&t)}return r})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(Kt||(Kt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.numPeers&&(t.uint32(8),t.uint64(e.numPeers)),!1!==r.lengthDelimited&&t.ldelim()},(e,t)=>{const r={},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();if(t>>>3==1)r.numPeers=e.uint64();else e.skipType(7&t)}return r})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(Vt||(Vt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.peerInfos)for(const r of e.peerInfos)t.uint32(10),Kt.codec().encode(r,t);!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{const n={peerInfos:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();if(t>>>3==1){if(null!=r.limits?.peerInfos&&n.peerInfos.length===r.limits.peerInfos)throw new er('Decode error - map field "peerInfos" had too many elements');n.peerInfos.push(Kt.codec().decode(e,e.uint32(),{limits:r.limits?.peerInfos$}))}else e.skipType(7&t)}return n})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(Ht||(Ht={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.query&&(t.uint32(10),Vt.codec().encode(e.query,t)),null!=e.response&&(t.uint32(18),Ht.codec().encode(e.response,t)),!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{const n={},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.query=Vt.codec().decode(e,e.uint32(),{limits:r.limits?.query});break;case 2:n.response=Ht.codec().decode(e,e.uint32(),{limits:r.limits?.response});break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(jt||(jt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.clusterId&&(t.uint32(8),t.uint32(e.clusterId)),null!=e.shards)for(const r of e.shards)t.uint32(16),t.uint32(r);!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{const n={shards:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.clusterId=e.uint32();break;case 2:if(null!=r.limits?.shards&&n.shards.length===r.limits.shards)throw new er('Decode error - map field "shards" had too many elements');n.shards.push(e.uint32());break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(Gt||(Gt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.clusterId&&(t.uint32(8),t.uint32(e.clusterId)),null!=e.shards)for(const r of e.shards)t.uint32(16),t.uint32(r);!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{const n={shards:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.clusterId=e.uint32();break;case 2:if(null!=r.limits?.shards&&n.shards.length===r.limits.shards)throw new er('Decode error - map field "shards" had too many elements');n.shards.push(e.uint32());break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(Wt||(Wt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.messageId&&""!==e.messageId&&(t.uint32(10),t.string(e.messageId)),null!=e.retrievalHint&&(t.uint32(18),t.bytes(e.retrievalHint)),!1!==r.lengthDelimited&&t.ldelim()},(e,t)=>{const r={messageId:""},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();switch(t>>>3){case 1:r.messageId=e.string();break;case 2:r.retrievalHint=e.bytes();break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(Xt||(Xt={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.senderId&&""!==e.senderId&&(t.uint32(10),t.string(e.senderId)),null!=e.messageId&&""!==e.messageId&&(t.uint32(18),t.string(e.messageId)),null!=e.channelId&&""!==e.channelId&&(t.uint32(26),t.string(e.channelId)),null!=e.lamportTimestamp&&(t.uint32(80),t.int32(e.lamportTimestamp)),null!=e.causalHistory)for(const r of e.causalHistory)t.uint32(90),Xt.codec().encode(r,t);null!=e.bloomFilter&&(t.uint32(98),t.bytes(e.bloomFilter)),null!=e.content&&(t.uint32(162),t.bytes(e.content)),!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{const n={senderId:"",messageId:"",channelId:"",causalHistory:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.senderId=e.string();break;case 2:n.messageId=e.string();break;case 3:n.channelId=e.string();break;case 10:n.lamportTimestamp=e.int32();break;case 11:if(null!=r.limits?.causalHistory&&n.causalHistory.length===r.limits.causalHistory)throw new er('Decode error - map field "causalHistory" had too many elements');n.causalHistory.push(Xt.codec().decode(e,e.uint32(),{limits:r.limits?.causalHistory$}));break;case 12:n.bloomFilter=e.bytes();break;case 20:n.content=e.bytes();break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(Zt||(Zt={}));const nr=e=>e.length/1048576<=1,sr="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;function ir(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function or(e){if(!Number.isSafeInteger(e)||e<0)throw Error("positive integer expected, got "+e)}function ar(e,...t){if(!ir(e))throw Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw Error("Uint8Array expected of length "+t+", got length="+e.length)}function cr(e){if("function"!=typeof e||"function"!=typeof e.create)throw Error("Hash should be wrapped by utils.createHasher");or(e.outputLen),or(e.blockLen)}function lr(e,t=!0){if(e.destroyed)throw Error("Hash instance has been destroyed");if(t&&e.finished)throw Error("Hash#digest() has already been called")}function ur(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function hr(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function dr(e,t){return e<<32-t|e>>>t}const pr=(()=>"function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex)(),fr=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function gr(e){if(ar(e),pr)return e.toHex();let t="";for(let r=0;r<e.length;r++)t+=fr[e[r]];return t}const mr=48,yr=57,br=65,wr=70,vr=97,Er=102;function Sr(e){return e>=mr&&e<=yr?e-mr:e>=br&&e<=wr?e-(br-10):e>=vr&&e<=Er?e-(vr-10):void 0}function Ar(e){if("string"!=typeof e)throw Error("hex string expected, got "+typeof e);if(pr)return Uint8Array.fromHex(e);const t=e.length,r=t/2;if(t%2)throw Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(r);for(let t=0,s=0;t<r;t++,s+=2){const r=Sr(e.charCodeAt(s)),i=Sr(e.charCodeAt(s+1));if(void 0===r||void 0===i){const t=e[s]+e[s+1];throw Error('hex string expected, got non-hex character "'+t+'" at index '+s)}n[t]=16*r+i}return n}function Ir(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw Error("string expected");return new Uint8Array((new TextEncoder).encode(e))}(e)),ar(e),e}function Cr(...e){let t=0;for(let r=0;r<e.length;r++){const n=e[r];ar(n),t+=n.length}const r=new Uint8Array(t);for(let t=0,n=0;t<e.length;t++){const s=e[t];r.set(s,n),n+=s.length}return r}class xr{}function kr(e){const t=t=>e().update(Ir(t)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t}function Tr(e=32){if(sr&&"function"==typeof sr.getRandomValues)return sr.getRandomValues(new Uint8Array(e));if(sr&&"function"==typeof sr.randomBytes)return Uint8Array.from(sr.randomBytes(e));throw Error("crypto.getRandomValues must be defined")}function Pr(e,t,r){return e&t^~e&r}function _r(e,t,r){return e&t^e&r^t&r}class Rr extends xr{constructor(e,t,r,n){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=n,this.buffer=new Uint8Array(e),this.view=hr(this.buffer)}update(e){lr(this),ar(e=Ir(e));const{view:t,buffer:r,blockLen:n}=this,s=e.length;for(let i=0;i<s;){const o=Math.min(n-this.pos,s-i);if(o===n){const t=hr(e);for(;n<=s-i;i+=n)this.process(t,i);continue}r.set(e.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===n&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){lr(this),function(e,t){ar(e);const r=t.outputLen;if(e.length<r)throw Error("digestInto() expects output buffer of length at least "+r)}(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:n,isLE:s}=this;let{pos:i}=this;t[i++]=128,ur(this.buffer.subarray(i)),this.padOffset>n-i&&(this.process(r,0),i=0);for(let e=i;e<n;e++)t[e]=0;!function(e,t,r,n){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,n);const s=BigInt(32),i=BigInt(4294967295),o=Number(r>>s&i),a=Number(r&i),c=n?4:0,l=n?0:4;e.setUint32(t+c,o,n),e.setUint32(t+l,a,n)}(r,n-8,BigInt(8*this.length),s),this.process(r,0);const o=hr(e),a=this.outputLen;if(a%4)throw Error("_sha2: outputLen should be aligned to 32bit");const c=a/4,l=this.get();if(c>l.length)throw Error("_sha2: outputLen bigger than state");for(let e=0;e<c;e++)o.setUint32(4*e,l[e],s)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:n,finished:s,destroyed:i,pos:o}=this;return e.destroyed=i,e.finished=s,e.length=n,e.pos=o,n%t&&e.buffer.set(r),e}clone(){return this._cloneInto()}}const Lr=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Dr=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Mr=BigInt(2**32-1),Nr=BigInt(32);function Or(e,t=!1){return t?{h:Number(e&Mr),l:Number(e>>Nr&Mr)}:{h:0|Number(e>>Nr&Mr),l:0|Number(e&Mr)}}const Ur=(e,t,r)=>e>>>r,Fr=(e,t,r)=>e<<32-r|t>>>r,Br=(e,t,r)=>e>>>r|t<<32-r,qr=(e,t,r)=>e<<32-r|t>>>r,$r=(e,t,r)=>e<<64-r|t>>>r-32,zr=(e,t,r)=>e>>>r-32|t<<64-r;function Kr(e,t,r,n){const s=(t>>>0)+(n>>>0);return{h:e+r+(s/2**32|0)|0,l:0|s}}const Vr=(e,t,r)=>(e>>>0)+(t>>>0)+(r>>>0),Hr=(e,t,r,n)=>t+r+n+(e/2**32|0)|0,jr=(e,t,r,n)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0),Gr=(e,t,r,n,s)=>t+r+n+s+(e/2**32|0)|0,Wr=(e,t,r,n,s)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0)+(s>>>0),Xr=(e,t,r,n,s,i)=>t+r+n+s+i+(e/2**32|0)|0,Zr=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Qr=new Uint32Array(64);class Yr extends Rr{constructor(e=32){super(64,e,8,!1),this.A=0|Lr[0],this.B=0|Lr[1],this.C=0|Lr[2],this.D=0|Lr[3],this.E=0|Lr[4],this.F=0|Lr[5],this.G=0|Lr[6],this.H=0|Lr[7]}get(){const{A:e,B:t,C:r,D:n,E:s,F:i,G:o,H:a}=this;return[e,t,r,n,s,i,o,a]}set(e,t,r,n,s,i,o,a){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|n,this.E=0|s,this.F=0|i,this.G=0|o,this.H=0|a}process(e,t){for(let r=0;r<16;r++,t+=4)Qr[r]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=Qr[e-15],r=Qr[e-2],n=dr(t,7)^dr(t,18)^t>>>3,s=dr(r,17)^dr(r,19)^r>>>10;Qr[e]=s+Qr[e-7]+n+Qr[e-16]|0}let{A:r,B:n,C:s,D:i,E:o,F:a,G:c,H:l}=this;for(let e=0;e<64;e++){const t=l+(dr(o,6)^dr(o,11)^dr(o,25))+Pr(o,a,c)+Zr[e]+Qr[e]|0,u=(dr(r,2)^dr(r,13)^dr(r,22))+_r(r,n,s)|0;l=c,c=a,a=o,o=i+t|0,i=s,s=n,n=r,r=t+u|0}r=r+this.A|0,n=n+this.B|0,s=s+this.C|0,i=i+this.D|0,o=o+this.E|0,a=a+this.F|0,c=c+this.G|0,l=l+this.H|0,this.set(r,n,s,i,o,a,c,l)}roundClean(){ur(Qr)}destroy(){this.set(0,0,0,0,0,0,0,0),ur(this.buffer)}}const Jr=(()=>function(e,t=!1){const r=e.length;let n=new Uint32Array(r),s=new Uint32Array(r);for(let i=0;i<r;i++){const{h:r,l:o}=Or(e[i],t);[n[i],s[i]]=[r,o]}return[n,s]}(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))))(),en=(()=>Jr[0])(),tn=(()=>Jr[1])(),rn=new Uint32Array(80),nn=new Uint32Array(80);class sn extends Rr{constructor(e=64){super(128,e,16,!1),this.Ah=0|Dr[0],this.Al=0|Dr[1],this.Bh=0|Dr[2],this.Bl=0|Dr[3],this.Ch=0|Dr[4],this.Cl=0|Dr[5],this.Dh=0|Dr[6],this.Dl=0|Dr[7],this.Eh=0|Dr[8],this.El=0|Dr[9],this.Fh=0|Dr[10],this.Fl=0|Dr[11],this.Gh=0|Dr[12],this.Gl=0|Dr[13],this.Hh=0|Dr[14],this.Hl=0|Dr[15]}get(){const{Ah:e,Al:t,Bh:r,Bl:n,Ch:s,Cl:i,Dh:o,Dl:a,Eh:c,El:l,Fh:u,Fl:h,Gh:d,Gl:p,Hh:f,Hl:g}=this;return[e,t,r,n,s,i,o,a,c,l,u,h,d,p,f,g]}set(e,t,r,n,s,i,o,a,c,l,u,h,d,p,f,g){this.Ah=0|e,this.Al=0|t,this.Bh=0|r,this.Bl=0|n,this.Ch=0|s,this.Cl=0|i,this.Dh=0|o,this.Dl=0|a,this.Eh=0|c,this.El=0|l,this.Fh=0|u,this.Fl=0|h,this.Gh=0|d,this.Gl=0|p,this.Hh=0|f,this.Hl=0|g}process(e,t){for(let r=0;r<16;r++,t+=4)rn[r]=e.getUint32(t),nn[r]=e.getUint32(t+=4);for(let e=16;e<80;e++){const t=0|rn[e-15],r=0|nn[e-15],n=Br(t,r,1)^Br(t,r,8)^Ur(t,0,7),s=qr(t,r,1)^qr(t,r,8)^Fr(t,r,7),i=0|rn[e-2],o=0|nn[e-2],a=Br(i,o,19)^$r(i,o,61)^Ur(i,0,6),c=qr(i,o,19)^zr(i,o,61)^Fr(i,o,6),l=jr(s,c,nn[e-7],nn[e-16]),u=Gr(l,n,a,rn[e-7],rn[e-16]);rn[e]=0|u,nn[e]=0|l}let{Ah:r,Al:n,Bh:s,Bl:i,Ch:o,Cl:a,Dh:c,Dl:l,Eh:u,El:h,Fh:d,Fl:p,Gh:f,Gl:g,Hh:m,Hl:y}=this;for(let e=0;e<80;e++){const t=Br(u,h,14)^Br(u,h,18)^$r(u,h,41),b=qr(u,h,14)^qr(u,h,18)^zr(u,h,41),w=u&d^~u&f,v=Wr(y,b,h&p^~h&g,tn[e],nn[e]),E=Xr(v,m,t,w,en[e],rn[e]),S=0|v,A=Br(r,n,28)^$r(r,n,34)^$r(r,n,39),I=qr(r,n,28)^zr(r,n,34)^zr(r,n,39),C=r&s^r&o^s&o,x=n&i^n&a^i&a;m=0|f,y=0|g,f=0|d,g=0|p,d=0|u,p=0|h,({h:u,l:h}=Kr(0|c,0|l,0|E,0|S)),c=0|o,l=0|a,o=0|s,a=0|i,s=0|r,i=0|n;const k=Vr(S,I,x);r=Hr(k,E,A,C),n=0|k}({h:r,l:n}=Kr(0|this.Ah,0|this.Al,0|r,0|n)),({h:s,l:i}=Kr(0|this.Bh,0|this.Bl,0|s,0|i)),({h:o,l:a}=Kr(0|this.Ch,0|this.Cl,0|o,0|a)),({h:c,l}=Kr(0|this.Dh,0|this.Dl,0|c,0|l)),({h:u,l:h}=Kr(0|this.Eh,0|this.El,0|u,0|h)),({h:d,l:p}=Kr(0|this.Fh,0|this.Fl,0|d,0|p)),({h:f,l:g}=Kr(0|this.Gh,0|this.Gl,0|f,0|g)),({h:m,l:y}=Kr(0|this.Hh,0|this.Hl,0|m,0|y)),this.set(r,n,s,i,o,a,c,l,u,h,d,p,f,g,m,y)}roundClean(){ur(rn,nn)}destroy(){ur(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const on=kr(()=>new Yr),an=kr(()=>new sn),cn=on;function ln(e,t="utf8"){const r=tt[t];if(null==r)throw Error(`Unsupported encoding "${t}"`);return r.encoder.encode(e).substring(1)}function un(e){if("string"==typeof e){return rt(e.replace(/^0x/i,"").toLowerCase(),"base16")}return e}const hn=e=>ln(e,"base16"),dn=e=>ln(e,"utf8"),pn=e=>rt(e,"utf8");function fn(e){const t=e.reduce((e,t)=>e+t.length,0),r=new Uint8Array(t);let n=0;for(const t of e)r.set(t,n),n+=t.length;return r}class gn{networkConfig;pubsubTopic;shardId;constructor(e,t,r){this.networkConfig=e,this.pubsubTopic=t,this.shardId=r}}class mn extends gn{networkConfig;pubsubTopic;shardId;contentTopic;static fromContentTopic(e,t){En(e);const r=function(e,t){const{application:r,version:n}=En(e),s=cn(fn([pn(r),pn(n)])),i=new DataView(s.buffer.slice(-8));return Number(i.getBigUint64(0,!1)%BigInt(t))}(e,t.numShardsInCluster),n=wn(t.clusterId,r);return new mn(t,n,r,e)}constructor(e,t,r,n){super(e,t,r),this.networkConfig=e,this.pubsubTopic=t,this.shardId=r,this.contentTopic=n}get clusterId(){return this.networkConfig.clusterId}get isAutoSharding(){return!0}get isStaticSharding(){return!1}}class yn extends gn{networkConfig;pubsubTopic;shardId;static fromShard(e,t){const r=wn(t.clusterId,e);return new yn(t,r,e)}static fromPubsubTopic(e,t){const{clusterId:r,shard:n}=vn(e);if(r!=t.clusterId)throw"Pubsub topic does not match network config's cluster id";return new yn(t,e,n)}constructor(e,t,r){super(e,t,r),this.networkConfig=e,this.pubsubTopic=t,this.shardId=r}get clusterId(){return this.networkConfig.clusterId}get isAutoSharding(){return!1}get isStaticSharding(){return!0}}function bn(e,t){if("clusterId"in(r=e)&&"numShardsInCluster"in r){if(t.contentTopic)return mn.fromContentTopic(t.contentTopic,e);throw Error("AutoSharding requires contentTopic")}if(void 0!==t.shardId)return yn.fromShard(t.shardId,e);if(t.pubsubTopic)return yn.fromPubsubTopic(t.pubsubTopic,e);throw Error("StaticSharding requires shardId or pubsubTopic");var r}const wn=(e,t)=>`/waku/2/rs/${e}/${t}`,vn=e=>{const t=e.split("/");if(6!=t.length||"waku"!==t[1]||"2"!==t[2]||"rs"!==t[3])throw Error("Invalid pubsub topic");const r=parseInt(t[4]),n=parseInt(t[5]);if(isNaN(r)||isNaN(n))throw Error("Invalid clusterId or shard");return{clusterId:r,shard:n}};function En(e){const t=e.split("/");if(t.length<5||t.length>6)throw Error("Content topic format is invalid: "+e);let r=0;if(6==t.length){if(r=parseInt(t[1]),isNaN(r))throw Error("Invalid generation field in content topic: "+e);if(r>0)throw Error("Generation greater than 0 is not supported: "+e)}const n=t.splice(-4);if(0==n[0].length)throw Error("Application field cannot be empty: "+e);if(0==n[1].length)throw Error("Version field cannot be empty: "+e);if(0==n[2].length)throw Error("Topic name field cannot be empty: "+e);if(0==n[3].length)throw Error("Encoding field cannot be empty: "+e);return{generation:r,application:n[0],version:n[1],topicName:n[2],encoding:n[3]}}const Sn=e=>{if((e=new Uint8Array(e)).length<3)throw Error("Insufficient data");const t=new DataView(e.buffer),r=t.getUint16(0),n=[];if(130===e.length)for(let e=0;e<1024;e++){const r=Math.floor(e/8)+2,s=7-e%8;t.getUint8(r)&1<<s&&n.push(e)}else{const r=t.getUint8(2);for(let s=0,i=3;s<r;s++,i+=2){if(i+1>=e.length)throw Error("Unexpected end of data");n.push(t.getUint16(i))}}return{clusterId:r,shards:n}},An=e=>{const{clusterId:t,shards:r}=e,n=r.length>=64?130:3+2*r.length,s=new ArrayBuffer(n),i=new DataView(s);if(i.setUint16(0,t),r.length>=64)for(const e of r){const t=Math.floor(e/8)+2,r=7-e%8;i.setUint8(t,i.getUint8(t)|1<<r)}else{i.setUint8(2,r.length);for(let e=0,t=3;e<r.length;e++,t+=2)i.setUint16(t,r[e])}return new Uint8Array(s)};var In="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function Cn(e){return e&&e.__esModule&&{}.hasOwnProperty.call(e,"default")?e.default:e}var xn,kn,Tn,Pn,_n,Rn={exports:{}};function Ln(){if(kn)return xn;kn=1;var e=1e3,t=60*e,r=60*t,n=24*r,s=7*n,i=365.25*n;function o(e,t,r,n){var s=t>=1.5*r;return Math.round(e/r)+" "+n+(s?"s":"")}return xn=(a,c)=>{c=c||{};var l=typeof a;if("string"===l&&a.length>0)return function(o){if((o+="").length>100)return;var a=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(o);if(!a)return;var c=parseFloat(a[1]);switch((a[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return c*i;case"weeks":case"week":case"w":return c*s;case"days":case"day":case"d":return c*n;case"hours":case"hour":case"hrs":case"hr":case"h":return c*r;case"minutes":case"minute":case"mins":case"min":case"m":return c*t;case"seconds":case"second":case"secs":case"sec":case"s":return c*e;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return c;default:return}}(a);if("number"===l&&isFinite(a))return c.long?function(s){var i=Math.abs(s);if(i>=n)return o(s,i,n,"day");if(i>=r)return o(s,i,r,"hour");if(i>=t)return o(s,i,t,"minute");if(i>=e)return o(s,i,e,"second");return s+" ms"}(a):function(s){var i=Math.abs(s);if(i>=n)return Math.round(s/n)+"d";if(i>=r)return Math.round(s/r)+"h";if(i>=t)return Math.round(s/t)+"m";if(i>=e)return Math.round(s/e)+"s";return s+"ms"}(a);throw Error("val is not a non-empty string or a valid number. val="+JSON.stringify(a))},xn}var Dn=(_n||(_n=1,function(e,t){t.formatArgs=function(t){if(t[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+t[0]+(this.useColors?"%c ":" ")+"+"+e.exports.humanize(this.diff),!this.useColors)return;const r="color: "+this.color;t.splice(1,0,r,"color: inherit");let n=0,s=0;t[0].replace(/%[a-zA-Z%]/g,e=>{"%%"!==e&&(n++,"%c"===e&&(s=n))}),t.splice(s,0,r)},t.save=e=>{try{e?t.storage.setItem("debug",e):t.storage.removeItem("debug")}catch(e){}},t.load=()=>{let e;try{e=t.storage.getItem("debug")||t.storage.getItem("DEBUG")}catch(e){}return!e&&"undefined"!=typeof process&&"env"in process&&(e=process.env.DEBUG),e},t.useColors=()=>{if("undefined"!=typeof window&&window.process&&("renderer"===window.process.type||window.process.__nwjs))return!0;if("undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;let e;return"undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&(e=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(e[1],10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},t.storage=(()=>{try{return localStorage}catch(e){}})(),t.destroy=(()=>{let e=!1;return()=>{e||(e=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],t.log=console.debug||console.log||(()=>{}),e.exports=(Pn||(Pn=1,Tn=function(e){function t(e){let n,s,i,o=null;function a(...e){if(!a.enabled)return;const r=a,s=Number(new Date),i=s-(n||s);r.diff=i,r.prev=n,r.curr=s,n=s,e[0]=t.coerce(e[0]),"string"!=typeof e[0]&&e.unshift("%O");let o=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,(n,s)=>{if("%%"===n)return"%";o++;const i=t.formatters[s];if("function"==typeof i){const t=e[o];n=i.call(r,t),e.splice(o,1),o--}return n}),t.formatArgs.call(r,e),(r.log||t.log).apply(r,e)}return a.namespace=e,a.useColors=t.useColors(),a.color=t.selectColor(e),a.extend=r,a.destroy=t.destroy,Object.defineProperty(a,"enabled",{enumerable:!0,configurable:!1,get:()=>null!==o?o:(s!==t.namespaces&&(s=t.namespaces,i=t.enabled(e)),i),set(e){o=e}}),"function"==typeof t.init&&t.init(a),a}function r(e,r){const n=t(this.namespace+(void 0===r?":":r)+e);return n.log=this.log,n}function n(e,t){let r=0,n=0,s=-1,i=0;for(;r<e.length;)if(n<t.length&&(t[n]===e[r]||"*"===t[n]))"*"===t[n]?(s=n,i=r,n++):(r++,n++);else{if(-1===s)return!1;n=s+1,i++,r=i}for(;n<t.length&&"*"===t[n];)n++;return n===t.length}return t.debug=t,t.default=t,t.coerce=e=>e instanceof Error?e.stack||e.message:e,t.disable=()=>{const e=[...t.names,...t.skips.map(e=>"-"+e)].join(",");return t.enable(""),e},t.enable=e=>{t.save(e),t.namespaces=e,t.names=[],t.skips=[];const r=("string"==typeof e?e:"").trim().replace(/\s+/g,",").split(",").filter(Boolean);for(const e of r)"-"===e[0]?t.skips.push(e.slice(1)):t.names.push(e)},t.enabled=e=>{for(const r of t.skips)if(n(e,r))return!1;for(const r of t.names)if(n(e,r))return!0;return!1},t.humanize=Ln(),t.destroy=()=>{console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(e).forEach(r=>{t[r]=e[r]}),t.names=[],t.skips=[],t.formatters={},t.selectColor=e=>{let r=0;for(let t=0;t<e.length;t++)r=(r<<5)-r+e.charCodeAt(t),r|=0;return t.colors[Math.abs(r)%t.colors.length]},t.enable(t.load()),t}),Tn)(t);const{formatters:r}=e.exports;r.j=e=>{try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}}(Rn,Rn.exports)),Rn.exports),Mn=Cn(Dn);const Nn="waku";let On=class e{_info;_warn;_error;static createDebugNamespace(e,t){return t?`${Nn}:${t}:${e}`:`${Nn}:${e}`}constructor(t){this._info=Mn(e.createDebugNamespace("info",t)),this._warn=Mn(e.createDebugNamespace("warn",t)),this._error=Mn(e.createDebugNamespace("error",t))}get info(){return this._info}get warn(){return this._warn}get error(){return this._error}log(e,...t){(this[e]||this.log)(...t)}};const Un=new On("message:version-0"),Fn=BigInt(1e6);class Bn{pubsubTopic;proto;constructor(e,t){this.pubsubTopic=e,this.proto=t}get ephemeral(){return!!this.proto.ephemeral}get payload(){return this.proto.payload}get contentTopic(){return this.proto.contentTopic}get timestamp(){try{if(this.proto.timestamp){const e=this.proto.timestamp/Fn;return new Date(Number(e))}return}catch(e){return}}get meta(){return this.proto.meta}get version(){return this.proto.version??0}get rateLimitProof(){return this.proto.rateLimitProof}}let qn=class{contentTopic;ephemeral;routingInfo;metaSetter;constructor(e,t=!1,r,n){if(this.contentTopic=e,this.ephemeral=t,this.routingInfo=r,this.metaSetter=n,!e||""===e)throw Error("Content topic must be specified")}get pubsubTopic(){return this.routingInfo.pubsubTopic}async toWire(e){return wt.encode(await this.toProtoObj(e))}async toProtoObj(e){const t=e.timestamp??new Date,r={payload:e.payload,version:0,contentTopic:this.contentTopic,timestamp:BigInt(t.valueOf())*Fn,meta:void 0,rateLimitProof:e.rateLimitProof,ephemeral:this.ephemeral};if(this.metaSetter){const e=this.metaSetter(r);return{...r,meta:e}}return r}};function $n({contentTopic:e,routingInfo:t,ephemeral:r,metaSetter:n}){return new qn(e,r,t,n)}let zn=class{contentTopic;routingInfo;constructor(e,t){if(this.contentTopic=e,this.routingInfo=t,!e||""===e)throw Error("Content topic must be specified")}get pubsubTopic(){return this.routingInfo.pubsubTopic}fromWireToProtoObj(e){const t=wt.decode(e);return Promise.resolve({payload:t.payload,contentTopic:t.contentTopic,version:t.version??void 0,timestamp:t.timestamp??void 0,meta:t.meta??void 0,rateLimitProof:t.rateLimitProof??void 0,ephemeral:t.ephemeral??!1})}async fromProtoObj(e,t){return t.version?(Un.error("Failed to decode due to incorrect version, expected:",0,", actual:",t.version),Promise.resolve(void 0)):new Bn(e,t)}};function Kn(e,t){return new zn(e,t)}var Vn,Hn,jn;(e=>{e.Relay="relay",e.Store="store",e.LightPush="lightpush",e.Filter="filter"})(Vn||(Vn={})),(e=>{e.GENERIC_FAIL="Generic error",e.REMOTE_PEER_REJECTED="Remote peer rejected",e.DECODE_FAILED="Failed to decode",e.NO_PEER_AVAILABLE="No peer available",e.NO_STREAM_AVAILABLE="No stream available",e.NO_RESPONSE="No response received",e.ENCODE_FAILED="Failed to encode",e.EMPTY_PAYLOAD="Payload is empty",e.SIZE_TOO_BIG="Size is too big",e.TOPIC_NOT_CONFIGURED="Topic not configured",e.STREAM_ABORTED="Stream aborted",e.RLN_PROOF_GENERATION="Proof generation failed",e.TOPIC_DECODER_MISMATCH="Topic decoder mismatch",e.INVALID_DECODER_TOPICS="Invalid decoder topics"})(Hn||(Hn={})),(e=>{e.BOOTSTRAP="bootstrap",e.PEER_EXCHANGE="peer-exchange",e.PEER_CACHE="peer-cache"})(jn||(jn={}));const Gn="locked",Wn={clusterId:1,numShardsInCluster:8};var Xn;function Zn(e){if(null!=e[Symbol.asyncIterator])return(async()=>{const t=[];for await(const r of e)t.push(r);return t})();const t=[];for(const r of e)t.push(r);return t}function Qn(e,r){null==r&&(r=e.reduce((e,t)=>e+t.length,0));const n=t(r);let s=0;for(const t of e)n.set(t,s),s+=t.length;return n}function Yn(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let r=0;r<e.byteLength;r++)if(e[r]!==t[r])return!1;return!0}(e=>{e.Unhealthy="Unhealthy",e.MinimallyHealthy="MinimallyHealthy",e.SufficientlyHealthy="SufficientlyHealthy"})(Xn||(Xn={}));const Jn=Symbol.for("@achingbrain/uint8arraylist");function es(e,t){if(null==t||t<0)throw new RangeError("index is out of bounds");let r=0;for(const n of e){const e=r+n.byteLength;if(t<e)return{buf:n,index:t-r};r=e}throw new RangeError("index is out of bounds")}function ts(e){return!!e?.[Jn]}class rs{bufs;length;[Jn]=!0;constructor(...e){this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const r of e)if(r instanceof Uint8Array)t+=r.byteLength,this.bufs.push(r);else{if(!ts(r))throw Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");t+=r.byteLength,this.bufs.push(...r.bufs)}this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const r of e.reverse())if(r instanceof Uint8Array)t+=r.byteLength,this.bufs.unshift(r);else{if(!ts(r))throw Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");t+=r.byteLength,this.bufs.unshift(...r.bufs)}this.length+=t}get(e){const t=es(this.bufs,e);return t.buf[t.index]}set(e,t){const r=es(this.bufs,e);r.buf[r.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let r=0;r<e.length;r++)this.set(t+r,e[r]);else{if(!ts(e))throw Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");for(let r=0;r<e.length;r++)this.set(t+r,e.get(r))}}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength)return this.bufs=[],void(this.length=0);for(;this.bufs.length>0;){if(!(e>=this.bufs[0].byteLength)){this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift()}}}slice(e,t){const{bufs:r,length:n}=this._subList(e,t);return Qn(r,n)}subarray(e,t){const{bufs:r,length:n}=this._subList(e,t);return 1===r.length?r[0]:Qn(r,n)}sublist(e,t){const{bufs:r,length:n}=this._subList(e,t),s=new rs;return s.length=n,s.bufs=[...r],s}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(0===e&&t===this.length)return{bufs:this.bufs,length:this.length};const r=[];let n=0;for(let s=0;s<this.bufs.length;s++){const i=this.bufs[s],o=n,a=o+i.byteLength;if(n=a,e>=a)continue;const c=e>=o&&e<a,l=t>o&&t<=a;if(c&&l){if(e===o&&t===a){r.push(i);break}const n=e-o;r.push(i.subarray(n,n+(t-e)));break}if(c){if(0===e){r.push(i);continue}r.push(i.subarray(e-o))}else{if(l){if(t===a){r.push(i);break}r.push(i.subarray(0,t-o));break}r.push(i)}}return{bufs:r,length:t-e}}indexOf(e,t=0){if(!(ts(e)||e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const r=e instanceof Uint8Array?e:e.subarray();if(isNaN(t=Number(t??0))&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),0===e.length)return t>this.length?this.length:t;const n=r.byteLength;if(0===n)throw new TypeError("search must be at least 1 byte long");const s=new Int32Array(256);for(let e=0;e<256;e++)s[e]=-1;for(let e=0;e<n;e++)s[r[e]]=e;const i=s,o=this.byteLength-r.byteLength,a=r.byteLength-1;let c;for(let e=t;e<=o;e+=c){c=0;for(let t=a;t>=0;t--){const n=this.get(e+t);if(r[t]!==n){c=Math.max(1,t-i[n]);break}}if(0===c)return e}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,r){const n=t(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,r),this.write(n,e)}getInt16(e,t){const r=this.subarray(e,e+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,t)}setInt16(t,r,n){const s=e(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,r,n),this.write(s,t)}getInt32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,t)}setInt32(t,r,n){const s=e(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,r,n),this.write(s,t)}getBigInt64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,t)}setBigInt64(t,r,n){const s=e(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,r,n),this.write(s,t)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,r){const n=t(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,r),this.write(n,e)}getUint16(e,t){const r=this.subarray(e,e+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,t)}setUint16(t,r,n){const s=e(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,r,n),this.write(s,t)}getUint32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,t)}setUint32(t,r,n){const s=e(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,r,n),this.write(s,t)}getBigUint64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,t)}setBigUint64(t,r,n){const s=e(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,r,n),this.write(s,t)}getFloat32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,t)}setFloat32(t,r,n){const s=e(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,r,n),this.write(s,t)}getFloat64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,t)}setFloat64(t,r,n){const s=e(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,r,n),this.write(s,t)}equals(e){if(null==e)return!1;if(!(e instanceof rs))return!1;if(e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!Yn(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const r=new rs;return r.bufs=e,null==t&&(t=e.reduce((e,t)=>e+t.byteLength,0)),r.length=t,r}}function ns(e){return null!=e[Symbol.asyncIterator]}const ss=e=>{const r=c(e),n=t(r);return h(e,n),ss.bytes=r,n};function is(e,t){const r=(t=t??{}).lengthEncoder??ss;function*n(e){const t=r(e.byteLength);t instanceof Uint8Array?yield t:yield*t,e instanceof Uint8Array?yield e:yield*e}return ns(e)?async function*(){for await(const t of e)yield*n(t)}():function*(){for(const t of e)yield*n(t)}()}ss.bytes=0,is.single=(e,t)=>{const r=(t=t??{}).lengthEncoder??ss;return new rs(r(e.byteLength),e)};let os=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"},as=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"},cs=class extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"},ls=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};var us;(e=>{e[e.LENGTH=0]="LENGTH",e[e.DATA=1]="DATA"})(us||(us={}));const hs=e=>{const t=d(e);return hs.bytes=c(t),t};function ds(e,t){const r=new rs;let n=us.LENGTH,s=-1;const i=t?.lengthDecoder??hs,o=t?.maxLengthLength??8,a=t?.maxDataLength??4194304;function*c(){for(;r.byteLength>0;){if(n===us.LENGTH)try{if(s=i(r),s<0)throw new os("Invalid message length");if(s>a)throw new as("Message length too long");const e=i.bytes;r.consume(e),null!=t?.onLength&&t.onLength(s),n=us.DATA}catch(e){if(e instanceof RangeError){if(r.byteLength>o)throw new cs("Message length length too long");break}throw e}if(n===us.DATA){if(r.byteLength<s)break;const e=r.sublist(0,s);r.consume(s),null!=t?.onData&&t.onData(e),yield e,n=us.LENGTH}}}return ns(e)?async function*(){for await(const t of e)r.append(t),yield*c();if(r.byteLength>0)throw new ls("Unexpected end of input")}():function*(){for(const t of e)r.append(t),yield*c();if(r.byteLength>0)throw new ls("Unexpected end of input")}()}function ps(){const e={};return e.promise=new Promise((t,r)=>{e.resolve=t,e.reject=r}),e}hs.bytes=0,ds.fromReader=(e,t)=>{let r=1;return ds(async function*(){for(;;)try{const{done:t,value:n}=await e.next(r);if(!0===t)return;null!=n&&(yield n)}catch(e){if("ERR_UNDER_READ"===e.code)return{done:!0,value:null};throw e}finally{r=1}}(),{...t??{},onLength(e){r=e}})};class fs{buffer;mask;top;btm;next;constructor(e){if(!(e>0)||e-1&e)throw Error("Max size for a FixedFIFO should be a power of two");this.buffer=Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return void 0===this.buffer[this.top]&&(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(void 0!==e)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return void 0===this.buffer[this.btm]}}class gs{size;hwm;head;tail;constructor(e={}){this.hwm=e.splitLimit??16,this.head=new fs(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return null!=e?.byteLength?e.byteLength:1}push(e){if(null!=e?.value&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new fs(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(void 0===e&&null!=this.tail.next){const t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return null!=e?.value&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}let ms=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}};function ys(e={}){return function(e,t){t=t??{};let r,n,s,i=t.onEnd,o=new gs,a=ps();const c=async()=>{try{return o.isEmpty()?s?{done:!0}:await new Promise((t,s)=>{n=i=>{n=null,o.push(i);try{t(e(o))}catch(e){s(e)}return r}}):e(o)}finally{o.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=ps()})}},l=e=>null!=n?n(e):(o.push(e),r),u=e=>(o=new gs,null!=n?n({error:e}):(o.push({error:e}),r)),h=e=>{if(s)return r;if(!0!==t?.objectMode&&null==e?.byteLength)throw Error("objectMode was not true but tried to push non-Uint8Array value");return l({done:!1,value:e})},d=e=>s?r:(s=!0,null!=e?u(e):l({done:!0})),p=()=>(o=new gs,d(),{done:!0}),f=e=>(d(e),{done:!0});if(r={[Symbol.asyncIterator](){return this},next:c,return:p,throw:f,push:h,end:d,get readableLength(){return o.size},async onEmpty(e){const t=e?.signal;if(t?.throwIfAborted(),o.isEmpty())return;let r,n;null!=t&&(r=new Promise((e,r)=>{n=()=>{r(new ms)},t.addEventListener("abort",n)}));try{await Promise.race([a.promise,r])}finally{null!=n&&null!=t&&t?.removeEventListener("abort",n)}}},null==i)return r;const g=r;return r={[Symbol.asyncIterator](){return this},next:()=>g.next(),throw:e=>(g.throw(e),null!=i&&(i(e),i=void 0),{done:!0}),return:()=>(g.return(),null!=i&&(i(),i=void 0),{done:!0}),push:h,end:e=>(g.end(e),null!=i&&(i(e),i=void 0),r),get readableLength(){return g.readableLength},onEmpty(e){return g.onEmpty(e)}},r}(e=>{const t=e.shift();if(null==t)return{done:!0};if(null!=t.error)throw t.error;return{done:!0===t.done,value:t.value}},e)}let bs=class extends Error{type;code;constructor(e,t,r){super(e??"The operation was aborted"),this.type="aborted",this.name=r??"AbortError",this.code=t??"ABORT_ERR"}};async function ws(e,t,r){if(null==t)return e;if(t.aborted)return e.catch(()=>{}),Promise.reject(new bs(r?.errorMessage,r?.errorCode,r?.errorName));let n;const s=new bs(r?.errorMessage,r?.errorCode,r?.errorName);try{return await Promise.race([e,new Promise((e,r)=>{n=()=>{r(s)},t.addEventListener("abort",n)})])}finally{null!=n&&t.removeEventListener("abort",n)}}class vs{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=ps(),this.haveNext=ps()}[Symbol.asyncIterator](){return this}async next(){if(null==this.nextResult&&await this.haveNext.promise,null==this.nextResult)throw Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=ps(),e}async throw(e){this.ended=!0,this.error=e,null!=e&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e));return{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){null!=e?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(null!=e&&this.ended)throw this.error??Error("Cannot push value onto an ended pushable");for(;null!=this.nextResult;)await this.readNext.promise;null!=e?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=ps(),await ws(this.readNext.promise,t?.signal,t)}}function Es(){return new vs}function Ss(e){return null!=e[Symbol.asyncIterator]}async function*As(e){const t=new AbortController,r=Es();(async function(e,t,r){try{await Promise.all(e.map(async e=>{for await(const n of e)await t.push(n,{signal:r}),r.throwIfAborted()})),await t.end(void 0,{signal:r})}catch(e){await t.end(e,{signal:r}).catch(()=>{})}})(e,r,t.signal).catch(()=>{});try{yield*r}finally{t.abort()}}function Is(...e){const t=[];for(const r of e)Ss(r)||t.push(r);return t.length===e.length?function*(e){for(const t of e)yield*t}(t):As(e)}function Cs(e,...t){if(null==e)throw Error("Empty pipeline");if(Ps(e)){const t=e;e=()=>t.source}else if(Ts(e)||ks(e)){const t=e;e=()=>t}const r=[e,...t];if(r.length>1&&Ps(r[r.length-1])&&(r[r.length-1]=r[r.length-1].sink),r.length>2)for(let e=1;e<r.length-1;e++)Ps(r[e])&&(r[e]=_s(r[e]));return xs(...r)}const xs=(...e)=>{let t;for(;e.length>0;)t=e.shift()(t);return t},ks=e=>null!=e?.[Symbol.asyncIterator],Ts=e=>null!=e?.[Symbol.iterator],Ps=e=>null!=e&&(null!=e.sink&&null!=e.source),_s=e=>t=>{const r=e.sink(t);if(null!=r?.then){const t=ys({objectMode:!0});let n;r.then(()=>{t.end()},e=>{t.end(e)});const s=e.source;if(ks(s))n=async function*(){yield*s,t.end()};else{if(!Ts(s))throw Error("Unknown duplex source type - must be Iterable or AsyncIterable");n=function*(){yield*s,t.end()}}return Is(t,n())}return e.source};function Rs(e){return e.filter(e=>"open"===e.status).sort((e,t)=>t.timeline.open-e.timeline.open).at(0)}const Ls="consumed";class Ds{multicodec;libp2p;log;ongoingCreation=new Set;streamPool=new Map;constructor(e,t){this.multicodec=e,this.libp2p=t,this.log=new On("stream-manager:"+e),this.libp2p.events.addEventListener("peer:update",this.handlePeerUpdateStreamPool)}async getStream(e){try{const t=e.toString(),r=this.streamPool.get(t);r&&(this.streamPool.delete(t),await r);const n=this.getOpenStreamForCodec(e)||await this.createStream(e);if(!n)return;return this.log.info(`Using stream for peerId=${t} multicodec=${this.multicodec}`),this.lockStream(t,n),n}catch(e){return void this.log.error("Failed to getStream:",e)}}async createStream(e,t=0){const r=Rs(this.libp2p.connectionManager.getConnections(e));if(!r)return void this.log.error(`Failed to get a connection to the peer peerId=${e.toString()} multicodec=${this.multicodec}`);let n,s;for(let i=0;i<t+1;i++)try{this.log.info(`Attempting to create a stream for peerId=${e.toString()} multicodec=${this.multicodec}`),s=await r.newStream(this.multicodec),this.log.info(`Created stream for peerId=${e.toString()} multicodec=${this.multicodec}`);break}catch(e){n=e}if(s)return s;this.log.error(`Failed to create a new stream for ${e.toString()} -- `+n)}async createStreamWithLock(e){const t=e.id.toString();if(this.ongoingCreation.has(t))this.log.info(`Skipping creation of a stream due to lock for peerId=${t} multicodec=${this.multicodec}`);else try{this.ongoingCreation.add(t),await this.createStream(e.id)}catch(e){this.log.error("Failed to createStreamWithLock:",e)}finally{this.ongoingCreation.delete(t)}}handlePeerUpdateStreamPool=e=>{const{peer:t}=e.detail;if(!t.protocols.includes(this.multicodec))return;this.getOpenStreamForCodec(t.id)||this.scheduleNewStream(t)};scheduleNewStream(e){this.log.info(`Scheduling creation of a stream for peerId=${e.id.toString()} multicodec=${this.multicodec}`),this.streamPool.has(e.id.toString())&&this.streamPool.delete(e.id.toString()),this.streamPool.set(e.id.toString(),this.createStreamWithLock(e))}getOpenStreamForCodec(e){const t=Rs(this.libp2p.connectionManager.getConnections(e));if(!t)return void this.log.info(`No open connection found for peerId=${e.toString()} multicodec=${this.multicodec}`);const r=t.streams.find(e=>e.protocol===this.multicodec);if(!r)return void this.log.info(`No open stream found for peerId=${e.toString()} multicodec=${this.multicodec}`);if(!["done","closed","closing"].includes(r.writeStatus||"")&&!this.isStreamLocked(r))return this.log.info(`Found open stream for peerId=${e.toString()} multicodec=${this.multicodec}`),r;this.log.info(`Stream for peerId=${e.toString()} multicodec=${this.multicodec} is unusable`)}lockStream(e,t){this.log.info(`Locking stream for peerId:${e}\tstreamId:${t.id}`),t.metadata[Ls]=!0}isStreamLocked(e){return!!e.metadata[Ls]}}let Ms;const Ns=new Uint8Array(16);function Os(){if(!Ms&&(Ms="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!Ms))throw Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return Ms(Ns)}const Us=[];for(let e=0;e<256;++e)Us.push((e+256).toString(16).slice(1));var Fs={randomUUID:"undefined"!=typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};function Bs(e){if(Fs.randomUUID&&!e)return Fs.randomUUID();const t=(e=e||{}).random||(e.rng||Os)();return t[6]=15&t[6]|64,t[8]=63&t[8]|128,function(e,t=0){return Us[e[t+0]]+Us[e[t+1]]+Us[e[t+2]]+Us[e[t+3]]+"-"+Us[e[t+4]]+Us[e[t+5]]+"-"+Us[e[t+6]]+Us[e[t+7]]+"-"+Us[e[t+8]]+Us[e[t+9]]+"-"+Us[e[t+10]]+Us[e[t+11]]+Us[e[t+12]]+Us[e[t+13]]+Us[e[t+14]]+Us[e[t+15]]}(t)}class qs{proto;constructor(e){this.proto=e}static decode(e){const t=Tt.decode(e);return new qs(t)}encode(){return Tt.encode(this.proto)}get wakuMessage(){return this.proto.wakuMessage}get pubsubTopic(){return this.proto.pubsubTopic}}class $s{proto;constructor(e){this.proto=e}static createSubscribeRequest(e,t){return new $s({requestId:Bs(),filterSubscribeType:xt.FilterSubscribeType.SUBSCRIBE,pubsubTopic:e,contentTopics:t})}static createUnsubscribeRequest(e,t){return new $s({requestId:Bs(),filterSubscribeType:xt.FilterSubscribeType.UNSUBSCRIBE,pubsubTopic:e,contentTopics:t})}static createUnsubscribeAllRequest(e){return new $s({requestId:Bs(),filterSubscribeType:xt.FilterSubscribeType.UNSUBSCRIBE_ALL,pubsubTopic:e,contentTopics:[]})}static createSubscriberPingRequest(){return new $s({requestId:Bs(),filterSubscribeType:xt.FilterSubscribeType.SUBSCRIBER_PING,pubsubTopic:"",contentTopics:[]})}static decode(e){const t=xt.decode(e);return new $s(t)}encode(){return xt.encode(this.proto)}get filterSubscribeType(){return this.proto.filterSubscribeType}get requestId(){return this.proto.requestId}get pubsubTopic(){return this.proto.pubsubTopic}get contentTopics(){return this.proto.contentTopics}}class zs{proto;constructor(e){this.proto=e}static decode(e){const t=kt.decode(e);return new zs(t)}encode(){return kt.encode(this.proto)}get statusCode(){return this.proto.statusCode}get statusDesc(){return this.proto.statusDesc}get requestId(){return this.proto.requestId}}const Ks=new On("filter-core"),Vs="/vac/waku/filter-subscribe/2.0.0-beta1",Hs="/vac/waku/filter-push/2.0.0-beta1";class js{handleIncomingMessage;streamManager;multicodec=Vs;constructor(e,t){this.handleIncomingMessage=e,this.streamManager=new Ds(Vs,t.components),t.handle(Hs,this.onRequest.bind(this),{maxInboundStreams:100}).catch(e=>{Ks.error("Failed to register ",Hs,e)})}async subscribe(e,t,r){const n=await this.streamManager.getStream(t);if(!n)return{success:null,failure:{error:Hn.NO_STREAM_AVAILABLE,peerId:t}};const s=$s.createSubscribeRequest(e,r);let i;try{if(i=await Cs([s.encode()],is,n,ds,async e=>await Zn(e)),!i?.length)throw Error("Received no response from subscription request.")}catch(e){return Ks.error("Failed to send subscribe request",e),{success:null,failure:{error:Hn.GENERIC_FAIL,peerId:t}}}const{statusCode:o,requestId:a,statusDesc:c}=zs.decode(i[0].slice());return o<200||o>=300?(Ks.error(`Filter subscribe request ${a} failed with status code ${o}: ${c}`),{failure:{error:Hn.REMOTE_PEER_REJECTED,peerId:t},success:null}):{failure:null,success:t}}async unsubscribe(e,t,r){const n=await this.streamManager.getStream(t);if(!n)return Ks.error("Failed to get a stream for remote peer:"+t.toString()),{success:null,failure:{error:Hn.NO_STREAM_AVAILABLE,peerId:t}};const s=$s.createUnsubscribeRequest(e,r);try{await Cs([s.encode()],is,n.sink)}catch(e){return Ks.error("Failed to send unsubscribe request",e),{success:null,failure:{error:Hn.GENERIC_FAIL,peerId:t}}}return{success:t,failure:null}}async unsubscribeAll(e,t){const r=await this.streamManager.getStream(t);if(!r)return Ks.error("Failed to get a stream for remote peer:"+t.toString()),{success:null,failure:{error:Hn.NO_STREAM_AVAILABLE,peerId:t}};const n=$s.createUnsubscribeAllRequest(e),s=await Cs([n.encode()],is,r,ds,async e=>await Zn(e));if(!s||!s.length)return{failure:{error:Hn.NO_RESPONSE,peerId:t},success:null};const{statusCode:i,requestId:o,statusDesc:a}=zs.decode(s[0].slice());return i<200||i>=300?(Ks.error(`Filter unsubscribe all request ${o} failed with status code ${i}: ${a}`),{failure:{error:Hn.REMOTE_PEER_REJECTED,peerId:t},success:null}):{failure:null,success:t}}async ping(e){const t=await this.streamManager.getStream(e);if(!t)return Ks.error("Failed to get a stream for remote peer:"+e.toString()),{success:null,failure:{error:Hn.NO_STREAM_AVAILABLE,peerId:e}};const r=$s.createSubscriberPingRequest();let n;try{n=await Cs([r.encode()],is,t,ds,async e=>await Zn(e))}catch(t){return Ks.error("Failed to send ping request",t),{success:null,failure:{error:Hn.GENERIC_FAIL,peerId:e}}}if(!n||!n.length)return{success:null,failure:{error:Hn.NO_RESPONSE,peerId:e}};const{statusCode:s,requestId:i,statusDesc:o}=zs.decode(n[0].slice());return s<200||s>=300?(Ks.error(`Filter ping request ${i} failed with status code ${s}: ${o}`),{success:null,failure:{error:Hn.REMOTE_PEER_REJECTED,peerId:e}}):{success:e,failure:null}}onRequest(e){const{connection:t,stream:r}=e,{remotePeer:n}=t;Ks.info("Received message from "+n.toString());try{Cs(r,ds,async e=>{for await(const r of e){const e=qs.decode(r.slice()),{pubsubTopic:n,wakuMessage:s}=e;if(!s)return void Ks.error("Received empty message");if(!n)return void Ks.error("Pubsub topic missing from push message");await this.handleIncomingMessage(n,s,t.remotePeer.toString())}}).then(()=>{Ks.info("Receiving pipe closed.")},async e=>{Ks.error(`Error with receiving pipe on peer:${t.remotePeer.toString()} -- stream:${r.id} -- protocol:${r.protocol}: `,e)})}catch(e){Ks.error("Error decoding message",e)}}}class Gs{proto;constructor(e){this.proto=e}static createRequest(e,t){return new Gs({requestId:Bs(),request:{message:e,pubsubTopic:t},response:void 0})}static decode(e){const t=Dt.decode(e);return new Gs(t)}encode(){return Dt.encode(this.proto)}get query(){return this.proto.request}get response(){return this.proto.response}}const Ws=new On("light-push"),Xs="/vac/waku/lightpush/2.0.0-beta1";class Zs{streamManager;multicodec=Xs;constructor(e){this.streamManager=new Ds(Xs,e.components)}async preparePushMessage(e,t){try{if(!t.payload||0===t.payload.length)return Ws.error("Failed to send waku light push: payload is empty"),{query:null,error:Hn.EMPTY_PAYLOAD};if(!await async function(e,t){const r=await e.toWire(t);return!!r&&nr(r)}(e,t))return Ws.error("Failed to send waku light push: message is bigger than 1MB"),{query:null,error:Hn.SIZE_TOO_BIG};const r=await e.toProtoObj(t);if(!r)return Ws.error("Failed to encode to protoMessage, aborting push"),{query:null,error:Hn.ENCODE_FAILED};return{query:Gs.createRequest(r,e.pubsubTopic),error:null}}catch(e){return Ws.error("Failed to prepare push message",e),{query:null,error:Hn.GENERIC_FAIL}}}async send(e,t,r){const{query:n,error:s}=await this.preparePushMessage(e,t);if(s||!n)return{success:null,failure:{error:s,peerId:r}};const i=await this.streamManager.getStream(r);if(!i)return Ws.error("Failed to get a stream for remote peer:"+r.toString()),{success:null,failure:{error:Hn.NO_STREAM_AVAILABLE,peerId:r}};let o;try{o=await Cs([n.encode()],is,i,ds,async e=>await Zn(e))}catch(e){return Ws.error("Failed to send waku light push request",e),{success:null,failure:{error:Hn.STREAM_ABORTED,peerId:r}}}const a=new rs;let c;o.forEach(e=>{a.append(e)});try{c=Gs.decode(a).response}catch(e){return Ws.error("Failed to decode push reply",e),{success:null,failure:{error:Hn.DECODE_FAILED,peerId:r}}}return c?(l=c.info)&&(l.includes("could not generate rln proof")||l.includes("could not get new message id to generate an rln proof")||l.includes("RLN validation failed"))?(Ws.error("Remote peer fault: RLN generation"),{success:null,failure:{error:Hn.RLN_PROOF_GENERATION,peerId:r}}):c.isSuccess?{success:r,failure:null}:(Ws.error("Remote peer rejected the message: ",c.info),{success:null,failure:{error:Hn.REMOTE_PEER_REJECTED,peerId:r}}):(Ws.error("Remote peer fault: No response in PushRPC"),{success:null,failure:{error:Hn.NO_RESPONSE,peerId:r}});var l}}const Qs={payload:new Uint8Array,contentTopic:"",version:void 0,timestamp:void 0,meta:void 0,rateLimitProof:void 0,ephemeral:void 0};const Ys=864e5,Js=1e6;class ei{proto;constructor(e){this.proto=e}static create(e){const t=new ei({...e,contentTopics:e.contentTopics||[],requestId:Bs(),timeStart:e.timeStart?BigInt(e.timeStart.getTime()*Js):void 0,timeEnd:e.timeEnd?BigInt(e.timeEnd.getTime()*Js):void 0,messageHashes:e.messageHashes||[],paginationLimit:e.paginationLimit?BigInt(e.paginationLimit):void 0}),r=e.messageHashes&&e.messageHashes.length>0,n=e.contentTopics&&e.contentTopics.length>0,s=e.timeStart||e.timeEnd;if(r){if(n||s)throw Error("Message hash lookup queries cannot include content filter criteria (contentTopics, timeStart, or timeEnd)")}else if(e.pubsubTopic&&(!e.contentTopics||0===e.contentTopics.length)||!e.pubsubTopic&&e.contentTopics&&e.contentTopics.length>0)throw Error("Both pubsubTopic and contentTopics must be set together for content-filtered queries");return t}static decode(e){const t=Bt.decode(e);return new ei(t)}encode(){return Bt.encode(this.proto)}}class ti{proto;constructor(e){this.proto=e}static decode(e){const t=qt.decode(e);return new ti(t)}encode(){return qt.encode(this.proto)}get statusCode(){return this.proto.statusCode}get statusDesc(){return this.proto.statusDesc}get messages(){return this.proto.messages}get paginationCursor(){return this.proto.paginationCursor}}const ri=new On("store"),ni="/vac/waku/store-query/3.0.0";class si{streamManager;multicodec=ni;constructor(e){this.streamManager=new Ds(ni,e.components)}get maxTimeLimit(){return Ys}async*queryPerPage(e,t,r){if(e.timeStart&&e.timeEnd){if(e.timeEnd.getTime()-e.timeStart.getTime()>Ys)throw Error("Time range bigger than 24h")}if(!(e.messageHashes&&e.messageHashes.length>0)&&e.contentTopics&&e.contentTopics.toString()!==Array.from(t.keys()).toString())throw Error("Internal error, the decoders should match the query's content topics");let n=e.paginationCursor;for(;;){const s=ei.create({...e,paginationCursor:n});ri.info("Sending store query request:",{hasMessageHashes:!!e.messageHashes?.length,messageHashCount:e.messageHashes?.length,pubsubTopic:e.pubsubTopic,contentTopics:e.contentTopics});const i=await this.streamManager.getStream(r);if(!i){ri.error("Failed to get a stream for remote peer:"+r.toString());break}const o=await Cs([s.encode()],is,i,ds,async e=>await Zn(e)),a=new rs;o.forEach(e=>{a.append(e)});const c=ti.decode(a);if(!c.statusCode||c.statusCode>=300){const e=`Store query failed with status code: ${c.statusCode}, description: ${c.statusDesc}`;throw ri.error(e),Error(e)}if(!c.messages||!c.messages.length){ri.warn("Stopping pagination due to empty messages in response");break}ri.info(c.messages.length+" messages retrieved from store");const l=c.messages.map(e=>{if(!e.message)return Promise.resolve(void 0);const r=e.message.contentTopic;if(r){const s=t.get(r);if(s)return s.fromProtoObj(e.pubsubTopic||"",(n=e.message,{...Qs,...n}))}var n;return Promise.resolve(void 0)});if(yield l,n=e.paginationForward?c.messages[c.messages.length-1].messageHash:c.messages[0].messageHash,c.messages.length>100&&c.messages.length<(e.paginationLimit||20))break}}}const ii=new On("connection-limiter");class oi{libp2p;events;networkMonitor;dialer;connectionMonitorInterval=null;options;constructor(e){this.libp2p=e.libp2p,this.events=e.events,this.networkMonitor=e.networkMonitor,this.dialer=e.dialer,this.options=e.options,this.onWakuConnectionEvent=this.onWakuConnectionEvent.bind(this),this.onDisconnectedEvent=this.onDisconnectedEvent.bind(this)}start(){this.dialPeersFromStore(),this.options.enableAutoRecovery&&null===this.connectionMonitorInterval&&(this.connectionMonitorInterval=setInterval(()=>{this.maintainConnections()},5e3)),this.events.addEventListener("waku:connection",this.onWakuConnectionEvent),this.libp2p.addEventListener("peer:disconnect",this.onDisconnectedEvent)}stop(){this.events.removeEventListener("waku:connection",this.onWakuConnectionEvent),this.libp2p.removeEventListener("peer:disconnect",this.onDisconnectedEvent),this.connectionMonitorInterval&&(clearInterval(this.connectionMonitorInterval),this.connectionMonitorInterval=null)}onWakuConnectionEvent(){this.options.enableAutoRecovery?this.networkMonitor.isBrowserConnected()&&this.dialPeersFromStore():ii.info("Auto recovery is disabled, skipping")}async maintainConnections(){await this.maintainConnectionsCount(),await this.maintainBootstrapConnections()}async onDisconnectedEvent(){0===this.libp2p.getConnections().length&&(ii.info("No connections, dialing peers from store"),await this.dialPeersFromStore())}async maintainConnectionsCount(){ii.info("Maintaining connections count");const e=this.libp2p.getConnections();if(e.length<=this.options.maxConnections){ii.info(`Node has less than max connections ${this.options.maxConnections}, trying to dial more peers`);const t=await this.getPrioritizedPeers();if(0===t.length)return void ii.info("No peers to dial, node is utilizing all known peers");const r=t.slice(0,this.options.maxConnections-e.length).map(e=>this.dialer.dial(e.id));return void await Promise.all(r)}ii.info(`Node has more than max connections ${this.options.maxConnections}, dropping connections`);try{const t=e.filter(e=>!e.tags.includes(Gn)).slice(this.options.maxConnections);if(0===t.length)return void ii.info("No connections to drop, skipping");const r=t.map(e=>this.libp2p.hangUp(e.remotePeer));await Promise.all(r),ii.info(`Dropped ${t.length} connections`)}catch(e){ii.error("Unexpected error while maintaining connections",e)}}async maintainBootstrapConnections(){ii.info("Maintaining bootstrap connections");const e=await this.getBootstrapPeers();if(!(e.length<=this.options.maxBootstrapPeers))try{const t=e.slice(this.options.maxBootstrapPeers);ii.info(`Dropping ${t.length} bootstrap connections because node has more than max bootstrap connections ${this.options.maxBootstrapPeers}`);const r=t.map(e=>this.libp2p.hangUp(e.id));await Promise.all(r),ii.info(`Dropped ${t.length} bootstrap connections`)}catch(e){ii.error("Unexpected error while maintaining bootstrap connections",e)}}async dialPeersFromStore(){ii.info("Dialing peers from store");try{const e=await this.getPrioritizedPeers();if(0===e.length)return void ii.info("No peers to dial, skipping");const t=e.map(e=>this.dialer.dial(e.id));ii.info(`Dialing ${e.length} peers from store`),await Promise.all(t),ii.info(`Dialed ${t.length} peers from store`)}catch(e){ii.error("Unexpected error while dialing peer store peers",e)}}async getPrioritizedPeers(){const e=await this.libp2p.peerStore.all(),t=this.libp2p.getConnections();ii.info(`Found ${e.length} peers in store, and found ${t.length} connections`);const r=e.filter(e=>!t.some(t=>t.remotePeer.equals(e.id))&&e.addresses.some(e=>e.multiaddr.toString().includes("wss")||e.multiaddr.toString().includes("ws"))),n=r.filter(e=>e.tags.has(jn.BOOTSTRAP)),s=r.filter(e=>e.tags.has(jn.PEER_EXCHANGE)),i=r.filter(e=>e.tags.has(jn.PEER_CACHE));return[...n,...s,...i]}async getBootstrapPeers(){return(await Promise.all(this.libp2p.getConnections().map(e=>e.remotePeer).map(e=>this.getPeer(e)))).filter(e=>e&&e.tags.has(jn.BOOTSTRAP))}async getPeer(e){try{return await this.libp2p.peerStore.get(e)}catch(t){return ii.error(`Failed to get peer ${e}, error: ${t}`),null}}}const ai=new On("dialer");class ci{libp2p;shardReader;options;dialingQueue=[];dialHistory=new Map;failedDials=new Map;dialingInterval=null;isProcessing=!1;isImmediateDialing=!1;constructor(e){this.libp2p=e.libp2p,this.shardReader=e.shardReader,this.options=e.options}start(){ai.info("Starting dialer"),this.dialingInterval||(this.dialingInterval=setInterval(()=>{this.processQueue()},500)),this.dialHistory.clear(),this.failedDials.clear()}stop(){ai.info("Stopping dialer"),this.dialingInterval&&(clearInterval(this.dialingInterval),this.dialingInterval=null),this.dialHistory.clear(),this.failedDials.clear()}async dial(e){if(await this.shouldSkipPeer(e))return void ai.info("Skipping peer: "+e);const t=0===this.dialingQueue.length,r=!this.isProcessing&&!this.isImmediateDialing;t&&r?(this.isImmediateDialing=!0,ai.info("Dialed peer immediately"),await this.dialPeer(e),this.isImmediateDialing=!1,ai.info("Released immediate dial lock")):(this.dialingQueue.push(e),ai.info("Added peer to dialing queue, queue size: "+this.dialingQueue.length))}async processQueue(){if(0!==this.dialingQueue.length&&!this.isProcessing){this.isProcessing=!0;try{const e=this.dialingQueue.slice(0,this.options.maxDialingPeers);this.dialingQueue=this.dialingQueue.slice(e.length),ai.info(`Processing dial queue: dialing ${e.length} peers, ${this.dialingQueue.length} remaining in queue`),await Promise.all(e.map(e=>this.dialPeer(e)))}finally{this.isProcessing=!1}}}async dialPeer(e){try{ai.info("Dialing peer from queue: "+e),await this.libp2p.dial(e),this.dialHistory.set(e.toString(),Date.now()),this.failedDials.delete(e.toString()),ai.info("Successfully dialed peer from queue: "+e)}catch(t){ai.error("Error dialing peer "+e,t),this.failedDials.set(e.toString(),Date.now())}}async shouldSkipPeer(e){const t=this.libp2p.getPeers().some(t=>t.equals(e));if(t)return ai.info(`Skipping peer ${e} - already connected`),!0;if(this.isRecentlyDialed(e))return ai.info(`Skipping peer ${e} - already dialed in the last 10 seconds`),!0;if(this.isRecentlyFailed(e))return ai.info(`Skipping peer ${e} - recently failed to dial`),!0;try{if(!await this.shardReader.hasShardInfo(e))return ai.info(`Skipping peer ${e} - no shard info`),!1;return!await this.shardReader.isPeerOnCluster(e)&&(ai.info(`Skipping peer ${e} - not on same cluster`),!0)}catch(t){return ai.error("Error checking shard info for peer "+e,t),!0}}isRecentlyDialed(e){const t=this.dialHistory.get(e.toString());return!!(t&&Date.now()-t<1e3*this.options.dialCooldown)}isRecentlyFailed(e){const t=this.failedDials.get(e.toString());return!!(t&&Date.now()-t<1e3*this.options.failedDialCooldown)}}const li=new On("discovery-dialer");class ui{libp2p;dialer;constructor(e){this.libp2p=e.libp2p,this.dialer=e.dialer,this.onPeerDiscovery=this.onPeerDiscovery.bind(this)}start(){this.libp2p.addEventListener("peer:discovery",this.onPeerDiscovery)}stop(){this.libp2p.removeEventListener("peer:discovery",this.onPeerDiscovery)}async onPeerDiscovery(e){const t=e.detail.id;li.info("Discovered new peer: "+t);try{await this.updatePeerStore(t,e.detail.multiaddrs),await this.dialer.dial(t)}catch(e){li.error("Error dialing peer "+t,e)}}async updatePeerStore(e,t){try{li.info("Updating peer store for "+e);const r=await this.getPeer(e);if(!r)return li.info(`Peer ${e} not found in store, saving`),void await this.libp2p.peerStore.save(e,{multiaddrs:t});const n=t.every(e=>r.addresses.some(t=>t.multiaddr.equals(e)));if(n)return void li.info(`Peer ${e} has same addresses in peer store, skipping`);li.info(`Merging peer ${e} addresses in peer store`),await this.libp2p.peerStore.merge(e,{multiaddrs:t})}catch(t){li.error("Error updating peer store for "+e,t)}}async getPeer(e){try{return await this.libp2p.peerStore.get(e)}catch(t){return void li.error("Error getting peer info for "+e,t)}}}const hi="/relay-ping/1/ping/null",di=new On("keep-alive");class pi{relay;networkConfig;libp2p;options;pingKeepAliveTimers=new Map;relayKeepAliveTimers=new Map;constructor({options:e,relay:t,networkConfig:r,libp2p:n}){this.options=e,this.relay=t,this.networkConfig=r,this.libp2p=n,this.onPeerConnect=this.onPeerConnect.bind(this),this.onPeerDisconnect=this.onPeerDisconnect.bind(this)}start(){this.libp2p.addEventListener("peer:connect",this.onPeerConnect),this.libp2p.addEventListener("peer:disconnect",this.onPeerDisconnect)}stop(){this.libp2p.removeEventListener("peer:connect",this.onPeerConnect),this.libp2p.removeEventListener("peer:disconnect",this.onPeerDisconnect);for(const e of this.pingKeepAliveTimers.values())clearInterval(e);for(const e of this.relayKeepAliveTimers.values())for(const t of e)clearInterval(t);this.pingKeepAliveTimers.clear(),this.relayKeepAliveTimers.clear()}onPeerConnect(e){const t=e.detail;this.startPingForPeer(t)}onPeerDisconnect(e){const t=e.detail;this.stopPingForPeer(t)}startPingForPeer(e){this.stopPingForPeer(e),this.startLibp2pPing(e),this.startRelayPing(e)}stopPingForPeer(e){this.stopLibp2pPing(e),this.stopRelayPing(e)}startLibp2pPing(e){if(0===this.options.pingKeepAlive)return void di.warn(`Ping keep alive is disabled pingKeepAlive:${this.options.pingKeepAlive}, skipping start for libp2p ping`);const t=e.toString();if(this.pingKeepAliveTimers.has(t))return void di.warn(`Ping already started for peer: ${t}, skipping start for libp2p ping`);const r=setInterval(()=>{this.pingLibp2p(e)},1e3*this.options.pingKeepAlive);this.pingKeepAliveTimers.set(t,r)}stopLibp2pPing(e){const t=e.toString();this.pingKeepAliveTimers.has(t)?(clearInterval(this.pingKeepAliveTimers.get(t)),this.pingKeepAliveTimers.delete(t)):di.warn(`Ping not started for peer: ${t}, skipping stop for ping`)}startRelayPing(e){if(!this.relay)return;if(0===this.options.relayKeepAlive)return void di.warn(`Relay keep alive is disabled relayKeepAlive:${this.options.relayKeepAlive}, skipping start for relay ping`);if(this.relayKeepAliveTimers.has(e.toString()))return void di.warn(`Relay ping already started for peer: ${e.toString()}, skipping start for relay ping`);const t=[];for(const r of this.relay.pubsubTopics){if(!this.relay.getMeshPeers(r).includes(e.toString())){di.warn(`Peer: ${e.toString()} is not in the mesh for topic: ${r}, skipping start for relay ping`);continue}const n=$n({routingInfo:bn(this.networkConfig,{contentTopic:hi,pubsubTopic:r}),contentTopic:hi,ephemeral:!0}),s=setInterval(()=>{this.pingRelay(n)},1e3*this.options.relayKeepAlive);t.push(s)}this.relayKeepAliveTimers.set(e.toString(),t)}stopRelayPing(e){if(!this.relay)return;const t=e.toString();this.relayKeepAliveTimers.has(t)?(this.relayKeepAliveTimers.get(t)?.map(clearInterval),this.relayKeepAliveTimers.delete(t)):di.warn(`Relay ping not started for peer: ${t}, skipping stop for relay ping`)}async pingRelay(e){try{di.info("Sending Waku Relay ping message"),await this.relay.send(e,{payload:new Uint8Array([1])})}catch(e){di.error("Failed to send relay ping",e)}}async pingLibp2p(e){try{di.info(`Pinging libp2p peer (${e.toString()})`);const t=await this.libp2p.services.ping.ping(e);di.info(`Ping succeeded (${e.toString()})`,t),await this.libp2p.peerStore.merge(e,{metadata:{ping:pn(t.toString())}}),di.info(`Ping updated for peer (${e.toString()})`)}catch(t){di.error(`Ping failed for peer (${e.toString()})`,t)}}}class fi{libp2p;events;isNetworkConnected=!1;constructor(e){this.libp2p=e.libp2p,this.events=e.events,this.onConnectedEvent=this.onConnectedEvent.bind(this),this.onDisconnectedEvent=this.onDisconnectedEvent.bind(this),this.dispatchNetworkEvent=this.dispatchNetworkEvent.bind(this)}start(){this.libp2p.addEventListener("peer:connect",this.onConnectedEvent),this.libp2p.addEventListener("peer:disconnect",this.onDisconnectedEvent);try{globalThis.addEventListener("online",this.dispatchNetworkEvent),globalThis.addEventListener("offline",this.dispatchNetworkEvent)}catch(e){}}stop(){this.libp2p.removeEventListener("peer:connect",this.onConnectedEvent),this.libp2p.removeEventListener("peer:disconnect",this.onDisconnectedEvent);try{globalThis.removeEventListener("online",this.dispatchNetworkEvent),globalThis.removeEventListener("offline",this.dispatchNetworkEvent)}catch(e){}}isConnected(){return!!this.isBrowserConnected()&&this.isP2PConnected()}isP2PConnected(){return this.isNetworkConnected}isBrowserConnected(){try{if(globalThis?.navigator&&!globalThis?.navigator?.onLine)return!1}catch(e){}return!0}onConnectedEvent(){this.isNetworkConnected||(this.isNetworkConnected=!0,this.dispatchNetworkEvent())}onDisconnectedEvent(){this.isNetworkConnected&&0===this.libp2p.getConnections().length&&(this.isNetworkConnected=!1,this.dispatchNetworkEvent())}dispatchNetworkEvent(){this.events.dispatchEvent(new CustomEvent("waku:connection",{detail:this.isConnected()}))}}const gi=new On("shard-reader");class mi{libp2p;clusterId;constructor(e){this.libp2p=e.libp2p,this.clusterId=e.networkConfig.clusterId}async isPeerOnCluster(e){const t=await this.getRelayShards(e);return!!t&&t.clusterId===this.clusterId}async hasShardInfo(e){return!!await this.getRelayShards(e)}async isPeerOnTopic(e,t){try{const{clusterId:r,shard:n}=vn(t);return r===this.clusterId&&await this.isPeerOnShard(e,n)}catch(r){return gi.error(`Error comparing pubsub topic ${t} with shard info for ${e}`,r),!1}}async isPeerOnShard(e,t){const r=await this.getRelayShards(e);return gi.info(`Checking if peer on same shard: this { clusterId: ${this.clusterId}, shardId: ${t} },${e} { clusterId: ${r?.clusterId}, shards: ${r?.shards} }`),!!r&&(r.clusterId===this.clusterId&&r.shards.includes(t))}async getRelayShards(e){try{const t=(await this.libp2p.peerStore.get(e)).metadata.get("shardInfo");if(!t)return;return Sn(t)}catch(t){return void gi.error("Error getting shard info for "+e,t)}}}const yi=Symbol.for("@libp2p/connection"),bi=Symbol.for("@libp2p/content-routing"),wi=Symbol.for("@libp2p/peer-discovery"),vi=Symbol.for("@libp2p/peer-id");function Ei(e){return!!e?.[vi]}const Si=Symbol.for("@libp2p/peer-routing"),Ai="keep-alive",Ii=Symbol.for("@libp2p/transport");var Ci;(e=>{e[e.FATAL_ALL=0]="FATAL_ALL",e[e.NO_FATAL=1]="NO_FATAL"})(Ci||(Ci={}));let xi=class extends Error{static name="AbortError";constructor(e="The operation was aborted"){super(e),this.name="AbortError"}};class ki extends Error{static name="UnexpectedPeerError";constructor(e="Unexpected Peer"){super(e),this.name="UnexpectedPeerError"}}let Ti=class extends Error{static name="InvalidCryptoExchangeError";constructor(e="Invalid crypto exchange"){super(e),this.name="InvalidCryptoExchangeError"}},Pi=class extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}};class _i extends Error{static name="InvalidPublicKeyError";constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}}class Ri extends Error{static name="ConnectionClosingError";constructor(e="The connection is closing"){super(e),this.name="ConnectionClosingError"}}class Li extends Error{static name="ConnectionClosedError";constructor(e="The connection is closed"){super(e),this.name="ConnectionClosedError"}}class Di extends Error{static name="ConnectionFailedError";constructor(e="Connection failed"){super(e),this.name="ConnectionFailedError"}}class Mi extends Error{static name="MuxerClosedError";constructor(e="The muxer is closed"){super(e),this.name="MuxerClosedError"}}class Ni extends Error{static name="StreamResetError";constructor(e="The stream has been reset"){super(e),this.name="StreamResetError"}}class Oi extends Error{static name="StreamStateError";constructor(e="The stream is in an invalid state"){super(e),this.name="StreamStateError"}}let Ui=class extends Error{static name="NotFoundError";constructor(e="Not found"){super(e),this.name="NotFoundError"}};class Fi extends Error{static name="InvalidPeerIdError";constructor(e="Invalid PeerID"){super(e),this.name="InvalidPeerIdError"}}let Bi=class extends Error{static name="InvalidMultiaddrError";constructor(e="Invalid multiaddr"){super(e),this.name="InvalidMultiaddrError"}};class qi extends Error{static name="InvalidCIDError";constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}}class $i extends Error{static name="InvalidMultihashError";constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}}class zi extends Error{static name="UnsupportedProtocolError";constructor(e="Unsupported protocol error"){super(e),this.name="UnsupportedProtocolError"}}class Ki extends Error{static name="InvalidMessageError";constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}}class Vi extends Error{static name="ProtocolError";constructor(e="Protocol error"){super(e),this.name="ProtocolError"}}let Hi=class extends Error{static name="TimeoutError";constructor(e="Timed out"){super(e),this.name="TimeoutError"}};class ji extends Error{static name="NotStartedError";constructor(e="Not started"){super(e),this.name="NotStartedError"}}class Gi extends Error{static name="DialError";constructor(e="Dial error"){super(e),this.name="DialError"}}class Wi extends Error{static name="LimitedConnectionError";constructor(e="Limited connection"){super(e),this.name="LimitedConnectionError"}}class Xi extends Error{static name="TooManyInboundProtocolStreamsError";constructor(e="Too many inbound protocol streams"){super(e),this.name="TooManyInboundProtocolStreamsError"}}class Zi extends Error{static name="TooManyOutboundProtocolStreamsError";constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}}class Qi extends Error{static name="UnsupportedKeyTypeError";constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}}class Yi extends EventTarget{#e=new Map;constructor(){super()}listenerCount(e){const t=this.#e.get(e);return null==t?0:t.length}addEventListener(e,t,r){super.addEventListener(e,t,r);let n=this.#e.get(e);null==n&&(n=[],this.#e.set(e,n)),n.push({callback:t,once:(!0!==r&&!1!==r&&r?.once)??!1})}removeEventListener(e,t,r){super.removeEventListener(e.toString(),t??null,r);let n=this.#e.get(e);null!=n&&(n=n.filter(({callback:e})=>e!==t),this.#e.set(e,n))}dispatchEvent(e){const t=super.dispatchEvent(e);let r=this.#e.get(e.type);return null==r||(r=r.filter(({once:e})=>!e),this.#e.set(e.type,r)),t}safeDispatchEvent(e,t={}){return this.dispatchEvent(new CustomEvent(e,t))}}function Ji(e){return null!=e&&"function"==typeof e.start&&"function"==typeof e.stop}const eo=Symbol.for("@libp2p/service-capabilities"),to=Symbol.for("@libp2p/service-dependencies"),ro=parseInt("11111",2),no=parseInt("10000000",2),so=parseInt("01111111",2),io={0:co,1:co,2(e,t){const r=ao(e,t),n=t.offset,s=t.offset+r,i=[];for(let t=n;t<s;t++)t===n&&0===e[t]||i.push(e[t]);return t.offset+=r,Uint8Array.from(i)},3(e,t){const r=ao(e,t),n=e[t.offset];t.offset++;const s=e.subarray(t.offset,t.offset+r-1);if(t.offset+=r,0!==n)throw Error("Unused bits in bit string is unimplemented");return s},4(e,t){const r=ao(e,t),n=e.subarray(t.offset,t.offset+r);return t.offset+=r,n},5(e,t){return t.offset++,null},6(e,t){const r=ao(e,t),n=t.offset+r,s=e[t.offset];t.offset++;let i=0,o=0;s<40?(i=0,o=s):s<80?(i=1,o=s-40):(i=2,o=s-80);let a=`${i}.${o}`,c=[];for(;t.offset<n;){const r=e[t.offset];if(t.offset++,c.push(127&r),r<128){c.reverse();let e=0;for(let t=0;t<c.length;t++)e+=c[t]<<7*t;a+="."+e,c=[]}}return a},16:co,22:co,48:co};function oo(e,t={offset:0}){const r=e[t.offset]&ro;if(t.offset++,null!=io[r])return io[r](e,t);throw Error("No decoder for tag "+r)}function ao(e,t){let r=0;if((e[t.offset]&no)===no){const n=e[t.offset]&so;let s="0x";t.offset++;for(let r=0;r<n;r++,t.offset++)s+=e[t.offset].toString(16).padStart(2,"0");r=parseInt(s,16)}else r=e[t.offset],t.offset++;return r}function co(e,t){ao(e,t);const r=[];for(;!(t.offset>=e.byteLength);){const n=oo(e,t);if(null===n)break;r.push(n)}return r}function lo(e){if(e.byteLength<128)return Uint8Array.from([e.byteLength]);const t=function(e){let t=e.toString(16);t.length%2==1&&(t="0"+t);const r=new rs;for(let e=0;e<t.length;e+=2)r.append(Uint8Array.from([parseInt(`${t[e]}${t[e+1]}`,16)]));return r}(e.byteLength);return new rs(Uint8Array.from([t.byteLength|no]),t)}function uo(e){const t=new rs;return!(128&~e.subarray()[0])&&t.append(Uint8Array.from([0])),t.append(e),new rs(Uint8Array.from([2]),lo(t),t)}function ho(e){const t=Uint8Array.from([0]),r=new rs(t,e);return new rs(Uint8Array.from([3]),lo(r),r)}function po(e,t=48){const r=new rs;for(const t of e)r.append(t);return new rs(Uint8Array.from([t]),lo(r),r)}const fo=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),go=Uint8Array.from([6,5,43,129,4,0,34]),mo=Uint8Array.from([6,5,43,129,4,0,35]),yo={ext:!0,kty:"EC",crv:"P-256"},bo={ext:!0,kty:"EC",crv:"P-384"},wo={ext:!0,kty:"EC",crv:"P-521"},vo=32,Eo=48,So=66;function Ao(e){return function(e){const t=e[1][1][0],r=1;let n,s;if(65===t.byteLength)return n=ln(t.subarray(r,r+vo),"base64url"),s=ln(t.subarray(r+vo),"base64url"),new Co({...yo,key_ops:["verify"],x:n,y:s});if(97===t.byteLength)return n=ln(t.subarray(r,r+Eo),"base64url"),s=ln(t.subarray(r+Eo),"base64url"),new Co({...bo,key_ops:["verify"],x:n,y:s});if(133===t.byteLength)return n=ln(t.subarray(r,r+So),"base64url"),s=ln(t.subarray(r+So),"base64url"),new Co({...wo,key_ops:["verify"],x:n,y:s});throw new Pi(`coordinates were wrong length, got ${t.byteLength}, expected 65, 97 or 133`)}(oo(e))}function Io(e){if("P-256"===e)return fo;if("P-384"===e)return go;if("P-521"===e)return mo;throw new Pi("Invalid curve "+e)}let Co=class{type="ECDSA";jwk;_raw;constructor(e){this.jwk=e}get raw(){var e;return null==this._raw&&(this._raw=(e=this.jwk,po([uo(Uint8Array.from([1])),po([Io(e.crv)],160),po([ho(new rs(Uint8Array.from([4]),rt(e.x??"","base64url"),rt(e.y??"","base64url")))],161)]).subarray())),this._raw}toMultihash(){return Be.digest(Zc(this))}toCID(){return je.createV1(114,this.toMultihash())}toString(){return he.encode(this.toMultihash().bytes).substring(1)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&Yn(this.raw,e.raw)}async verify(e,t,r){return async function(e,t,r,n){const s=await crypto.subtle.importKey("jwk",e,{name:"ECDSA",namedCurve:e.crv??"P-256"},!1,["verify"]);n?.signal?.throwIfAborted();const i=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},s,t,r.subarray());return n?.signal?.throwIfAborted(),i}(this.jwk,t,e,r)}};const xo=BigInt(0),ko=BigInt(1);function To(e,t=""){if("boolean"!=typeof e){throw Error((t&&`"${t}"`)+"expected boolean, got type="+typeof e)}return e}function Po(e,t,r=""){const n=ir(e),s=e?.length,i=void 0!==t;if(!n||i&&s!==t){throw Error((r&&`"${r}" `)+"expected Uint8Array"+(i?" of length "+t:"")+", got "+(n?"length="+s:"type="+typeof e))}return e}function _o(e){const t=e.toString(16);return 1&t.length?"0"+t:t}function Ro(e){if("string"!=typeof e)throw Error("hex string expected, got "+typeof e);return""===e?xo:BigInt("0x"+e)}function Lo(e){return Ro(gr(e))}function Do(e){return ar(e),Ro(gr(Uint8Array.from(e).reverse()))}function Mo(e,t){return Ar(e.toString(16).padStart(2*t,"0"))}function No(e,t){return Mo(e,t).reverse()}function Oo(e,t,r){let n;if("string"==typeof t)try{n=Ar(t)}catch(t){throw Error(e+" must be hex string or Uint8Array, cause: "+t)}else{if(!ir(t))throw Error(e+" must be hex string or Uint8Array");n=Uint8Array.from(t)}const s=n.length;if("number"==typeof r&&s!==r)throw Error(e+" of length "+r+" expected, got "+s);return n}function Uo(e){return Uint8Array.from(e)}const Fo=e=>"bigint"==typeof e&&xo<=e;function Bo(e,t,r,n){if(!function(e,t,r){return Fo(e)&&Fo(t)&&Fo(r)&&t<=e&&e<r}(t,r,n))throw Error("expected valid "+e+": "+r+" <= n < "+n+", got "+t)}function qo(e){let t;for(t=0;e>xo;e>>=ko,t+=1);return t}const $o=e=>(ko<<BigInt(e))-ko;function zo(e,t,r={}){if(!e||"object"!=typeof e)throw Error("expected valid options object");function n(t,r,n){const s=e[t];if(n&&void 0===s)return;const i=typeof s;if(i!==r||null===s)throw Error(`param "${t}" is invalid: expected ${r}, got ${i}`)}Object.entries(t).forEach(([e,t])=>n(e,t,!1)),Object.entries(r).forEach(([e,t])=>n(e,t,!0))}function Ko(e){const t=new WeakMap;return(r,...n)=>{const s=t.get(r);if(void 0!==s)return s;const i=e(r,...n);return t.set(r,i),i}}const Vo=BigInt(0),Ho=BigInt(1),jo=BigInt(2),Go=BigInt(3),Wo=BigInt(4),Xo=BigInt(5),Zo=BigInt(7),Qo=BigInt(8),Yo=BigInt(9),Jo=BigInt(16);function ea(e,t){const r=e%t;return r>=Vo?r:t+r}function ta(e,t,r){let n=e;for(;t-- >Vo;)n*=n,n%=r;return n}function ra(e,t){if(e===Vo)throw Error("invert: expected non-zero number");if(t<=Vo)throw Error("invert: expected positive modulus, got "+t);let r=ea(e,t),n=t,s=Vo,i=Ho;for(;r!==Vo;){const e=n%r,t=s-i*(n/r);n=r,r=e,s=i,i=t}if(n!==Ho)throw Error("invert: does not exist");return ea(s,t)}function na(e,t,r){if(!e.eql(e.sqr(t),r))throw Error("Cannot find square root")}function sa(e,t){const r=(e.ORDER+Ho)/Wo,n=e.pow(t,r);return na(e,n,t),n}function ia(e,t){const r=(e.ORDER-Xo)/Qo,n=e.mul(t,jo),s=e.pow(n,r),i=e.mul(t,s),o=e.mul(e.mul(i,jo),s),a=e.mul(i,e.sub(o,e.ONE));return na(e,a,t),a}function oa(e){if(e<Go)throw Error("sqrt is not defined for small field");let t=e-Ho,r=0;for(;t%jo===Vo;)t/=jo,r++;let n=jo;const s=da(e);for(;1===ua(s,n);)if(n++>1e3)throw Error("Cannot find square root: probably non-prime P");if(1===r)return sa;let i=s.pow(n,t);const o=(t+Ho)/jo;return function(e,n){if(e.is0(n))return n;if(1!==ua(e,n))throw Error("Cannot find square root");let s=r,a=e.mul(e.ONE,i),c=e.pow(n,t),l=e.pow(n,o);for(;!e.eql(c,e.ONE);){if(e.is0(c))return e.ZERO;let t=1,r=e.sqr(c);for(;!e.eql(r,e.ONE);)if(t++,r=e.sqr(r),t===s)throw Error("Cannot find square root");const n=Ho<<BigInt(s-t-1),i=e.pow(a,n);s=t,a=e.sqr(i),c=e.mul(c,a),l=e.mul(l,i)}return l}}function aa(e){return e%Wo===Go?sa:e%Qo===Xo?ia:e%Jo===Yo?function(e){const t=da(e),r=oa(e),n=r(t,t.neg(t.ONE)),s=r(t,n),i=r(t,t.neg(n)),o=(e+Zo)/Jo;return(e,t)=>{let r=e.pow(t,o),a=e.mul(r,n);const c=e.mul(r,s),l=e.mul(r,i),u=e.eql(e.sqr(a),t),h=e.eql(e.sqr(c),t);r=e.cmov(r,a,u),a=e.cmov(l,c,h);const d=e.eql(e.sqr(a),t),p=e.cmov(r,a,d);return na(e,p,t),p}}(e):oa(e)}const ca=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function la(e,t,r=!1){const n=Array(t.length).fill(r?e.ZERO:void 0),s=t.reduce((t,r,s)=>e.is0(r)?t:(n[s]=t,e.mul(t,r)),e.ONE),i=e.inv(s);return t.reduceRight((t,r,s)=>e.is0(r)?t:(n[s]=e.mul(t,n[s]),e.mul(t,r)),i),n}function ua(e,t){const r=(e.ORDER-Ho)/jo,n=e.pow(t,r),s=e.eql(n,e.ONE),i=e.eql(n,e.ZERO),o=e.eql(n,e.neg(e.ONE));if(!s&&!i&&!o)throw Error("invalid Legendre symbol result");return s?1:i?0:-1}function ha(e,t){void 0!==t&&or(t);const r=void 0!==t?t:e.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function da(e,t,r=!1,n={}){if(e<=Vo)throw Error("invalid field: expected ORDER > 0, got "+e);let s,i,o,a=!1;if("object"==typeof t&&null!=t){if(n.sqrt||r)throw Error("cannot specify opts in two arguments");const e=t;e.BITS&&(s=e.BITS),e.sqrt&&(i=e.sqrt),"boolean"==typeof e.isLE&&(r=e.isLE),"boolean"==typeof e.modFromBytes&&(a=e.modFromBytes),o=e.allowedLengths}else"number"==typeof t&&(s=t),n.sqrt&&(i=n.sqrt);const{nBitLength:c,nByteLength:l}=ha(e,s);if(l>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");let u;const h=Object.freeze({ORDER:e,isLE:r,BITS:c,BYTES:l,MASK:$o(c),ZERO:Vo,ONE:Ho,allowedLengths:o,create(t){return ea(t,e)},isValid(t){if("bigint"!=typeof t)throw Error("invalid field element: expected bigint, got "+typeof t);return Vo<=t&&t<e},is0(e){return e===Vo},isValidNot0(e){return!h.is0(e)&&h.isValid(e)},isOdd(e){return(e&Ho)===Ho},neg(t){return ea(-t,e)},eql(e,t){return e===t},sqr(t){return ea(t*t,e)},add(t,r){return ea(t+r,e)},sub(t,r){return ea(t-r,e)},mul(t,r){return ea(t*r,e)},pow(e,t){return function(e,t,r){if(r<Vo)throw Error("invalid exponent, negatives unsupported");if(r===Vo)return e.ONE;if(r===Ho)return t;let n=e.ONE,s=t;for(;r>Vo;)r&Ho&&(n=e.mul(n,s)),s=e.sqr(s),r>>=Ho;return n}(h,e,t)},div(t,r){return ea(t*ra(r,e),e)},sqrN(e){return e*e},addN(e,t){return e+t},subN(e,t){return e-t},mulN(e,t){return e*t},inv(t){return ra(t,e)},sqrt:i||(t=>(u||(u=aa(e)),u(h,t))),toBytes(e){return r?No(e,l):Mo(e,l)},fromBytes(t,n=!0){if(o){if(!o.includes(t.length)||t.length>l)throw Error("Field.fromBytes: expected "+o+" bytes, got "+t.length);const e=new Uint8Array(l);e.set(t,r?0:e.length-t.length),t=e}if(t.length!==l)throw Error("Field.fromBytes: expected "+l+" bytes, got "+t.length);let s=r?Do(t):Lo(t);if(a&&(s=ea(s,e)),!n&&!h.isValid(s))throw Error("invalid field element: outside of range 0..ORDER");return s},invertBatch(e){return la(h,e)},cmov(e,t,r){return r?t:e}});return Object.freeze(h)}function pa(e){if("bigint"!=typeof e)throw Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function fa(e){const t=pa(e);return t+Math.ceil(t/2)}const ga=BigInt(0),ma=BigInt(1);function ya(e,t){const r=t.negate();return e?r:t}function ba(e,t){const r=la(e.Fp,t.map(e=>e.Z));return t.map((t,n)=>e.fromAffine(t.toAffine(r[n])))}function wa(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw Error("invalid window size, expected [1.."+t+"], got W="+e)}function va(e,t){wa(e,t);const r=2**e;return{windows:Math.ceil(t/e)+1,windowSize:2**(e-1),mask:$o(e),maxNumber:r,shiftBy:BigInt(e)}}function Ea(e,t,r){const{windowSize:n,mask:s,maxNumber:i,shiftBy:o}=r;let a=Number(e&s),c=e>>o;a>n&&(a-=i,c+=ma);const l=t*n;return{nextN:c,offset:l+Math.abs(a)-1,isZero:0===a,isNeg:a<0,isNegF:t%2!=0,offsetF:l}}const Sa=new WeakMap,Aa=new WeakMap;function Ia(e){return Aa.get(e)||1}function Ca(e){if(e!==ga)throw Error("invalid wNAF")}class xa{constructor(e,t){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=t}_unsafeLadder(e,t,r=this.ZERO){let n=e;for(;t>ga;)t&ma&&(r=r.add(n)),n=n.double(),t>>=ma;return r}precomputeWindow(e,t){const{windows:r,windowSize:n}=va(t,this.bits),s=[];let i=e,o=i;for(let e=0;e<r;e++){o=i,s.push(o);for(let e=1;e<n;e++)o=o.add(i),s.push(o);i=o.double()}return s}wNAF(e,t,r){if(!this.Fn.isValid(r))throw Error("invalid scalar");let n=this.ZERO,s=this.BASE;const i=va(e,this.bits);for(let e=0;e<i.windows;e++){const{nextN:o,offset:a,isZero:c,isNeg:l,isNegF:u,offsetF:h}=Ea(r,e,i);r=o,c?s=s.add(ya(u,t[h])):n=n.add(ya(l,t[a]))}return Ca(r),{p:n,f:s}}wNAFUnsafe(e,t,r,n=this.ZERO){const s=va(e,this.bits);for(let e=0;e<s.windows&&r!==ga;e++){const{nextN:i,offset:o,isZero:a,isNeg:c}=Ea(r,e,s);if(r=i,!a){const e=t[o];n=n.add(c?e.negate():e)}}return Ca(r),n}getPrecomputes(e,t,r){let n=Sa.get(t);return n||(n=this.precomputeWindow(t,e),1!==e&&("function"==typeof r&&(n=r(n)),Sa.set(t,n))),n}cached(e,t,r){const n=Ia(e);return this.wNAF(n,this.getPrecomputes(n,e,r),t)}unsafe(e,t,r,n){const s=Ia(e);return 1===s?this._unsafeLadder(e,t,n):this.wNAFUnsafe(s,this.getPrecomputes(s,e,r),t,n)}createCache(e,t){wa(t,this.bits),Aa.set(e,t),Sa.delete(e)}hasCache(e){return 1!==Ia(e)}}function ka(e,t,r,n){!function(e,t){if(!Array.isArray(e))throw Error("array expected");e.forEach((e,r)=>{if(!(e instanceof t))throw Error("invalid point at index "+r)})}(r,e),function(e,t){if(!Array.isArray(e))throw Error("array of scalars expected");e.forEach((e,r)=>{if(!t.isValid(e))throw Error("invalid scalar at index "+r)})}(n,t);const s=r.length,i=n.length;if(s!==i)throw Error("arrays of points and scalars must have equal length");const o=e.ZERO,a=qo(BigInt(s));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const l=$o(c),u=Array(Number(l)+1).fill(o);let h=o;for(let e=Math.floor((t.BITS-1)/c)*c;e>=0;e-=c){u.fill(o);for(let t=0;t<i;t++){const s=n[t],i=Number(s>>BigInt(e)&l);u[i]=u[i].add(r[t])}let t=o;for(let e=u.length-1,r=o;e>0;e--)r=r.add(u[e]),t=t.add(r);if(h=h.add(t),0!==e)for(let e=0;e<c;e++)h=h.double()}return h}function Ta(e,t,r){if(t){if(t.ORDER!==e)throw Error("Field.ORDER must match order: Fp == p, Fn == n");return function(e){const t=ca.reduce((e,t)=>(e[t]="function",e),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"});zo(e,t)}(t),t}return da(e,{isLE:r})}function Pa(e,t,r={},n){if(void 0===n&&(n="edwards"===e),!t||"object"!=typeof t)throw Error(`expected valid ${e} CURVE object`);for(const e of["p","n","h"]){const r=t[e];if(!("bigint"==typeof r&&r>ga))throw Error(`CURVE.${e} must be positive bigint`)}const s=Ta(t.p,r.Fp,n),i=Ta(t.n,r.Fn,n),o=["Gx","Gy","a","weierstrass"===e?"b":"d"];for(const e of o)if(!s.isValid(t[e]))throw Error(`CURVE.${e} must be valid field element of CURVE.Fp`);return{CURVE:t=Object.freeze(Object.assign({},t)),Fp:s,Fn:i}}const _a=BigInt(0),Ra=BigInt(1),La=BigInt(2),Da=BigInt(8);function Ma(e,t,r={}){if("function"!=typeof t)throw Error('"hash" function param is required');zo(r,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:n}=r,{BASE:s,Fp:i,Fn:o}=e,a=r.randomBytes||Tr,c=r.adjustScalarBytes||(e=>e),l=r.domain||((e,t,r)=>{if(To(r,"phflag"),t.length||r)throw Error("Contexts/pre-hash are not supported");return e});function u(e){return o.create(Do(e))}function h(e){const{head:r,prefix:n,scalar:i}=function(e){const r=m.secretKey;e=Oo("private key",e,r);const n=Oo("hashed private key",t(e),2*r),s=c(n.slice(0,r));return{head:s,prefix:n.slice(r,2*r),scalar:u(s)}}(e),o=s.multiply(i),a=o.toBytes();return{head:r,prefix:n,scalar:i,point:o,pointBytes:a}}function d(e){return h(e).pointBytes}function p(e=Uint8Array.of(),...r){const s=Cr(...r);return u(t(l(s,Oo("context",e),!!n)))}const f={zip215:!0};const g=i.BYTES,m={secretKey:g,publicKey:g,signature:2*g,seed:g};function y(e=a(m.seed)){return Po(e,m.seed,"seed")}const b={getExtendedPublicKey:h,randomSecretKey:y,isValidSecretKey(e){return ir(e)&&e.length===o.BYTES},isValidPublicKey(t,r){try{return!!e.fromBytes(t,r)}catch(e){return!1}},toMontgomery(t){const{y:r}=e.fromBytes(t),n=m.publicKey,s=32===n;if(!s&&57!==n)throw Error("only defined for 25519 and 448");const o=s?i.div(Ra+r,Ra-r):i.div(r-Ra,r+Ra);return i.toBytes(o)},toMontgomerySecret(e){const r=m.secretKey;Po(e,r);const n=t(e.subarray(0,r));return c(n).subarray(0,r)},randomPrivateKey:y,precompute:(t=8,r=e.BASE)=>r.precompute(t,!1)};return Object.freeze({keygen(e){const t=b.randomSecretKey(e);return{secretKey:t,publicKey:d(t)}},getPublicKey:d,sign(e,t,r={}){e=Oo("message",e),n&&(e=n(e));const{prefix:i,scalar:a,pointBytes:c}=h(t),l=p(r.context,i,e),u=s.multiply(l).toBytes(),d=p(r.context,u,c,e),f=o.create(l+d*a);if(!o.isValid(f))throw Error("sign failed: invalid s");return Po(Cr(u,o.toBytes(f)),m.signature,"result")},verify(t,r,i,o=f){const{context:a,zip215:c}=o,l=m.signature;t=Oo("signature",t,l),r=Oo("message",r),i=Oo("publicKey",i,m.publicKey),void 0!==c&&To(c,"zip215"),n&&(r=n(r));const u=l/2,h=t.subarray(0,u),d=Do(t.subarray(u,l));let g,y,b;try{g=e.fromBytes(i,c),y=e.fromBytes(h,c),b=s.multiplyUnsafe(d)}catch(e){return!1}if(!c&&g.isSmallOrder())return!1;const w=p(a,y.toBytes(),g.toBytes(),r);return y.add(g.multiplyUnsafe(w)).subtract(b).clearCofactor().is0()},utils:b,Point:e,lengths:m})}function Na(e){const{CURVE:t,curveOpts:r,hash:n,eddsaOpts:s}=function(e){const t={a:e.a,d:e.d,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},r={Fp:e.Fp,Fn:da(t.n,e.nBitLength,!0),uvRatio:e.uvRatio},n={randomBytes:e.randomBytes,adjustScalarBytes:e.adjustScalarBytes,domain:e.domain,prehash:e.prehash,mapToCurve:e.mapToCurve};return{CURVE:t,curveOpts:r,hash:e.hash,eddsaOpts:n}}(e),i=function(e,t={}){const r=Pa("edwards",e,t,t.FpFnLE),{Fp:n,Fn:s}=r;let i=r.CURVE;const{h:o}=i;zo(t,{},{uvRatio:"function"});const a=La<<BigInt(8*s.BYTES)-Ra,c=e=>n.create(e),l=t.uvRatio||((e,t)=>{try{return{isValid:!0,value:n.sqrt(n.div(e,t))}}catch(e){return{isValid:!1,value:_a}}});if(!((e,t,r,n)=>{const s=e.sqr(r),i=e.sqr(n),o=e.add(e.mul(t.a,s),i),a=e.add(e.ONE,e.mul(t.d,e.mul(s,i)));return e.eql(o,a)})(n,i,i.Gx,i.Gy))throw Error("bad curve params: generator point");function u(e,t,r=!1){return Bo("coordinate "+e,t,r?Ra:_a,a),t}function h(e){if(!(e instanceof f))throw Error("ExtendedPoint expected")}const d=Ko((e,t)=>{const{X:r,Y:s,Z:i}=e,o=e.is0();null==t&&(t=o?Da:n.inv(i));const a=c(r*t),l=c(s*t),u=n.mul(i,t);if(o)return{x:_a,y:Ra};if(u!==Ra)throw Error("invZ was invalid");return{x:a,y:l}}),p=Ko(e=>{const{a:t,d:r}=i;if(e.is0())throw Error("bad point: ZERO");const{X:n,Y:s,Z:o,T:a}=e,l=c(n*n),u=c(s*s),h=c(o*o),d=c(h*h),p=c(l*t);if(c(h*c(p+u))!==c(d+c(r*c(l*u))))throw Error("bad point: equation left != right (1)");if(c(n*s)!==c(o*a))throw Error("bad point: equation left != right (2)");return!0});class f{constructor(e,t,r,n){this.X=u("x",e),this.Y=u("y",t),this.Z=u("z",r,!0),this.T=u("t",n),Object.freeze(this)}static CURVE(){return i}static fromAffine(e){if(e instanceof f)throw Error("extended point not allowed");const{x:t,y:r}=e||{};return u("x",t),u("y",r),new f(t,r,Ra,c(t*r))}static fromBytes(e,t=!1){const r=n.BYTES,{a:s,d:o}=i;e=Uo(Po(e,r,"point")),To(t,"zip215");const u=Uo(e),h=e[r-1];u[r-1]=-129&h;const d=Do(u),p=t?a:n.ORDER;Bo("point.y",d,_a,p);const g=c(d*d),m=c(g-Ra),y=c(o*g-s);let{isValid:b,value:w}=l(m,y);if(!b)throw Error("bad point: invalid y coordinate");const v=(w&Ra)===Ra,E=!!(128&h);if(!t&&w===_a&&E)throw Error("bad point: x=0 and x_0=1");return E!==v&&(w=c(-w)),f.fromAffine({x:w,y:d})}static fromHex(e,t=!1){return f.fromBytes(Oo("point",e),t)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(e=8,t=!0){return g.createCache(this,e),t||this.multiply(La),this}assertValidity(){p(this)}equals(e){h(e);const{X:t,Y:r,Z:n}=this,{X:s,Y:i,Z:o}=e,a=c(t*o),l=c(s*n),u=c(r*o),d=c(i*n);return a===l&&u===d}is0(){return this.equals(f.ZERO)}negate(){return new f(c(-this.X),this.Y,this.Z,c(-this.T))}double(){const{a:e}=i,{X:t,Y:r,Z:n}=this,s=c(t*t),o=c(r*r),a=c(La*c(n*n)),l=c(e*s),u=t+r,h=c(c(u*u)-s-o),d=l+o,p=d-a,g=l-o,m=c(h*p),y=c(d*g),b=c(h*g),w=c(p*d);return new f(m,y,w,b)}add(e){h(e);const{a:t,d:r}=i,{X:n,Y:s,Z:o,T:a}=this,{X:l,Y:u,Z:d,T:p}=e,g=c(n*l),m=c(s*u),y=c(a*r*p),b=c(o*d),w=c((n+s)*(l+u)-g-m),v=b-y,E=b+y,S=c(m-t*g),A=c(w*v),I=c(E*S),C=c(w*S),x=c(v*E);return new f(A,I,x,C)}subtract(e){return this.add(e.negate())}multiply(e){if(!s.isValidNot0(e))throw Error("invalid scalar: expected 1 <= sc < curve.n");const{p:t,f:r}=g.cached(this,e,e=>ba(f,e));return ba(f,[t,r])[0]}multiplyUnsafe(e,t=f.ZERO){if(!s.isValid(e))throw Error("invalid scalar: expected 0 <= sc < curve.n");return e===_a?f.ZERO:this.is0()||e===Ra?this:g.unsafe(this,e,e=>ba(f,e),t)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}isTorsionFree(){return g.unsafe(this,i.n).is0()}toAffine(e){return d(this,e)}clearCofactor(){return o===Ra?this:this.multiplyUnsafe(o)}toBytes(){const{x:e,y:t}=this.toAffine(),r=n.toBytes(t);return r[r.length-1]|=e&Ra?128:0,r}toHex(){return gr(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(e){return ba(f,e)}static msm(e,t){return ka(f,s,e,t)}_setWindowSize(e){this.precompute(e)}toRawBytes(){return this.toBytes()}}f.BASE=new f(i.Gx,i.Gy,Ra,c(i.Gx*i.Gy)),f.ZERO=new f(_a,Ra,Ra,_a),f.Fp=n,f.Fn=s;const g=new xa(f,s.BITS);return f.BASE.precompute(8),f}(t,r);return function(e,t){const r=t.Point;return Object.assign({},t,{ExtendedPoint:r,CURVE:e,nBitLength:r.Fn.BITS,nByteLength:r.Fn.BYTES})}(e,Ma(i,n,s))}const Oa=BigInt(0),Ua=BigInt(1),Fa=BigInt(2);function Ba(e){const t=(zo(r=e,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...r}));var r;const{P:n,type:s,adjustScalarBytes:i,powPminus2:o,randomBytes:a}=t,c="x25519"===s;if(!c&&"x448"!==s)throw Error("invalid type");const l=a||Tr,u=c?255:448,h=c?32:56,d=c?BigInt(9):BigInt(5),p=c?BigInt(121665):BigInt(39081),f=c?Fa**BigInt(254):Fa**BigInt(447),g=c?BigInt(8)*Fa**BigInt(251)-Ua:BigInt(4)*Fa**BigInt(445)-Ua,m=f+g+Ua,y=e=>ea(e,n),b=w(d);function w(e){return No(y(e),h)}function v(e,t){const r=function(e,t){Bo("u",e,Oa,n),Bo("scalar",t,f,m);const r=t,s=e;let i=Ua,a=Oa,c=e,l=Ua,h=Oa;for(let e=BigInt(u-1);e>=Oa;e--){const t=r>>e&Ua;h^=t,({x_2:i,x_3:c}=S(h,i,c)),({x_2:a,x_3:l}=S(h,a,l)),h=t;const n=i+a,o=y(n*n),u=i-a,d=y(u*u),f=o-d,g=c+l,m=y((c-l)*n),b=y(g*u),w=m+b,v=m-b;c=y(w*w),l=y(s*y(v*v)),i=y(o*d),a=y(f*(o+y(p*f)))}({x_2:i,x_3:c}=S(h,i,c)),({x_2:a,x_3:l}=S(h,a,l));const d=o(a);return y(i*d)}(function(e){const t=Oo("u coordinate",e,h);return c&&(t[31]&=127),y(Do(t))}(t),function(e){return Do(i(Oo("scalar",e,h)))}(e));if(r===Oa)throw Error("invalid private or public key received");return w(r)}function E(e){return v(e,b)}function S(e,t,r){const n=y(e*(t-r));return{x_2:t=y(t-n),x_3:r=y(r+n)}}const A={secretKey:h,publicKey:h,seed:h},I=(e=l(h))=>(ar(e,A.seed),e);const C={randomSecretKey:I,randomPrivateKey:I};return{keygen(e){const t=I(e);return{secretKey:t,publicKey:E(t)}},getSharedSecret(e,t){return v(e,t)},getPublicKey(e){return E(e)},scalarMult:v,scalarMultBase:E,utils:C,GuBytes:b.slice(),lengths:A}}const qa=BigInt(1),$a=BigInt(2),za=BigInt(3),Ka=BigInt(5),Va=BigInt(8),Ha=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),ja=(()=>({p:Ha,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:Va,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")}))();function Ga(e){const t=BigInt(10),r=BigInt(20),n=BigInt(40),s=BigInt(80),i=Ha,o=e*e%i*e%i,a=ta(o,$a,i)*o%i,c=ta(a,qa,i)*e%i,l=ta(c,Ka,i)*c%i,u=ta(l,t,i)*l%i,h=ta(u,r,i)*u%i,d=ta(h,n,i)*h%i,p=ta(d,s,i)*d%i,f=ta(p,s,i)*d%i,g=ta(f,t,i)*l%i;return{pow_p_5_8:ta(g,$a,i)*e%i,b2:o}}function Wa(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}const Xa=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function Za(e,t){const r=Ha,n=ea(t*t*t,r),s=ea(n*n*t,r);let i=ea(e*n*Ga(e*s).pow_p_5_8,r);const o=ea(t*i*i,r),a=i,c=ea(i*Xa,r),l=o===e,u=o===ea(-e,r),h=o===ea(-e*Xa,r);return l&&(i=a),(u||h)&&(i=c),(ea(i,r)&Ho)===Ho&&(i=ea(-i,r)),{isValid:l||u,value:i}}const Qa=(()=>da(ja.p,{isLE:!0}))(),Ya=(()=>({...ja,Fp:Qa,hash:an,adjustScalarBytes:Wa,uvRatio:Za}))(),Ja=(()=>Na(Ya))(),ec=(()=>{const e=Qa.ORDER;return Ba({P:e,type:"x25519",powPminus2(t){const{pow_p_5_8:r,b2:n}=Ga(t);return ea(ta(r,za,e)*n,e)},adjustScalarBytes:Wa})})();let tc=class extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}},rc=class extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}};var nc={get(e=globalThis){const t=e.crypto;if(null==t?.subtle)throw new rc("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return t}};let sc;const ic=(async()=>{try{return await nc.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function oc(){const e=Ja.utils.randomPrivateKey(),t=Ja.getPublicKey(e),r=function(e,t){const r=new Uint8Array(64);for(let n=0;n<32;n++)r[n]=e[n],r[32+n]=t[n];return r}(e,t);return{privateKey:r,publicKey:t}}async function ac(e,t){return null==sc&&(sc=await ic),sc?async function(e,t){let r;r=64===e.length?e.subarray(0,32):e;const n={crv:"Ed25519",kty:"OKP",x:ln(e.subarray(32),"base64url"),d:ln(r,"base64url"),ext:!0,key_ops:["sign"]},s=await nc.get().subtle.importKey("jwk",n,{name:"Ed25519"},!0,["sign"]),i=await nc.get().subtle.sign({name:"Ed25519"},s,t instanceof Uint8Array?t:t.subarray());return new Uint8Array(i,0,i.byteLength)}(e,t):function(e,t){const r=e.subarray(0,32);return Ja.sign(t instanceof Uint8Array?t:t.subarray(),r)}(e,t)}async function cc(e,t,r){return null==sc&&(sc=await ic),sc?async function(e,t,r){if(e.buffer instanceof ArrayBuffer){const n=await nc.get().subtle.importKey("raw",e.buffer,{name:"Ed25519"},!1,["verify"]);return await nc.get().subtle.verify({name:"Ed25519"},n,t,r instanceof Uint8Array?r:r.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}(e,t,r):function(e,t,r){return Ja.verify(t,r instanceof Uint8Array?r:r.subarray(),e)}(e,t,r)}function lc(e){return null!=e&&("function"==typeof e.then&&"function"==typeof e.catch&&"function"==typeof e.finally)}let uc=class{type="Ed25519";raw;constructor(e){this.raw=pc(e,32)}toMultihash(){return Be.digest(Zc(this))}toCID(){return je.createV1(114,this.toMultihash())}toString(){return he.encode(this.toMultihash().bytes).substring(1)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&Yn(this.raw,e.raw)}verify(e,t,r){r?.signal?.throwIfAborted();const n=cc(this.raw,t,e);return lc(n)?n.then(e=>(r?.signal?.throwIfAborted(),e)):n}};class hc{type="Ed25519";raw;publicKey;constructor(e,t){this.raw=pc(e,64),this.publicKey=new uc(t)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&Yn(this.raw,e.raw)}sign(e,t){t?.signal?.throwIfAborted();const r=ac(this.raw,e);return lc(r)?r.then(e=>(t?.signal?.throwIfAborted(),e)):(t?.signal?.throwIfAborted(),r)}}function dc(e){return e=pc(e,32),new uc(e)}function pc(e,t){if((e=Uint8Array.from(e??[])).length!==t)throw new Pi(`Key must be a Uint8Array of length ${t}, got ${e.length}`);return e}var fc,gc,mc,yc;function bc(e){if(isNaN(e)||e<=0)throw new Pi("random bytes length must be a Number bigger than 0");return Tr(e)}(e=>{e.RSA="RSA",e.Ed25519="Ed25519",e.secp256k1="secp256k1",e.ECDSA="ECDSA"})(fc||(fc={})),(e=>{e[e.RSA=0]="RSA",e[e.Ed25519=1]="Ed25519",e[e.secp256k1=2]="secp256k1",e[e.ECDSA=3]="ECDSA"})(gc||(gc={})),(fc||(fc={})).codec=()=>Yt(gc),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.Type&&(t.uint32(8),fc.codec().encode(e.Type,t)),null!=e.Data&&(t.uint32(18),t.bytes(e.Data)),!1!==r.lengthDelimited&&t.ldelim()},(e,t)=>{const r={},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();switch(t>>>3){case 1:r.Type=fc.codec().decode(e);break;case 2:r.Data=e.bytes();break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(mc||(mc={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.Type&&(t.uint32(8),fc.codec().encode(e.Type,t)),null!=e.Data&&(t.uint32(18),t.bytes(e.Data)),!1!==r.lengthDelimited&&t.ldelim()},(e,t)=>{const r={},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();switch(t>>>3){case 1:r.Type=fc.codec().decode(e);break;case 2:r.Data=e.bytes();break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(yc||(yc={}));let wc=class{type="RSA";jwk;_raw;_multihash;constructor(e,t){this.jwk=e,this._multihash=t}get raw(){return null==this._raw&&(this._raw=function(e){if(null==e.n||null==e.e)throw new Pi("JWK was missing components");return po([vc,ho(po([uo(rt(e.n,"base64url")),uo(rt(e.e,"base64url"))]))]).subarray()}(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return je.createV1(114,this._multihash)}toString(){return he.encode(this.toMultihash().bytes).substring(1)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&Yn(this.raw,e.raw)}verify(e,t,r){return async function(e,t,r,n){const s=await nc.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);n?.signal?.throwIfAborted();const i=await nc.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},s,t,r instanceof Uint8Array?r:r.subarray());return n?.signal?.throwIfAborted(),i}(this.jwk,t,e,r)}};const vc=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function Ec(e,t){if(e.byteLength>=1062)throw new _i("Key size is too large");return function(e,t,r){const n=function(e){const t=oo(e[1],{offset:0});return{kty:"RSA",n:ln(t[0],"base64url"),e:ln(t[1],"base64url")}}(e);if(null==r){r=Ne(18,cn(mc.encode({Type:fc.RSA,Data:t})))}return new wc(n,r)}(oo(e,{offset:0}),e,t)}class Sc extends xr{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,cr(e);const r=Ir(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(r.length>n?e.create().update(r).digest():r);for(let e=0;e<s.length;e++)s[e]^=54;this.iHash.update(s),this.oHash=e.create();for(let e=0;e<s.length;e++)s[e]^=106;this.oHash.update(s),ur(s)}update(e){return lr(this),this.iHash.update(e),this}digestInto(e){lr(this),ar(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:n,destroyed:s,blockLen:i,outputLen:o}=this;return e.finished=n,e.destroyed=s,e.blockLen=i,e.outputLen=o,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ac=(e,t,r)=>new Sc(e,t).update(r).digest();Ac.create=(e,t)=>new Sc(e,t);const Ic=(e,t)=>(e+(e>=0?t:-t)/_c)/t;function Cc(e){if(!["compact","recovered","der"].includes(e))throw Error('Signature format must be "compact", "recovered", or "der"');return e}function xc(e,t){const r={};for(let n of Object.keys(t))r[n]=void 0===e[n]?t[n]:e[n];return To(r.lowS,"lowS"),To(r.prehash,"prehash"),void 0!==r.format&&Cc(r.format),r}const kc={Err:class extends Error{constructor(e=""){super(e)}},_tlv:{encode(e,t){const{Err:r}=kc;if(e<0||e>256)throw new r("tlv.encode: wrong tag");if(1&t.length)throw new r("tlv.encode: unpadded data");const n=t.length/2,s=_o(n);if(s.length/2&128)throw new r("tlv.encode: long form length too big");const i=n>127?_o(s.length/2|128):"";return _o(e)+i+s+t},decode(e,t){const{Err:r}=kc;let n=0;if(e<0||e>256)throw new r("tlv.encode: wrong tag");if(t.length<2||t[n++]!==e)throw new r("tlv.decode: wrong tlv");const s=t[n++];let i=0;if(!!(128&s)){const e=127&s;if(!e)throw new r("tlv.decode(long): indefinite length not supported");if(e>4)throw new r("tlv.decode(long): byte length is too big");const o=t.subarray(n,n+e);if(o.length!==e)throw new r("tlv.decode: length bytes not complete");if(0===o[0])throw new r("tlv.decode(long): zero leftmost byte");for(const e of o)i=i<<8|e;if(n+=e,i<128)throw new r("tlv.decode(long): not minimal encoding")}else i=s;const o=t.subarray(n,n+i);if(o.length!==i)throw new r("tlv.decode: wrong value length");return{v:o,l:t.subarray(n+i)}}},_int:{encode(e){const{Err:t}=kc;if(e<Tc)throw new t("integer: negative integers are not allowed");let r=_o(e);if(8&Number.parseInt(r[0],16)&&(r="00"+r),1&r.length)throw new t("unexpected DER parsing assertion: unpadded hex");return r},decode(e){const{Err:t}=kc;if(128&e[0])throw new t("invalid signature integer: negative");if(0===e[0]&&!(128&e[1]))throw new t("invalid signature integer: unnecessary leading zero");return Lo(e)}},toSig(e){const{Err:t,_int:r,_tlv:n}=kc,s=Oo("signature",e),{v:i,l:o}=n.decode(48,s);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,i),{v:l,l:u}=n.decode(2,c);if(u.length)throw new t("invalid signature: left bytes after parsing");return{r:r.decode(a),s:r.decode(l)}},hexFromSig(e){const{_tlv:t,_int:r}=kc,n=t.encode(2,r.encode(e.r))+t.encode(2,r.encode(e.s));return t.encode(48,n)}},Tc=BigInt(0),Pc=BigInt(1),_c=BigInt(2),Rc=BigInt(3),Lc=BigInt(4);function Dc(e,t){const{BYTES:r}=e;let n;if("bigint"==typeof t)n=t;else{let s=Oo("private key",t);try{n=e.fromBytes(s)}catch(e){throw Error(`invalid private key: expected ui8a of size ${r}, got ${typeof t}`)}}if(!e.isValidNot0(n))throw Error("invalid private key: out of range [1..N-1]");return n}function Mc(e,t={}){const r=Pa("weierstrass",e,t),{Fp:n,Fn:s}=r;let i=r.CURVE;const{h:o,n:a}=i;zo(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:c}=t;if(c&&(!n.is0(i.a)||"bigint"!=typeof c.beta||!Array.isArray(c.basises)))throw Error('invalid endo: expected "beta": bigint and "basises": array');const l=Oc(n,s);function u(){if(!n.isOdd)throw Error("compression is not supported: Field does not have .isOdd()")}const h=t.toBytes||function(e,t,r){const{x:s,y:i}=t.toAffine(),o=n.toBytes(s);if(To(r,"isCompressed"),r){u();return Cr(Nc(!n.isOdd(i)),o)}return Cr(Uint8Array.of(4),o,n.toBytes(i))},d=t.fromBytes||function(e){Po(e,void 0,"Point");const{publicKey:t,publicKeyUncompressed:r}=l,s=e.length,i=e[0],o=e.subarray(1);if(s!==t||2!==i&&3!==i){if(s===r&&4===i){const e=n.BYTES,t=n.fromBytes(o.subarray(0,e)),r=n.fromBytes(o.subarray(e,2*e));if(!f(t,r))throw Error("bad point: is not on curve");return{x:t,y:r}}throw Error(`bad point: got length ${s}, expected compressed=${t} or uncompressed=${r}`)}{const e=n.fromBytes(o);if(!n.isValid(e))throw Error("bad point: is not on curve, wrong x");const t=p(e);let r;try{r=n.sqrt(t)}catch(e){const t=e instanceof Error?": "+e.message:"";throw Error("bad point: is not on curve, sqrt error"+t)}u();return!(1&~i)!==n.isOdd(r)&&(r=n.neg(r)),{x:e,y:r}}};function p(e){const t=n.sqr(e),r=n.mul(t,e);return n.add(n.add(r,n.mul(e,i.a)),i.b)}function f(e,t){const r=n.sqr(t),s=p(e);return n.eql(r,s)}if(!f(i.Gx,i.Gy))throw Error("bad curve params: generator point");const g=n.mul(n.pow(i.a,Rc),Lc),m=n.mul(n.sqr(i.b),BigInt(27));if(n.is0(n.add(g,m)))throw Error("bad curve params: a or b");function y(e,t,r=!1){if(!n.isValid(t)||r&&n.is0(t))throw Error("bad point coordinate "+e);return t}function b(e){if(!(e instanceof A))throw Error("ProjectivePoint expected")}function w(e){if(!c||!c.basises)throw Error("no endo");return function(e,t,r){const[[n,s],[i,o]]=t,a=Ic(o*e,r),c=Ic(-s*e,r);let l=e-a*n-c*i,u=-a*s-c*o;const h=l<Tc,d=u<Tc;h&&(l=-l),d&&(u=-u);const p=$o(Math.ceil(qo(r)/2))+Pc;if(l<Tc||l>=p||u<Tc||u>=p)throw Error("splitScalar (endomorphism): failed, k="+e);return{k1neg:h,k1:l,k2neg:d,k2:u}}(e,c.basises,s.ORDER)}const v=Ko((e,t)=>{const{X:r,Y:s,Z:i}=e;if(n.eql(i,n.ONE))return{x:r,y:s};const o=e.is0();null==t&&(t=o?n.ONE:n.inv(i));const a=n.mul(r,t),c=n.mul(s,t),l=n.mul(i,t);if(o)return{x:n.ZERO,y:n.ZERO};if(!n.eql(l,n.ONE))throw Error("invZ was invalid");return{x:a,y:c}}),E=Ko(e=>{if(e.is0()){if(t.allowInfinityPoint&&!n.is0(e.Y))return;throw Error("bad point: ZERO")}const{x:r,y:s}=e.toAffine();if(!n.isValid(r)||!n.isValid(s))throw Error("bad point: x or y not field elements");if(!f(r,s))throw Error("bad point: equation left != right");if(!e.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0});function S(e,t,r,s,i){return r=new A(n.mul(r.X,e),r.Y,r.Z),t=ya(s,t),r=ya(i,r),t.add(r)}class A{constructor(e,t,r){this.X=y("x",e),this.Y=y("y",t,!0),this.Z=y("z",r),Object.freeze(this)}static CURVE(){return i}static fromAffine(e){const{x:t,y:r}=e||{};if(!e||!n.isValid(t)||!n.isValid(r))throw Error("invalid affine point");if(e instanceof A)throw Error("projective point not allowed");return n.is0(t)&&n.is0(r)?A.ZERO:new A(t,r,n.ONE)}static fromBytes(e){const t=A.fromAffine(d(Po(e,void 0,"point")));return t.assertValidity(),t}static fromHex(e){return A.fromBytes(Oo("pointHex",e))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(e=8,t=!0){return C.createCache(this,e),t||this.multiply(Rc),this}assertValidity(){E(this)}hasEvenY(){const{y:e}=this.toAffine();if(!n.isOdd)throw Error("Field doesn't support isOdd");return!n.isOdd(e)}equals(e){b(e);const{X:t,Y:r,Z:s}=this,{X:i,Y:o,Z:a}=e,c=n.eql(n.mul(t,a),n.mul(i,s)),l=n.eql(n.mul(r,a),n.mul(o,s));return c&&l}negate(){return new A(this.X,n.neg(this.Y),this.Z)}double(){const{a:e,b:t}=i,r=n.mul(t,Rc),{X:s,Y:o,Z:a}=this;let c=n.ZERO,l=n.ZERO,u=n.ZERO,h=n.mul(s,s),d=n.mul(o,o),p=n.mul(a,a),f=n.mul(s,o);return f=n.add(f,f),u=n.mul(s,a),u=n.add(u,u),c=n.mul(e,u),l=n.mul(r,p),l=n.add(c,l),c=n.sub(d,l),l=n.add(d,l),l=n.mul(c,l),c=n.mul(f,c),u=n.mul(r,u),p=n.mul(e,p),f=n.sub(h,p),f=n.mul(e,f),f=n.add(f,u),u=n.add(h,h),h=n.add(u,h),h=n.add(h,p),h=n.mul(h,f),l=n.add(l,h),p=n.mul(o,a),p=n.add(p,p),h=n.mul(p,f),c=n.sub(c,h),u=n.mul(p,d),u=n.add(u,u),u=n.add(u,u),new A(c,l,u)}add(e){b(e);const{X:t,Y:r,Z:s}=this,{X:o,Y:a,Z:c}=e;let l=n.ZERO,u=n.ZERO,h=n.ZERO;const d=i.a,p=n.mul(i.b,Rc);let f=n.mul(t,o),g=n.mul(r,a),m=n.mul(s,c),y=n.add(t,r),w=n.add(o,a);y=n.mul(y,w),w=n.add(f,g),y=n.sub(y,w),w=n.add(t,s);let v=n.add(o,c);return w=n.mul(w,v),v=n.add(f,m),w=n.sub(w,v),v=n.add(r,s),l=n.add(a,c),v=n.mul(v,l),l=n.add(g,m),v=n.sub(v,l),h=n.mul(d,w),l=n.mul(p,m),h=n.add(l,h),l=n.sub(g,h),h=n.add(g,h),u=n.mul(l,h),g=n.add(f,f),g=n.add(g,f),m=n.mul(d,m),w=n.mul(p,w),g=n.add(g,m),m=n.sub(f,m),m=n.mul(d,m),w=n.add(w,m),f=n.mul(g,w),u=n.add(u,f),f=n.mul(v,w),l=n.mul(y,l),l=n.sub(l,f),f=n.mul(y,g),h=n.mul(v,h),h=n.add(h,f),new A(l,u,h)}subtract(e){return this.add(e.negate())}is0(){return this.equals(A.ZERO)}multiply(e){const{endo:r}=t;if(!s.isValidNot0(e))throw Error("invalid scalar: out of range");let n,i;const o=e=>C.cached(this,e,e=>ba(A,e));if(r){const{k1neg:t,k1:s,k2neg:a,k2:c}=w(e),{p:l,f:u}=o(s),{p:h,f:d}=o(c);i=u.add(d),n=S(r.beta,l,h,t,a)}else{const{p:t,f:r}=o(e);n=t,i=r}return ba(A,[n,i])[0]}multiplyUnsafe(e){const{endo:r}=t,n=this;if(!s.isValid(e))throw Error("invalid scalar: out of range");if(e===Tc||n.is0())return A.ZERO;if(e===Pc)return n;if(C.hasCache(this))return this.multiply(e);if(r){const{k1neg:t,k1:s,k2neg:i,k2:o}=w(e),{p1:a,p2:c}=function(e,t,r,n){let s=t,i=e.ZERO,o=e.ZERO;for(;r>ga||n>ga;)r&ma&&(i=i.add(s)),n&ma&&(o=o.add(s)),s=s.double(),r>>=ma,n>>=ma;return{p1:i,p2:o}}(A,n,s,o);return S(r.beta,a,c,t,i)}return C.unsafe(n,e)}multiplyAndAddUnsafe(e,t,r){const n=this.multiplyUnsafe(t).add(e.multiplyUnsafe(r));return n.is0()?void 0:n}toAffine(e){return v(this,e)}isTorsionFree(){const{isTorsionFree:e}=t;return o===Pc||(e?e(A,this):C.unsafe(this,a).is0())}clearCofactor(){const{clearCofactor:e}=t;return o===Pc?this:e?e(A,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(e=!0){return To(e,"isCompressed"),this.assertValidity(),h(A,this,e)}toHex(e=!0){return gr(this.toBytes(e))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(e=!0){return this.toBytes(e)}_setWindowSize(e){this.precompute(e)}static normalizeZ(e){return ba(A,e)}static msm(e,t){return ka(A,s,e,t)}static fromPrivateKey(e){return A.BASE.multiply(Dc(s,e))}}A.BASE=new A(i.Gx,i.Gy,n.ONE),A.ZERO=new A(n.ZERO,n.ONE,n.ZERO),A.Fp=n,A.Fn=s;const I=s.BITS,C=new xa(A,t.endo?Math.ceil(I/2):I);return A.BASE.precompute(8),A}function Nc(e){return Uint8Array.of(e?2:3)}function Oc(e,t){return{secretKey:t.BYTES,publicKey:1+e.BYTES,publicKeyUncompressed:1+2*e.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function Uc(e,t={}){const{Fn:r}=e,n=t.randomBytes||Tr,s=Object.assign(Oc(e.Fp,r),{seed:fa(r.ORDER)});function i(e){try{return!!Dc(r,e)}catch(e){return!1}}function o(e=n(s.seed)){return function(e,t,r=!1){const n=e.length,s=pa(t),i=fa(t);if(n<16||n<i||n>1024)throw Error("expected "+i+"-1024 bytes of input, got "+n);const o=ea(r?Do(e):Lo(e),t-Ho)+Ho;return r?No(o,s):Mo(o,s)}(Po(e,s.seed,"seed"),r.ORDER)}function a(t,n=!0){return e.BASE.multiply(Dc(r,t)).toBytes(n)}function c(t){if("bigint"==typeof t)return!1;if(t instanceof e)return!0;const{secretKey:n,publicKey:i,publicKeyUncompressed:o}=s;if(r.allowedLengths||n===i)return;const a=Oo("key",t).length;return a===i||a===o}const l={isValidSecretKey:i,isValidPublicKey(t,r){const{publicKey:n,publicKeyUncompressed:i}=s;try{const s=t.length;return(!0!==r||s===n)&&((!1!==r||s===i)&&!!e.fromBytes(t))}catch(e){return!1}},randomSecretKey:o,isValidPrivateKey:i,randomPrivateKey:o,normPrivateKeyToScalar(e){return Dc(r,e)},precompute:(t=8,r=e.BASE)=>r.precompute(t,!1)};return Object.freeze({getPublicKey:a,getSharedSecret(t,n,s=!0){if(!0===c(t))throw Error("first arg must be private key");if(!1===c(n))throw Error("second arg must be public key");const i=Dc(r,t);return e.fromHex(n).multiply(i).toBytes(s)},keygen(e){const t=o(e);return{secretKey:t,publicKey:a(t)}},Point:e,utils:l,lengths:s})}function Fc(e,t,r={}){cr(t),zo(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const n=r.randomBytes||Tr,s=r.hmac||((e,...r)=>Ac(t,e,Cr(...r))),{Fp:i,Fn:o}=e,{ORDER:a,BITS:c}=o,{keygen:l,getPublicKey:u,getSharedSecret:h,utils:d,lengths:p}=Uc(e,r),f={prehash:!1,lowS:"boolean"==typeof r.lowS&&r.lowS,format:void 0,extraEntropy:!1},g="compact";function m(e){return e>a>>Pc}function y(e,t){if(!o.isValidNot0(t))throw Error(`invalid signature ${e}: out of range 1..Point.Fn.ORDER`);return t}class b{constructor(e,t,r){this.r=y("r",e),this.s=y("s",t),null!=r&&(this.recovery=r),Object.freeze(this)}static fromBytes(e,t=g){let r;if(function(e,t){Cc(t);const r=p.signature;Po(e,"compact"===t?r:"recovered"===t?r+1:void 0,t+" signature")}(e,t),"der"===t){const{r:t,s:r}=kc.toSig(Po(e));return new b(t,r)}"recovered"===t&&(r=e[0],t="compact",e=e.subarray(1));const n=o.BYTES,s=e.subarray(0,n),i=e.subarray(n,2*n);return new b(o.fromBytes(s),o.fromBytes(i),r)}static fromHex(e,t){return this.fromBytes(Ar(e),t)}addRecoveryBit(e){return new b(this.r,this.s,e)}recoverPublicKey(t){const r=i.ORDER,{r:n,s,recovery:c}=this;if(null==c||![0,1,2,3].includes(c))throw Error("recovery id invalid");if(a*_c<r&&c>1)throw Error("recovery id is ambiguous for h>1 curve");const l=2===c||3===c?n+a:n;if(!i.isValid(l))throw Error("recovery id 2 or 3 invalid");const u=i.toBytes(l),h=e.fromBytes(Cr(Nc(!(1&c)),u)),d=o.inv(l),p=v(Oo("msgHash",t)),f=o.create(-p*d),g=o.create(s*d),m=e.BASE.multiplyUnsafe(f).add(h.multiplyUnsafe(g));if(m.is0())throw Error("point at infinify");return m.assertValidity(),m}hasHighS(){return m(this.s)}toBytes(e=g){if(Cc(e),"der"===e)return Ar(kc.hexFromSig(this));const t=o.toBytes(this.r),r=o.toBytes(this.s);if("recovered"===e){if(null==this.recovery)throw Error("recovery bit must be present");return Cr(Uint8Array.of(this.recovery),t,r)}return Cr(t,r)}toHex(e){return gr(this.toBytes(e))}assertValidity(){}static fromCompact(e){return b.fromBytes(Oo("sig",e),"compact")}static fromDER(e){return b.fromBytes(Oo("sig",e),"der")}normalizeS(){return this.hasHighS()?new b(this.r,o.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return gr(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return gr(this.toBytes("compact"))}}const w=r.bits2int||function(e){if(e.length>8192)throw Error("input is too large");const t=Lo(e),r=8*e.length-c;return r>0?t>>BigInt(r):t},v=r.bits2int_modN||function(e){return o.create(w(e))},E=$o(c);function S(e){return Bo("num < 2^"+c,e,Tc,E),o.toBytes(e)}function A(e,r){return Po(e,void 0,"message"),r?Po(t(e),void 0,"prehashed message"):e}return Object.freeze({keygen:l,getPublicKey:u,getSharedSecret:h,utils:d,lengths:p,Point:e,sign(r,i,a={}){r=Oo("message",r);const{seed:c,k2sig:l}=function(t,r,s){if(["recovered","canonical"].some(e=>e in s))throw Error("sign() legacy options not supported");const{lowS:i,prehash:a,extraEntropy:c}=xc(s,f);t=A(t,a);const l=v(t),u=Dc(o,r),h=[S(u),S(l)];if(null!=c&&!1!==c){const e=!0===c?n(p.secretKey):c;h.push(Oo("extraEntropy",e))}const d=Cr(...h),g=l;return{seed:d,k2sig(t){const r=w(t);if(!o.isValidNot0(r))return;const n=o.inv(r),s=e.BASE.multiply(r).toAffine(),a=o.create(s.x);if(a===Tc)return;const c=o.create(n*o.create(g+a*u));if(c===Tc)return;let l=(s.x===a?0:2)|Number(s.y&Pc),h=c;return i&&m(c)&&(h=o.neg(c),l^=1),new b(a,h,l)}}}(r,i,a),u=function(e,t,r){if("number"!=typeof e||e<2)throw Error("hashLen must be a number");if("number"!=typeof t||t<2)throw Error("qByteLen must be a number");if("function"!=typeof r)throw Error("hmacFn must be a function");const n=e=>new Uint8Array(e),s=e=>Uint8Array.of(e);let i=n(e),o=n(e),a=0;const c=()=>{i.fill(1),o.fill(0),a=0},l=(...e)=>r(o,i,...e),u=(e=n(0))=>{o=l(s(0),e),i=l(),0!==e.length&&(o=l(s(1),e),i=l())},h=()=>{if(a++>=1e3)throw Error("drbg: tried 1000 values");let e=0;const r=[];for(;e<t;){i=l();const t=i.slice();r.push(t),e+=i.length}return Cr(...r)};return(e,t)=>{let r;for(c(),u(e);!(r=t(h()));)u();return c(),r}}(t.outputLen,o.BYTES,s);return u(c,l)},verify(t,r,n,s={}){const{lowS:i,prehash:a,format:c}=xc(s,f);if(n=Oo("publicKey",n),r=A(Oo("message",r),a),"strict"in s)throw Error("options.strict was renamed to lowS");const l=void 0===c?function(e){let t;const r="string"==typeof e||ir(e),n=!r&&null!==e&&"object"==typeof e&&"bigint"==typeof e.r&&"bigint"==typeof e.s;if(!r&&!n)throw Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(n)t=new b(e.r,e.s);else if(r){try{t=b.fromBytes(Oo("sig",e),"der")}catch(e){if(!(e instanceof kc.Err))throw e}if(!t)try{t=b.fromBytes(Oo("sig",e),"compact")}catch(e){return!1}}return t||!1}(t):b.fromBytes(Oo("sig",t),c);if(!1===l)return!1;try{const t=e.fromBytes(n);if(i&&l.hasHighS())return!1;const{r:s,s:a}=l,c=v(r),u=o.inv(a),h=o.create(c*u),d=o.create(s*u),p=e.BASE.multiplyUnsafe(h).add(t.multiplyUnsafe(d));if(p.is0())return!1;return o.create(p.x)===s}catch(e){return!1}},recoverPublicKey(e,t,r={}){const{prehash:n}=xc(r,f);return t=A(t,n),b.fromBytes(e,"recovered").recoverPublicKey(t).toBytes()},Signature:b,hash:t})}function Bc(e){const{CURVE:t,curveOpts:r}=function(e){const t={a:e.a,b:e.b,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},r=e.Fp;let n=e.allowedPrivateKeyLengths?Array.from(new Set(e.allowedPrivateKeyLengths.map(e=>Math.ceil(e/2)))):void 0;return{CURVE:t,curveOpts:{Fp:r,Fn:da(t.n,{BITS:e.nBitLength,allowedLengths:n,modFromBytes:e.wrapPrivateKey}),allowInfinityPoint:e.allowInfinityPoint,endo:e.endo,isTorsionFree:e.isTorsionFree,clearCofactor:e.clearCofactor,fromBytes:e.fromBytes,toBytes:e.toBytes}}}(e),n={hmac:e.hmac,randomBytes:e.randomBytes,lowS:e.lowS,bits2int:e.bits2int,bits2int_modN:e.bits2int_modN};return{CURVE:t,curveOpts:r,hash:e.hash,ecdsaOpts:n}}function qc(e){const{CURVE:t,curveOpts:r,hash:n,ecdsaOpts:s}=Bc(e);return function(e,t){const r=t.Point;return Object.assign({},t,{ProjectivePoint:r,CURVE:Object.assign({},e,ha(r.Fn.ORDER,r.Fn.BITS))})}(e,Fc(Mc(t,r),n,s))}const $c={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},zc={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},Kc=BigInt(2);const Vc=da($c.p,{sqrt(e){const t=$c.p,r=BigInt(3),n=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),l=e*e*e%t,u=l*l*e%t,h=ta(u,r,t)*u%t,d=ta(h,r,t)*u%t,p=ta(d,Kc,t)*l%t,f=ta(p,s,t)*p%t,g=ta(f,i,t)*f%t,m=ta(g,a,t)*g%t,y=ta(m,c,t)*m%t,b=ta(y,a,t)*g%t,w=ta(b,r,t)*u%t,v=ta(w,o,t)*f%t,E=ta(v,n,t)*l%t,S=ta(E,Kc,t);if(!Vc.eql(Vc.sqr(S),e))throw Error("Cannot find square root");return S}}),Hc=function(e,t){const r=t=>qc({...e,hash:t});return{...r(t),create:r}}({...$c,Fp:Vc,lowS:!0,endo:zc},on);let jc=class{type="secp256k1";raw;_key;constructor(e){this._key=function(e){try{return Hc.ProjectivePoint.fromHex(e),e}catch(e){throw new _i(e+"")}}(e),this.raw=function(e){const t=Hc.ProjectivePoint.fromHex(e).toRawBytes(!0);return t}(this._key)}toMultihash(){return Be.digest(Zc(this))}toCID(){return je.createV1(114,this.toMultihash())}toString(){return he.encode(this.toMultihash().bytes).substring(1)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&Yn(this.raw,e.raw)}verify(e,t,r){return function(e,t,r,n){const s=ze.digest(r instanceof Uint8Array?r:r.subarray());if(lc(s))return s.then(({digest:r})=>(n?.signal?.throwIfAborted(),Hc.verify(t,r,e))).catch(e=>{if("AbortError"===e.name)throw e;throw new tc(e+"")});try{return n?.signal?.throwIfAborted(),Hc.verify(t,s.digest,e)}catch(e){throw new tc(e+"")}}(this._key,t,e,r)}};function Gc(e){return new jc(e)}async function Wc(){return async function(){const{privateKey:e,publicKey:t}=oc();return new hc(e,t)}()}function Xc(e,t){const{Type:r,Data:n}=mc.decode(e),s=n??new Uint8Array;switch(r){case fc.RSA:return Ec(s,t);case fc.Ed25519:return dc(s);case fc.secp256k1:return Gc(s);case fc.ECDSA:return Ao(s);default:throw new Qi}}function Zc(e){return mc.encode({Type:fc[e.type],Data:e.raw})}const Qc=Symbol.for("nodejs.util.inspect.custom");let Yc=class{type;multihash;publicKey;string;constructor(e){this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}[vi]=!0;toString(){return null==this.string&&(this.string=he.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return je.createV1(114,this.multihash)}toJSON(){return this.toString()}equals(e){if(null==e)return!1;if(e instanceof Uint8Array)return Yn(this.multihash.bytes,e);if("string"==typeof e)return this.toString()===e;if(null!=e?.toMultihash()?.bytes)return Yn(this.multihash.bytes,e.toMultihash().bytes);throw Error("not valid Id")}[Qc](){return`PeerId(${this.toString()})`}},Jc=class extends Yc{type="RSA";publicKey;constructor(e){super({...e,type:"RSA"}),this.publicKey=e.publicKey}},el=class extends Yc{type="Ed25519";publicKey;constructor(e){super({...e,type:"Ed25519"}),this.publicKey=e.publicKey}},tl=class extends Yc{type="secp256k1";publicKey;constructor(e){super({...e,type:"secp256k1"}),this.publicKey=e.publicKey}};class rl{type="url";multihash;publicKey;url;constructor(e){this.url=e.toString(),this.multihash=Be.digest(rt(this.url))}[Qc](){return`PeerId(${this.url})`}[vi]=!0;toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return je.createV1(2336,this.toMultihash())}toJSON(){return this.toString()}equals(e){return null!=e&&(e instanceof Uint8Array&&(e=ln(e)),e.toString()===this.toString())}}function nl(e){let t;if("1"!==e.charAt(0)&&"Q"!==e.charAt(0)){if(e.startsWith("k51qzi5uqu5")||e.startsWith("kzwfwjn5ji4")||e.startsWith("k2k4r8")||e.startsWith("bafz"))return ol(je.parse(e));throw new Pi('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return t=Oe(he.decode("z"+e)),il(t)}function sl(e){if("Ed25519"===e.type)return new el({multihash:e.toCID().multihash,publicKey:e});if("secp256k1"===e.type)return new tl({multihash:e.toCID().multihash,publicKey:e});if("RSA"===e.type)return new Jc({multihash:e.toCID().multihash,publicKey:e});throw new Qi}function il(e){if(function(e){return e.code===ze.code}(e))return new Jc({multihash:e});if(function(e){return e.code===Be.code}(e))try{const t=function(e){const{Type:t,Data:r}=mc.decode(e.digest),n=r??new Uint8Array;switch(t){case fc.Ed25519:return dc(n);case fc.secp256k1:return Gc(n);case fc.ECDSA:return Ao(n);default:throw new Qi}}(e);if("Ed25519"===t.type)return new el({multihash:e,publicKey:t});if("secp256k1"===t.type)return new tl({multihash:e,publicKey:t})}catch(t){const r=ln(e.digest);return new rl(new URL(r))}throw new $i("Supplied PeerID Multihash is invalid")}function ol(e){if(null==e?.multihash||null==e.version||1===e.version&&114!==e.code&&2336!==e.code)throw new qi("Supplied PeerID CID is invalid");if(2336===e.code){const t=ln(e.multihash.digest);return new rl(new URL(t))}return il(e.multihash)}class al extends Error{static name="InvalidMultiaddrError";name="InvalidMultiaddrError"}class cl extends Error{static name="ValidationError";name="ValidationError"}class ll extends Error{static name="InvalidParametersError";name="InvalidParametersError"}class ul extends Error{static name="UnknownProtocolError";name="UnknownProtocolError"}const hl=new class{index=0;input="";new(e){return this.index=0,this.input=e,this}readAtomically(e){const t=this.index,r=e();return void 0===r&&(this.index=t),r}parseWith(e){const t=e();if(this.index===this.input.length)return t}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically(()=>{const t=this.readChar();if(t===e)return t})}readSeparator(e,t,r){return this.readAtomically(()=>{if(!(t>0&&void 0===this.readGivenChar(e)))return r()})}readNumber(e,t,r,n){return this.readAtomically(()=>{let s=0,i=0;const o=this.peekChar();if(void 0===o)return;const a="0"===o,c=2**(8*n)-1;for(;;){const r=this.readAtomically(()=>{const t=this.readChar();if(void 0===t)return;const r=Number.parseInt(t,e);return Number.isNaN(r)?void 0:r});if(void 0===r)break;if(s*=e,s+=r,s>c)return;if(i+=1,void 0!==t&&i>t)return}return 0===i||!r&&a&&i>1?void 0:s})}readIPv4Addr(){return this.readAtomically(()=>{const e=new Uint8Array(4);for(let t=0;t<e.length;t++){const r=this.readSeparator(".",t,()=>this.readNumber(10,3,!1,1));if(void 0===r)return;e[t]=r}return e})}readIPv6Addr(){const e=e=>{for(let t=0;t<e.length/2;t++){const r=2*t;if(t<e.length-3){const n=this.readSeparator(":",t,()=>this.readIPv4Addr());if(void 0!==n)return e[r]=n[0],e[r+1]=n[1],e[r+2]=n[2],e[r+3]=n[3],[r+4,!0]}const n=this.readSeparator(":",t,()=>this.readNumber(16,4,!0,2));if(void 0===n)return[r,!1];e[r]=n>>8,e[r+1]=255&n}return[e.length,!1]};return this.readAtomically(()=>{const t=new Uint8Array(16),[r,n]=e(t);if(16===r)return t;if(n)return;if(void 0===this.readGivenChar(":"))return;if(void 0===this.readGivenChar(":"))return;const s=new Uint8Array(14),i=16-(r+2),[o]=e(s.subarray(0,i));return t.set(s.subarray(0,o),16-o),t})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}};function dl(e){if(!(e.length>15))return hl.new(e).parseWith(()=>hl.readIPv4Addr())}function pl(e){if(e.includes("%")&&(e=e.split("%")[0]),!(e.length>45))return hl.new(e).parseWith(()=>hl.readIPv6Addr())}function fl(e,t=!1){if(e.includes("%")&&(e=e.split("%")[0]),e.length>45)return;const r=hl.new(e).parseWith(()=>hl.readIPAddr());return r?t&&4===r.length?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,r[0],r[1],r[2],r[3]]):r:void 0}function gl(e){return!!dl(e)}function ml(e){return!!pl(e)}const yl=41,bl=42;function wl(e){return t=>ln(t,e)}function vl(e){return t=>rt(t,e)}function El(e){return new DataView(e.buffer).getUint16(e.byteOffset).toString()}function Sl(e){const t=new ArrayBuffer(2);return new DataView(t).setUint16(0,"string"==typeof e?parseInt(e):e),new Uint8Array(t)}function Al(e){const t=e.subarray(0,e.length-2),r=e.subarray(e.length-2);return`${ln(t,"base32")}:${El(r)}`}const Il=e=>{e=e.toString().trim();const t=new Uint8Array(4);return e.split(/\./g).forEach((e,r)=>{const n=parseInt(e,10);if(isNaN(n)||n<0||n>255)throw new al("Invalid byte value in IP address");t[r]=n}),t};const Cl=Object.values(Qe).map(e=>e.decoder),xl=(()=>{let e=Cl[0].or(Cl[1]);return Cl.slice(2).forEach(t=>e=e.or(t)),e})();const kl=function(...e){return t=>{for(const r of e)r(t)}}(function(e){if(parseInt(e).toString()!==e)throw new cl("Value must be an integer")},function(e){if(e<0)throw new cl("Value must be a positive integer, or zero")},(Tl=65535,e=>{if(e>Tl)throw new cl("Value must be smaller than or equal to "+Tl)}));var Tl;const Pl=-1;const _l=new class{protocolsByCode=new Map;protocolsByName=new Map;getProtocol(e){let t;if(t="string"==typeof e?this.protocolsByName.get(e):this.protocolsByCode.get(e),null==t)throw new ul(`Protocol ${e} was unknown`);return t}addProtocol(e){this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),e.aliases?.forEach(t=>{this.protocolsByName.set(t,e)})}removeProtocol(e){const t=this.protocolsByCode.get(e);null!=t&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),t.aliases?.forEach(e=>{this.protocolsByName.delete(e)}))}},Rl=[{code:4,name:"ip4",size:32,valueToBytes:Il,bytesToValue(e){if(4!==e.byteLength)throw new al("IPv4 address was incorrect length");const t=[];for(let r=0;r<e.byteLength;r++)t.push(e[r]);return t.join(".")},validate(e){if(!gl(e))throw new cl(`Invalid IPv4 address "${e}"`)}},{code:6,name:"tcp",size:16,valueToBytes:Sl,bytesToValue:El,validate:kl},{code:273,name:"udp",size:16,valueToBytes:Sl,bytesToValue:El,validate:kl},{code:33,name:"dccp",size:16,valueToBytes:Sl,bytesToValue:El,validate:kl},{code:yl,name:"ip6",size:128,valueToBytes(e){let t=0;const r=(e=e.toString().trim()).split(":",8);let n;for(n=0;n<r.length;n++){let e;gl(r[n])&&(e=Il(r[n]),r[n]=ln(e.subarray(0,2),"base16")),null!=e&&++n<8&&r.splice(n,0,ln(e.subarray(2,4),"base16"))}if(""===r[0])for(;r.length<8;)r.unshift("0");else if(""===r[r.length-1])for(;r.length<8;)r.push("0");else if(r.length<8){for(n=0;n<r.length&&""!==r[n];n++);const e=[n,1];for(n=9-r.length;n>0;n--)e.push("0");r.splice.apply(r,e)}const s=new Uint8Array(t+16);for(n=0;n<r.length;n++){""===r[n]&&(r[n]="0");const e=parseInt(r[n],16);if(isNaN(e)||e<0||e>65535)throw new al("Invalid byte value in IP address");s[t++]=e>>8&255,s[t++]=255&e}return s},bytesToValue(e){if(16!==e.byteLength)throw new al("IPv6 address was incorrect length");const t=[];for(let r=0;r<e.byteLength;r+=2){const n=e[r],s=e[r+1],i=`${n.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;t.push(i)}const r=t.join(":");try{const e=new URL(`http://[${r}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new al(`Invalid IPv6 address "${r}"`)}},stringToValue(e){try{const t=new URL(`http://[${e}]`);return t.hostname.substring(1,t.hostname.length-1)}catch{throw new al(`Invalid IPv6 address "${e}"`)}},validate(e){if(!ml(e))throw new cl(`Invalid IPv6 address "${e}"`)}},{code:bl,name:"ip6zone",size:Pl},{code:43,name:"ipcidr",size:8,bytesToValue:wl("base10"),valueToBytes:vl("base10")},{code:53,name:"dns",size:Pl,resolvable:!0},{code:54,name:"dns4",size:Pl,resolvable:!0},{code:55,name:"dns6",size:Pl,resolvable:!0},{code:56,name:"dnsaddr",size:Pl,resolvable:!0},{code:132,name:"sctp",size:16,valueToBytes:Sl,bytesToValue:El,validate:kl},{code:301,name:"udt"},{code:302,name:"utp"},{code:400,name:"unix",size:Pl,path:!0,stringToValue(e){return decodeURIComponent(e)},valueToString(e){return encodeURIComponent(e)}},{code:421,name:"p2p",aliases:["ipfs"],size:Pl,bytesToValue:wl("base58btc"),valueToBytes(e){return e.startsWith("Q")||e.startsWith("1")?vl("base58btc")(e):je.parse(e).multihash.bytes}},{code:444,name:"onion",size:96,bytesToValue:Al,valueToBytes(e){const t=e.split(":");if(2!==t.length)throw Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(16!==t[0].length)throw Error(`failed to parse onion addr: ${t[0]} not a Tor onion address.`);const r=rt(t[0],"base32"),n=parseInt(t[1],10);if(n<1||n>65536)throw Error("Port number is not in range(1, 65536)");const s=Sl(n);return Qn([r,s],r.length+s.length)}},{code:445,name:"onion3",size:296,bytesToValue:Al,valueToBytes(e){const t=e.split(":");if(2!==t.length)throw Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(56!==t[0].length)throw Error(`failed to parse onion addr: ${t[0]} not a Tor onion3 address.`);const r=Y.decode("b"+t[0]),n=parseInt(t[1],10);if(n<1||n>65536)throw Error("Port number is not in range(1, 65536)");const s=Sl(n);return Qn([r,s],r.length+s.length)}},{code:446,name:"garlic64",size:Pl},{code:447,name:"garlic32",size:Pl},{code:448,name:"tls"},{code:449,name:"sni",size:Pl},{code:454,name:"noise"},{code:460,name:"quic"},{code:461,name:"quic-v1"},{code:465,name:"webtransport"},{code:466,name:"certhash",size:Pl,bytesToValue:function(e){return t=>e.encoder.encode(t)}(me),valueToBytes(e){return xl.decode(e)}},{code:480,name:"http"},{code:481,name:"http-path",size:Pl,stringToValue(e){return"/"+decodeURIComponent(e)},valueToString(e){return encodeURIComponent(e.substring(1))}},{code:443,name:"https"},{code:477,name:"ws"},{code:478,name:"wss"},{code:479,name:"p2p-websocket-star"},{code:277,name:"p2p-stardust"},{code:275,name:"p2p-webrtc-star"},{code:276,name:"p2p-webrtc-direct"},{code:280,name:"webrtc-direct"},{code:281,name:"webrtc"},{code:290,name:"p2p-circuit"},{code:777,name:"memory",size:Pl}];function Ll(e,t,r){return null==e.size||0===e.size?0:e.size>0?e.size/8:d(t,r)}Rl.forEach(e=>{_l.addProtocol(e)});const Dl=Symbol.for("nodejs.util.inspect.custom"),Ml=Symbol.for("@multiformats/multiaddr"),Nl=[53,54,55,56];class Ol extends Error{constructor(e="No available resolver"){super(e),this.name="NoAvailableResolverError"}}function Ul(e){if(null==e&&(e="/"),Xl(e))return e.getComponents();if(e instanceof Uint8Array)return function(e){const t=[];let r=0;for(;r<e.length;){const n=d(e,r),s=_l.getProtocol(n),i=c(n),o=Ll(s,e,r+i);let a=0;o>0&&s.size===Pl&&(a=c(o));const l=i+a+o,u={code:n,name:s.name,bytes:e.subarray(r,r+l)};if(o>0){const t=r+i+a,n=e.subarray(t,t+o);u.value=s.bytesToValue?.(n)??ln(n)}t.push(u),r+=l}return t}(e);if("string"==typeof e)return""===(e=e.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""))&&(e="/"),function(e){if("/"!==e.charAt(0))throw new al('String multiaddr must start with "/"');const t=[];let r="protocol",n="",s="";for(let i=1;i<e.length;i++){const o=e.charAt(i);"/"!==o&&("protocol"===r?s+=e.charAt(i):n+=e.charAt(i));const a=i===e.length-1;if("/"===o||a){const e=_l.getProtocol(s);if("protocol"===r){if(null==e.size||0===e.size){t.push({code:e.code,name:e.name}),n="",s="",r="protocol";continue}if(a)throw new al(`Component ${s} was missing value`);r="value"}else if("value"===r){const i={code:e.code,name:e.name};if(null!=e.size&&0!==e.size){if(""===n)throw new al(`Component ${s} was missing value`);i.value=e.stringToValue?.(n)??n}t.push(i),n="",s="",r="protocol"}}}if(""!==s&&""!==n)throw new al("Incomplete multiaddr");return t}(e);if(Array.isArray(e))return e;throw new al("Must be a string, Uint8Array, Component[], or another Multiaddr")}class Fl{[Ml]=!0;#t;#r;#n;constructor(e="/",t={}){this.#t=Ul(e),!1!==t.validate&&function(e){e.getComponents().forEach(e=>{const t=_l.getProtocol(e.code);null!=e.value&&t.validate?.(e.value)})}(this)}get bytes(){return null==this.#n&&(this.#n=function(e){let t=0;const r=[];for(const n of e){if(null==n.bytes){const e=_l.getProtocol(n.code),t=c(n.code);let r,s=0,i=0;null!=n.value&&(r=e.valueToBytes?.(n.value)??rt(n.value),s=r.byteLength,e.size===Pl&&(i=c(s)));const o=new Uint8Array(t+i+s);let a=0;l(n.code,o,a),a+=t,null!=r&&(e.size===Pl&&(l(s,o,a),a+=i),o.set(r,a)),n.bytes=o}r.push(n.bytes),t+=n.bytes.byteLength}return Qn(r,t)}(this.#t)),this.#n}toString(){return null==this.#r&&(this.#r="/"+this.#t.flatMap(e=>{if(null==e.value)return e.name;const t=_l.getProtocol(e.code);if(null==t)throw new al("Unknown protocol code "+e.code);return[e.name,t.valueToString?.(e.value)??e.value]}).join("/")),this.#r}toJSON(){return this.toString()}toOptions(){let e,t,r,n,s="";for(const{code:i,name:o,value:a}of this.#t)i===bl&&(s="%"+(a??"")),Nl.includes(i)&&(t="tcp",n=443,r=`${a??""}${s}`,e=55===i?6:4),6!==i&&273!==i||(t="tcp"===o?"tcp":"udp",n=parseInt(a??"")),4!==i&&i!==yl||(t="tcp",r=`${a??""}${s}`,e=i===yl?6:4);if(null==e||null==t||null==r||null==n)throw Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:r,transport:t,port:n}}getComponents(){return[...this.#t]}protos(){return this.#t.map(({code:e,value:t})=>{const r=_l.getProtocol(e);return{code:e,size:r.size??0,name:r.name,resolvable:!!r.resolvable,path:!!r.path}})}protoCodes(){return this.#t.map(({code:e})=>e)}protoNames(){return this.#t.map(({name:e})=>e)}tuples(){return this.#t.map(({code:e,value:t})=>{if(null==t)return[e];const r=_l.getProtocol(e),n=[e];return null!=t&&n.push(r.valueToBytes?.(t)??rt(t)),n})}stringTuples(){return this.#t.map(({code:e,value:t})=>null==t?[e]:[e,t])}encapsulate(e){const t=new Fl(e);return new Fl([...this.#t,...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),r=this.toString(),n=r.lastIndexOf(t);if(n<0)throw new ll(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new Fl(r.slice(0,n),{validate:!1})}decapsulateCode(e){let t;for(let r=this.#t.length-1;r>-1;r--)if(this.#t[r].code===e){t=r;break}return new Fl(this.#t.slice(0,t),{validate:!1})}getPeerId(){try{let e=[];this.#t.forEach(({code:t,value:r})=>{421===t&&e.push([t,r]),290===t&&(e=[])});const t=e.pop();if(null!=t?.[1]){const e=t[1];return"Q"===e[0]||"1"===e[0]?ln(he.decode("z"+e),"base58btc"):ln(je.parse(e).multihash.bytes,"base58btc")}return null}catch(e){return null}}getPath(){for(const e of this.#t){if(_l.getProtocol(e.code).path)return e.value??null}return null}equals(e){return Yn(this.bytes,e.bytes)}async resolve(e){const t=this.protos().find(e=>e.resolvable);if(null==t)return[this];const r=Wl.get(t.name);if(null==r)throw new Ol("no available resolver for "+t.name);return(await r(this,e)).map(e=>Zl(e))}nodeAddress(){const e=this.toOptions();if("tcp"!==e.transport&&"udp"!==e.transport)throw Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(){return 2===this.#t.length&&((4===this.#t[0].code||this.#t[0].code===yl)&&(6===this.#t[1].code||273===this.#t[1].code))}[Dl](){return`Multiaddr(${this.toString()})`}}const Bl=4,ql=16,$l=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function zl(e,t){t.length===ql&&e.length===Bl&&function(e,t,r){let n=0;for(const s of e)if(!(n<t)){if(n>r)break;if(255!==s)return!1;n++}return!0}(t,0,11)&&(t=t.slice(12)),t.length===Bl&&e.length===ql&&function(e,t,r,n){let s=0;for(const i of e)if(!(s<r)){if(s>n)break;if(i!==t[s])return!1;s++}return!0}(e,$l,0,11)&&(e=e.slice(12));const r=e.length;if(r!=t.length)throw Error("Failed to mask ip");const n=new Uint8Array(r);for(let s=0;s<r;s++)n[s]=e[s]&t[s];return n}function Kl(e,t){if(t!==8*Bl&&t!==8*ql)throw Error("Invalid CIDR mask");if(e<0||e>t)throw Error("Invalid CIDR mask");const r=t/8,n=new Uint8Array(r);for(let t=0;t<r;t++)e>=8?(n[t]=255,e-=8):(n[t]=255-(255>>e),e=0);return n}class Vl{constructor(e,t){if(null==t)({network:this.network,mask:this.mask}=function(e){const[t,r]=e.split("/");if(!t||!r)throw Error("Failed to parse given CIDR: "+e);let n=Bl,s=dl(t);if(null==s&&(n=ql,s=pl(t),null==s))throw Error("Failed to parse given CIDR: "+e);const i=parseInt(r,10);if(Number.isNaN(i)||(i+"").length!==r.length||i<0||i>8*n)throw Error("Failed to parse given CIDR: "+e);const o=Kl(i,8*n);return{network:zl(s,o),mask:o}}(e));else{const r=fl(e);if(null==r)throw Error("Failed to parse network");const n=parseInt(t+="",10);if(Number.isNaN(n)||(n+"").length!==t.length||n<0||n>8*r.length){const e=fl(t);if(null==e)throw Error("Failed to parse mask");this.mask=e}else this.mask=Kl(n,8*r.length);this.network=zl(r,this.mask)}}contains(e){return function(e,t){if("string"==typeof t&&(t=fl(t)),null==t)throw Error("Invalid ip");if(t.length!==e.network.length)return!1;for(let r=0;r<t.length;r++)if((e.network[r]&e.mask[r])!==(t[r]&e.mask[r]))return!1;return!0}({network:this.network,mask:this.mask},e)}toString(){const e=function(e){let t=0;for(let[r,n]of e.entries()){if(255!==n){for(;128&n;)t++,n<<=1;if(128&n)return-1;for(let t=r+1;t<e.length;t++)if(0!=e[t])return-1;break}t+=8}return t}(this.mask),t=-1!==e?e+"":function(e){let t="0x";for(const r of e)t+=(r>>4).toString(16)+(15&r).toString(16);return t}(this.mask);return function(e){switch(e.length){case Bl:return e.join(".");case ql:{const t=[];for(let r=0;r<e.length;r++)r%2==0&&t.push(e[r].toString(16).padStart(2,"0")+e[r+1].toString(16).padStart(2,"0"));return t.join(":")}default:throw Error("Invalid ip length")}}(this.network)+"/"+t}}function Hl(e,t){return new Vl(e).contains(t)}function jl(e,t){const r=_l.getProtocol(e);return r.bytesToValue?.(t)??ln(t,"base16")}function Gl(e,t){const r=_l.getProtocol(e);return r.valueToBytes?.(t)??rt(t,"base16")}const Wl=new Map;function Xl(e){return!!e?.[Ml]}function Zl(e){return new Fl(e)}function Ql(e){const t=_l.getProtocol(e);return{code:t.code,size:t.size??0,name:t.name,resolvable:!!t.resolvable,path:!!t.path}}const Yl=e=>{if(!e)return-1;try{const t=e.metadata.get("ping");return t?Number(dn(t)):-1}catch(e){return-1}},Jl=new On("connection-manager");class eu{keepAliveManager;discoveryDialer;dialer;shardReader;networkMonitor;connectionLimiter;options;libp2p;constructor(e){this.libp2p=e.libp2p,this.options={maxBootstrapPeers:3,maxConnections:10,pingKeepAlive:300,relayKeepAlive:300,enableAutoRecovery:true,maxDialingPeers:3,failedDialCooldown:60,dialCooldown:10,...e.config},this.keepAliveManager=new pi({relay:e.relay,libp2p:e.libp2p,networkConfig:e.networkConfig,options:{pingKeepAlive:this.options.pingKeepAlive,relayKeepAlive:this.options.relayKeepAlive}}),this.shardReader=new mi({libp2p:e.libp2p,networkConfig:e.networkConfig}),this.dialer=new ci({libp2p:e.libp2p,shardReader:this.shardReader,options:this.options}),this.discoveryDialer=new ui({libp2p:e.libp2p,dialer:this.dialer}),this.networkMonitor=new fi({libp2p:e.libp2p,events:e.events}),this.connectionLimiter=new oi({libp2p:e.libp2p,events:e.events,networkMonitor:this.networkMonitor,dialer:this.dialer,options:this.options})}start(){this.dialer.start(),this.networkMonitor.start(),this.discoveryDialer.start(),this.keepAliveManager.start(),this.connectionLimiter.start()}stop(){this.dialer.stop(),this.networkMonitor.stop(),this.discoveryDialer.stop(),this.keepAliveManager.stop(),this.connectionLimiter.stop()}isConnected(){return this.networkMonitor.isConnected()}async dial(e,t){const r=Ei(n=e)?n:Zl(n);var n;Jl.info(`Dialing peer ${r.toString()} with protocols ${t}`);const s=await this.libp2p.dialProtocol(r,t);return Jl.info(`Dialed peer ${r.toString()} with protocols ${t}`),s}async hangUp(e){const t=Ei(r=e)?r:nl(Zl(r).getPeerId());var r;try{return Jl.info("Dropping connection with peer "+t.toString()),await this.libp2p.hangUp(t),Jl.info("Dropped connection with peer "+t.toString()),!0}catch(e){return Jl.error(`Error dropping connection with peer ${t.toString()} - ${e}`),!1}}async getConnectedPeers(e){const t=this.libp2p.getPeers();if(Jl.info("Getting connected peers for codec "+e),0===t.length)return Jl.info("No connected peers"),[];const r=(await Promise.all(t.map(async e=>{try{return await this.libp2p.peerStore.get(e)}catch(e){return null}}))).filter(e=>!!e).filter(t=>!e||t.protocols.includes(e)).sort((e,t)=>Yl(e)-Yl(t));return Jl.info(`Found ${r.length} connected peers for codec ${e}`),r}async hasShardInfo(e){return this.shardReader.hasShardInfo(e)}async isPeerOnTopic(e,t){return this.shardReader.isPeerOnTopic(e,t)}async isPeerOnShard(e,t){return this.shardReader.isPeerOnShard(e,t)}}const tu=new On("metadata"),ru="/vac/waku/metadata/1.0.0";class nu{clusterId;streamManager;libp2pComponents;handshakesConfirmed=new Map;multicodec=ru;constructor(e,t){this.clusterId=e,this.streamManager=new Ds(ru,t),this.libp2pComponents=t,t.registrar.handle(ru,e=>{this.onRequest(e)})}async query(e){const t=Gt.encode({clusterId:this.clusterId,shards:[]});if(!await this.libp2pComponents.peerStore.get(e))return{shardInfo:null,error:Hn.NO_PEER_AVAILABLE};const r=await this.streamManager.getStream(e);if(!r)return tu.error("Failed to get a stream for remote peer:"+e.toString()),{shardInfo:null,error:Hn.NO_STREAM_AVAILABLE};const n=await Cs([t],is,r,ds,async e=>await Zn(e)),{error:s,shardInfo:i}=this.decodeMetadataResponse(n);return s?{shardInfo:null,error:s}:(await this.savePeerShardInfo(e,i),{shardInfo:i,error:null})}async confirmOrAttemptHandshake(e){const t=this.handshakesConfirmed.get(e.toString());return t?{shardInfo:t,error:null}:await this.query(e)}async onRequest(e){try{const{stream:t,connection:r}=e,n=Wt.encode({clusterId:this.clusterId,shards:[]}),s=await Cs([n],is,t,ds,async e=>await Zn(e)),{error:i,shardInfo:o}=this.decodeMetadataResponse(s);if(i)return;await this.savePeerShardInfo(r.remotePeer,o)}catch(e){tu.error("Error handling metadata request",e)}}decodeMetadataResponse(e){const t=new rs;e.forEach(e=>{t.append(e)});const r=Wt.decode(t);return r?{shardInfo:r,error:null}:(tu.error("Error decoding metadata response"),{shardInfo:null,error:Hn.DECODE_FAILED})}async savePeerShardInfo(e,t){await this.libp2pComponents.peerStore.merge(e,{metadata:{shardInfo:An(t)}}),this.handshakesConfirmed.set(e.toString(),t)}}function su(e){return t=>new nu(e,t)}function iu(e,t){const r=pn(e),n=pn(t.contentTopic),s=function(e){if(!e)return;let t;t="bigint"==typeof e?e:1000000n*BigInt(e.valueOf());return function(e){const t=new ArrayBuffer(8),r=new DataView(t);return"number"==typeof e?r.setFloat64(0,e,!1):r.setBigInt64(0,e,!1),new Uint8Array(t)}(t)}(t.timestamp),i=fn([r,t.payload,n,t.meta,s].filter(rr));return cn(i)}function ou(e,t){const r=iu(e,t);return hn(r)}const au=new On("peer-manager");var cu;(e=>{e.Connect="filter:connect",e.Disconnect="filter:disconnect"})(cu||(cu={}));class lu{events=new Yi;numPeersToUse;libp2p;connectionManager;lockedPeers=new Set;unlockedPeers=new Map;constructor(e){this.onConnected=this.onConnected.bind(this),this.onDisconnected=this.onDisconnected.bind(this),this.numPeersToUse=e?.config?.numPeersToUse||2,this.libp2p=e.libp2p,this.connectionManager=e.connectionManager}start(){this.libp2p.addEventListener("peer:identify",this.onConnected),this.libp2p.addEventListener("peer:disconnect",this.onDisconnected)}stop(){this.libp2p.removeEventListener("peer:identify",this.onConnected),this.libp2p.removeEventListener("peer:disconnect",this.onDisconnected)}async getPeers(e){au.info(`Getting peers for protocol: ${e.protocol}, pubsubTopic: ${e.pubsubTopic}`);const t=await this.connectionManager.getConnectedPeers();au.info(`Found ${t.length} connected peers`);let r=[];for(const n of t){const t=this.hasPeerProtocol(n,e.protocol),s=await this.connectionManager.isPeerOnTopic(n.id,e.pubsubTopic),i=this.isPeerAvailableForUse(n.id);t&&s&&i&&(r.push(n),au.info(`Peer ${n.id} qualifies for protocol ${e.protocol}`))}const n=r.filter(e=>this.isPeerLocked(e.id));if(au.info(`Found ${n.length} locked peers out of ${r.length} qualifying peers`),n.length>=this.numPeersToUse){const e=n.slice(0,this.numPeersToUse).map(e=>e.id);return au.info(`Using ${e.length} locked peers: ${e.map(e=>e.toString())}`),e}const s=r.filter(e=>!this.isPeerLocked(e.id));au.info(`Found ${s.length} unlocked peers, need ${this.numPeersToUse-n.length} more`),r=[...n,...s].slice(0,this.numPeersToUse).map(e=>(this.lockPeer(e.id),e));const i=r.map(e=>e.id);return au.info(`Selected ${i.length} peers: ${i.map(e=>e.toString())}`),i}async renewPeer(e,t){au.info(`Renewing peer ${e} for protocol: ${t.protocol}, pubsubTopic: ${t.pubsubTopic}`);const r=(await this.connectionManager.getConnectedPeers()).find(t=>t.id.equals(e));r?(au.info(`Found peer ${e} in connected peers, unlocking and getting new peers`),this.unlockPeer(r.id),await this.getPeers(t)):au.warn(`Cannot renew peer:${e}, no connection to the peer.`)}async isPeerOnPubsub(e,t){return!await this.connectionManager.hasShardInfo(e)||this.connectionManager.isPeerOnTopic(e,t)}async onConnected(e){const t=e.detail;t.protocols.includes(this.matchProtocolToCodec(Vn.Filter))&&this.dispatchFilterPeerConnect(t.peerId)}async onDisconnected(e){const t=e.detail;try{const e=await this.libp2p.peerStore.get(t);this.hasPeerProtocol(e,Vn.Filter)&&this.dispatchFilterPeerDisconnect(e.id)}catch(e){au.error("Failed to dispatch Filter disconnect event:"+e)}}hasPeerProtocol(e,t){return e.protocols.includes(this.matchProtocolToCodec(t))}lockPeer(e){au.info("Locking peer "+e),this.lockedPeers.add(e.toString()),this.libp2p.getConnections().filter(t=>t.remotePeer.equals(e)).forEach(e=>e.tags.push(Gn)),this.unlockedPeers.delete(e.toString())}isPeerLocked(e){return this.lockedPeers.has(e.toString())}unlockPeer(e){au.info("Unlocking peer "+e),this.lockedPeers.delete(e.toString()),this.libp2p.getConnections().filter(t=>t.remotePeer.equals(e)).forEach(e=>{e.tags=e.tags.filter(e=>e!==Gn)}),this.unlockedPeers.set(e.toString(),Date.now())}isPeerAvailableForUse(e){const t=this.unlockedPeers.get(e.toString());if(!t)return!0;const r=new Date(t).getTime();return Date.now()-r>=1e4}dispatchFilterPeerConnect(e){this.events.dispatchEvent(new CustomEvent(cu.Connect,{detail:e}))}dispatchFilterPeerDisconnect(e){this.events.dispatchEvent(new CustomEvent(cu.Disconnect,{detail:e}))}matchProtocolToCodec(e){return{[Vn.Filter]:Vs,[Vn.LightPush]:Xs,[Vn.Store]:ni,[Vn.Relay]:""}[e]}}class uu{ttlMs;cleanupIntervalId=null;entryTimestamps=new Map;constructor(e,t=5e3){this.ttlMs=e,this.startCleanupInterval(t)}dispose(){null!==this.cleanupIntervalId&&(clearInterval(this.cleanupIntervalId),this.cleanupIntervalId=null),this.entryTimestamps.clear()}add(e){return this.entryTimestamps.set(e,Date.now()),this}has(e){return this.entryTimestamps.has(e)}startCleanupInterval(e){this.cleanupIntervalId=setInterval(()=>{this.removeExpiredEntries()},e)}removeExpiredEntries(){const e=Date.now();for(const[t,r]of this.entryTimestamps.entries())e-r>this.ttlMs&&this.entryTimestamps.delete(t)}}const hu=new On("sdk:filter-subscription");class du{pubsubTopic;protocol;peerManager;config;isStarted=!1;inProgress=!1;peers=new Map;peerFailures=new Map;receivedMessages=new uu(6e4);callbacks=new Map;messageEmitter=new Yi;toSubscribeContentTopics=new Set;toUnsubscribeContentTopics=new Set;subscribeIntervalId=null;keepAliveIntervalId=null;get contentTopics(){const e=Array.from(this.callbacks.keys()).map(e=>e.contentTopic),t=new Set(e).values();return Array.from(t)}constructor(e){this.config=e.config,this.pubsubTopic=e.pubsubTopic,this.protocol=e.protocol,this.peerManager=e.peerManager,this.onPeerConnected=this.onPeerConnected.bind(this),this.onPeerDisconnected=this.onPeerDisconnected.bind(this)}start(){hu.info("Starting subscription for pubsubTopic: "+this.pubsubTopic),this.isStarted||this.inProgress?hu.info("Subscription already started or in progress, skipping start"):(this.inProgress=!0,this.attemptSubscribe({useNewContentTopics:!1}),this.setupSubscriptionInterval(),this.setupKeepAliveInterval(),this.setupEventListeners(),this.isStarted=!0,this.inProgress=!1,hu.info("Subscription started for pubsubTopic: "+this.pubsubTopic))}stop(){hu.info("Stopping subscription for pubsubTopic: "+this.pubsubTopic),this.isStarted&&!this.inProgress?(this.inProgress=!0,this.disposeEventListeners(),this.disposeIntervals(),this.disposePeers(),this.disposeHandlers(),this.receivedMessages.dispose(),this.inProgress=!1,this.isStarted=!1,hu.info("Subscription stopped for pubsubTopic: "+this.pubsubTopic)):hu.info("Subscription not started or stop in progress, skipping stop")}isEmpty(){return 0===this.callbacks.size}async add(e,t){const r=Array.isArray(e)?e:[e];for(const e of r)this.addSingle(e,t);return!(this.toSubscribeContentTopics.size>0)||await this.attemptSubscribe({useNewContentTopics:!0})}async remove(e){const t=Array.isArray(e)?e:[e];for(const e of t)this.removeSingle(e);return!(this.toUnsubscribeContentTopics.size>0)||await this.attemptUnsubscribe({useNewContentTopics:!0})}invoke(e,t){this.isMessageReceived(e)?hu.info(`Skipping invoking callbacks for already received message: pubsubTopic:${this.pubsubTopic}, peerId:${t.toString()}, contentTopic:${e.contentTopic}`):(hu.info("Invoking message for contentTopic: "+e.contentTopic),this.messageEmitter.dispatchEvent(new CustomEvent(e.contentTopic,{detail:e})))}addSingle(e,t){hu.info("Adding subscription for contentTopic: "+e.contentTopic);const r=!this.contentTopics.includes(e.contentTopic);if(r&&this.toSubscribeContentTopics.add(e.contentTopic),this.callbacks.has(e)){hu.warn(`Replacing callback associated associated with decoder with pubsubTopic:${e.pubsubTopic} and contentTopic:${e.contentTopic}`);const t=this.callbacks.get(e);this.callbacks.delete(e),this.messageEmitter.removeEventListener(e.contentTopic,t)}const n=r=>{(async()=>{try{const n=await e.fromProtoObj(e.pubsubTopic,r.detail);t(n)}catch(e){hu.error("Error decoding message",e)}})()};this.callbacks.set(e,n),this.messageEmitter.addEventListener(e.contentTopic,n),hu.info(`Subscription added for contentTopic: ${e.contentTopic}, isNewContentTopic: ${r}`)}removeSingle(e){hu.info("Removing subscription for contentTopic: "+e.contentTopic);const t=this.callbacks.get(e);t||hu.warn(`No callback associated with decoder with pubsubTopic:${e.pubsubTopic} and contentTopic:${e.contentTopic}`),this.callbacks.delete(e),this.messageEmitter.removeEventListener(e.contentTopic,t);const r=!this.contentTopics.includes(e.contentTopic);r&&this.toUnsubscribeContentTopics.add(e.contentTopic),hu.info(`Subscription removed for contentTopic: ${e.contentTopic}, isCompletelyRemoved: ${r}`)}isMessageReceived(e){try{const t=ou(this.pubsubTopic,e);if(this.receivedMessages.has(t))return!0;this.receivedMessages.add(t)}catch(e){}return!1}setupSubscriptionInterval(){hu.info("Setting up subscription interval with period 1000ms"),this.subscribeIntervalId=setInterval(()=>{(async()=>{this.toSubscribeContentTopics.size>0&&(hu.info(`Subscription interval: ${this.toSubscribeContentTopics.size} topics to subscribe`),await this.attemptSubscribe({useNewContentTopics:!0})),this.toUnsubscribeContentTopics.size>0&&(hu.info(`Subscription interval: ${this.toUnsubscribeContentTopics.size} topics to unsubscribe`),await this.attemptUnsubscribe({useNewContentTopics:!0}))})()},1e3)}setupKeepAliveInterval(){hu.info(`Setting up keep-alive interval with period ${this.config.keepAliveIntervalMs}ms`),this.keepAliveIntervalId=setInterval(()=>{(async()=>{hu.info(`Keep-alive interval running for ${this.peers.size} peers`);let e=await Promise.all(Array.from(this.peers.values()).map(async e=>{if((await this.protocol.ping(e)).success)return hu.info("Ping successful for peer: "+e.toString()),void this.peerFailures.set(e.toString(),0);let t=this.peerFailures.get(e.toString())||0;return t+=1,this.peerFailures.set(e.toString(),t),hu.warn(`Ping failed for peer: ${e.toString()}, failures: ${t}/${this.config.pingsBeforePeerRenewed}`),t<this.config.pingsBeforePeerRenewed?void 0:(hu.info(`Peer ${e.toString()} exceeded max failures (${this.config.pingsBeforePeerRenewed}), will be replaced`),e)}));e=e.filter(e=>!!e),await Promise.all(e.map(e=>(this.peers.delete(e?.toString()),this.peerFailures.delete(e?.toString()),this.requestUnsubscribe(e,this.contentTopics)))),e.length>0&&(hu.info(`Replacing ${e.length} failed peers`),await this.attemptSubscribe({useNewContentTopics:!1,useOnlyNewPeers:!0}))})()},this.config.keepAliveIntervalMs)}setupEventListeners(){this.peerManager.events.addEventListener(cu.Connect,this.onPeerConnected),this.peerManager.events.addEventListener(cu.Disconnect,this.onPeerDisconnected)}disposeIntervals(){this.subscribeIntervalId&&clearInterval(this.subscribeIntervalId),this.keepAliveIntervalId&&clearInterval(this.keepAliveIntervalId)}disposeHandlers(){for(const[e,t]of this.callbacks.entries())this.messageEmitter.removeEventListener(e.contentTopic,t);this.callbacks.clear()}async disposePeers(){await this.attemptUnsubscribe({useNewContentTopics:!1}),this.peers.clear(),this.peerFailures=new Map}disposeEventListeners(){this.peerManager.events.removeEventListener(cu.Connect,this.onPeerConnected),this.peerManager.events.removeEventListener(cu.Disconnect,this.onPeerDisconnected)}async onPeerConnected(e){const t=e.detail?.toString();hu.info("Peer connected: "+t);await this.peerManager.isPeerOnPubsub(e.detail,this.pubsubTopic)?this.peers.has(t)?hu.info(`Peer ${t} already subscribed, skipping`):await this.attemptSubscribe({useNewContentTopics:!1,useOnlyNewPeers:!0}):hu.info(`Peer ${t} doesn't support pubsubTopic:${this.pubsubTopic}`)}async onPeerDisconnected(e){const t=e.detail?.toString();hu.info("Peer disconnected: "+t);await this.peerManager.isPeerOnPubsub(e.detail,this.pubsubTopic)?this.peers.has(t)?(hu.info(`Active peer ${t} disconnected, removing from peers list`),this.peers.delete(t),this.attemptSubscribe({useNewContentTopics:!1,useOnlyNewPeers:!0})):hu.info(`Disconnected peer ${t} not in use, ignoring`):hu.info(`Peer ${t} doesn't support pubsubTopic:${this.pubsubTopic}`)}async attemptSubscribe(e){const{useNewContentTopics:t,useOnlyNewPeers:r=!1}=e,n=t?Array.from(this.toSubscribeContentTopics):this.contentTopics;if(hu.info(`Attempting to subscribe: useNewContentTopics=${t}, useOnlyNewPeers=${r}, contentTopics=${n.length}`),!n.length)return hu.warn("Requested content topics is an empty array, skipping"),!1;const s=new Set(this.peers.keys()),i=await this.peerManager.getPeers({protocol:Vn.Filter,pubsubTopic:this.pubsubTopic});for(const e of i){if(this.peers.size>=this.config.numPeersToUse)break;this.peers.set(e.toString(),e)}const o=r?Array.from(this.peers.values()).filter(e=>!s.has(e.toString())):Array.from(this.peers.values());if(hu.info(`Subscribing with ${o.length} peers for ${n.length} content topics`),r&&0===o.length)return hu.warn("Requested to use only new peers, but no peers found, skipping"),!1;const a=await Promise.all(o.map(e=>this.requestSubscribe(e,n))),c=a.filter(e=>e).length;return hu.info(`Subscribe attempts completed: ${c}/${a.length} successful`),t&&(this.toSubscribeContentTopics=new Set),a.some(e=>e)}async requestSubscribe(e,t){if(hu.info(`requestSubscribe: pubsubTopic:${this.pubsubTopic}\tcontentTopics:${t.join(",")}`),!t.length||!this.pubsubTopic)return hu.warn("requestSubscribe: no contentTopics or pubsubTopic provided, not sending subscribe request"),!1;const r=await this.protocol.subscribe(this.pubsubTopic,e,t);return r.failure?(hu.warn(`requestSubscribe: Failed to subscribe ${this.pubsubTopic} to ${e.toString()} with error:${r.failure.error} for contentTopics:${t}`),!1):(hu.info(`requestSubscribe: Subscribed ${this.pubsubTopic} to ${e.toString()} for contentTopics:${t}`),!0)}async attemptUnsubscribe(e){const{useNewContentTopics:t}=e,r=t?Array.from(this.toUnsubscribeContentTopics):this.contentTopics;if(hu.info(`Attempting to unsubscribe: useNewContentTopics=${t}, contentTopics=${r.length}`),!r.length)return hu.warn("Requested content topics is an empty array, skipping"),!1;const n=Array.from(this.peers.values()),s=await Promise.all(n.map(e=>this.requestUnsubscribe(e,t?r:void 0))),i=s.filter(e=>e).length;return hu.info(`Unsubscribe attempts completed: ${i}/${s.length} successful`),t&&(this.toUnsubscribeContentTopics=new Set),s.some(e=>e)}async requestUnsubscribe(e,t){const r=t?await this.protocol.unsubscribe(this.pubsubTopic,e,t):await this.protocol.unsubscribeAll(this.pubsubTopic,e);return r.failure?(hu.warn(`requestUnsubscribe: Failed to unsubscribe for pubsubTopic:${this.pubsubTopic} from peerId:${e.toString()} with error:${r.failure?.error} for contentTopics:${t}`),!1):(hu.info(`requestUnsubscribe: Unsubscribed pubsubTopic:${this.pubsubTopic} from peerId:${e.toString()} for contentTopics:${t}`),!0)}}const pu=new On("sdk:filter");class fu{protocol;peerManager;config;subscriptions=new Map;constructor(e){this.config={numPeersToUse:2,pingsBeforePeerRenewed:3,keepAliveIntervalMs:6e4,...e.options},this.peerManager=e.peerManager,this.protocol=new js(this.onIncomingMessage.bind(this),e.libp2p)}get multicodec(){return this.protocol.multicodec}unsubscribeAll(){for(const e of this.subscriptions.values())e.stop();this.subscriptions.clear()}async subscribe(e,t){const r=Array.isArray(e)?e:[e];if(0===r.length)throw Error("Cannot subscribe with 0 decoders.");const n=r.map(e=>e.pubsubTopic),s=n[0],i=r.map(e=>e.contentTopic);pu.info(`Subscribing to contentTopics: ${i}, pubsubTopic: ${s}`),this.throwIfTopicNotSame(n);let o=this.subscriptions.get(s);o||(o=new du({pubsubTopic:s,protocol:this.protocol,config:this.config,peerManager:this.peerManager}),o.start());const a=await o.add(r,t);return this.subscriptions.set(s,o),pu.info(`Subscription ${a?"successful":"failed"} for content topic: ${i}`),a}async unsubscribe(e){const t=Array.isArray(e)?e:[e];if(0===t.length)throw Error("Cannot unsubscribe with 0 decoders.");const r=t.map(e=>e.pubsubTopic),n=r[0],s=t.map(e=>e.contentTopic);pu.info(`Unsubscribing from contentTopics: ${s}, pubsubTopic: ${n}`),this.throwIfTopicNotSame(r);const i=this.subscriptions.get(n);if(!i)return pu.warn("No subscriptions associated with the decoder."),!1;const o=await i.remove(t);return i.isEmpty()&&(pu.warn("Subscription has no decoders anymore, terminating it."),i.stop(),this.subscriptions.delete(n)),pu.info(`Unsubscribing ${o?"successful":"failed"} for content topic: ${s}`),o}async onIncomingMessage(e,t,r){pu.info(`Received message for pubsubTopic:${e}, contentTopic:${t.contentTopic}, peerId:${r.toString()}`);const n=this.subscriptions.get(e);n?n.invoke(t,r):pu.error("No subscription locally registered for topic "+e)}throwIfTopicNotSame(e){const t=e[0],r=e.every(e=>e===t);if(!r)throw Error("Cannot subscribe to more than one pubsub topic at the same time, got pubsubTopics:"+e)}}const gu=new On("health-indicator");class mu{libp2p;events;value=Xn.Unhealthy;constructor(e){this.libp2p=e.libp2p,this.events=e.events,this.onPeerIdentify=this.onPeerIdentify.bind(this),this.onPeerDisconnected=this.onPeerDisconnected.bind(this)}start(){gu.info("start: adding listeners to libp2p"),this.libp2p.addEventListener("peer:identify",this.onPeerIdentify),this.libp2p.addEventListener("peer:disconnect",this.onPeerDisconnected)}stop(){gu.info("stop: removing listeners to libp2p"),this.libp2p.removeEventListener("peer:identify",this.onPeerIdentify),this.libp2p.removeEventListener("peer:disconnect",this.onPeerDisconnected)}toValue(){return this.value}async onPeerDisconnected(e){gu.info("onPeerDisconnected: received libp2p event");this.libp2p.getConnections().length>0&&gu.info("onPeerDisconnected: has connections, ignoring"),gu.info("onPeerDisconnected: node identified as "+Xn.Unhealthy),this.updateAndDispatchHealthEvent(Xn.Unhealthy)}async onPeerIdentify(e){gu.info("onPeerIdentify: received libp2p event");const t=this.libp2p.getConnections(),r=await Promise.all(t.map(async e=>{try{return await this.libp2p.peerStore.get(e.remotePeer)}catch(e){return null}})),n=r.filter(e=>e?.protocols.includes(Vs)).length,s=r.filter(e=>e?.protocols.includes(Xs)).length;let i;0===n||0===s?i=Xn.Unhealthy:n>=2&&s>=2?i=Xn.SufficientlyHealthy:1===n&&1===s?i=Xn.MinimallyHealthy:(gu.error(`onPeerIdentify: unexpected state, cannot identify health status of the node: Filter:${n}; LightPush:${s}`),i=this.value),gu.info("onPeerIdentify: node identified as "+i),this.updateAndDispatchHealthEvent(i)}updateAndDispatchHealthEvent(e){this.value!==e&&(this.value=e,this.events.dispatchEvent(new CustomEvent("waku:health",{detail:this.value})))}}const yu=e=>new Promise((t,r)=>setTimeout(()=>r(Error("Task timeout")),e)),bu=new On("sdk:retry-manager");class wu{intervalID=null;retryIntervalMs;inProgress=0;queue=[];peerManager;constructor(e){this.peerManager=e.peerManager,this.retryIntervalMs=e.retryIntervalMs||1e3}start(){this.intervalID=setInterval(()=>{this.processQueue()},this.retryIntervalMs)}stop(){this.intervalID&&(clearInterval(this.intervalID),this.intervalID=null)}push(e,t,r){this.queue.push({maxAttempts:t,callback:e,routingInfo:r})}processQueue(){if(0!==this.queue.length)for(;this.queue.length&&this.inProgress<5;){const e=this.queue.shift();e&&this.scheduleTask(e)}}scheduleTask(e){setTimeout(async()=>this.taskExecutor(e),100)}async taskExecutor(e){if(e.maxAttempts<=0)return void bu.warn("scheduleTask: max attempts has reached, removing from queue");const t=(await this.peerManager.getPeers({protocol:Vn.LightPush,pubsubTopic:e.routingInfo.pubsubTopic}))[0];if(!t)return bu.warn("scheduleTask: no peers, putting back to queue"),void this.queue.push({...e,maxAttempts:e.maxAttempts-1});try{this.inProgress+=1;const r=await Promise.race([yu(1e4),e.callback(t)]);if(r?.failure)throw Error(r.failure.error);if(bu.info("scheduleTask: executed successfully"),0===e.maxAttempts)return void bu.warn("scheduleTask: discarded a task due to limit of max attempts");this.queue.push({...e,maxAttempts:e.maxAttempts-1})}catch(n){const s=n;if(bu.error("scheduleTask: task execution failed with error:",s),((r=s.message)===Hn.REMOTE_PEER_REJECTED||r===Hn.NO_RESPONSE||r===Hn.RLN_PROOF_GENERATION||r===Hn.NO_PEER_AVAILABLE)&&await this.peerManager.renewPeer(t,{protocol:Vn.LightPush,pubsubTopic:e.routingInfo.pubsubTopic}),0===e.maxAttempts)return void bu.warn("scheduleTask: discarded a task due to limit of max attempts");this.queue.push({...e,maxAttempts:e.maxAttempts-1})}finally{this.inProgress-=1}var r}}const vu=new On("sdk:light-push"),Eu={autoRetry:!0,retryIntervalMs:1e3,maxAttempts:3,numPeersToUse:1};class Su{config;retryManager;peerManager;protocol;constructor(e){this.config={...Eu,...e.options||{}},this.peerManager=e.peerManager,this.protocol=new Zs(e.libp2p),this.retryManager=new wu({peerManager:e.peerManager,retryIntervalMs:this.config.retryIntervalMs})}get multicodec(){return this.protocol.multicodec}start(){this.retryManager.start()}stop(){this.retryManager.stop()}async send(e,t,r={}){r={...this.config,...r};const{pubsubTopic:n}=e;vu.info("send: attempting to send a message to pubsubTopic:",n);const s=await this.peerManager.getPeers({protocol:Vn.LightPush,pubsubTopic:e.pubsubTopic}),i=s?.length>0?await Promise.all(s.map(r=>this.protocol.send(e,t,r).catch(()=>({success:null,failure:{error:Hn.GENERIC_FAIL}})))):[],o=i.length?{successes:i.filter(e=>e.success).map(e=>e.success),failures:i.filter(e=>e.failure).map(e=>e.failure)}:{successes:[],failures:[{error:Hn.NO_PEER_AVAILABLE}]};if(r.autoRetry&&0===o.successes.length){const n=r=>this.protocol.send(e,t,r);this.retryManager.push(n.bind(this),r.maxAttempts||3,e.routingInfo)}return o}}const Au=new On("store-sdk");class Iu{options;libp2p;peerManager;protocol;constructor(e){this.options=e.options||{},this.peerManager=e.peerManager,this.libp2p=e.libp2p,this.protocol=new si(e.libp2p)}get multicodec(){return this.protocol.multicodec}async*queryGenerator(e,t){const{decodersAsMap:r,queryOptions:n}=this.buildQueryParams(e,t);for(const e of n){const t=await this.getPeerToUse(e.pubsubTopic);if(!t)throw Au.error("No peers available to query"),Error("No peers available to query");Au.info("Querying store with options: "+JSON.stringify(e));const n=this.protocol.queryPerPage(e,r,t);for await(const e of n)yield e}}async queryWithOrderedCallback(e,t,r){Au.info("Querying store with ordered callback");for await(const n of this.queryGenerator(e,r))if(await this.processMessages(n,t))break}async queryWithPromiseCallback(e,t,r){Au.info("Querying store with promise callback");let n=!1;for await(const s of this.queryGenerator(e,r)){const e=s.map(async e=>{n||(n=!!await t(e))});if(await Promise.all(e),n)break}}async processMessages(e,t){let r=!1;const n=(await Promise.all(e)).filter(rr);return await Promise.all(n.map(async e=>{e&&!r&&(r=!!await t(e))})),r}createCursor(e){return iu(e.pubsubTopic,e)}validateDecodersAndPubsubTopic(e){if(0===e.length)throw Au.error("No decoders provided"),Error("No decoders provided");const t=Array.from(new Set(e.map(e=>e.pubsubTopic)));if(t.length>1)throw Au.error("API does not support querying multiple pubsub topics at once"),Error("API does not support querying multiple pubsub topics at once");const r=t[0],n=new Map;e.forEach(e=>{if(n.has(e.contentTopic))throw Au.error("API does not support different decoder per content topic"),Error("API does not support different decoder per content topic");n.set(e.contentTopic,e)});const s=e.filter(e=>e.pubsubTopic===r).map(e=>e.contentTopic);if(0===s.length)throw Au.error("No decoders found for topic "+r),Error("No decoders found for topic "+r);return{pubsubTopic:r,contentTopics:s,decodersAsMap:n}}async getPeerToUse(e){const t=await this.peerManager.getPeers({protocol:Vn.Store,pubsubTopic:e});return this.options.peers?await this.getPeerFromConfigurationOrFirst(t,this.options.peers):t[0]}async getPeerFromConfigurationOrFirst(e,t){const r=t.map(Zl),n=[];for(const t of r){const r=e.find(e=>e.toString()===t.getPeerId()?.toString());if(r)return r;n.push(t)}for(;n.length;){const e=n.pop();if(!e)return;try{if(await this.libp2p.dial(e))return nl(e.getPeerId())}catch(t){Au.warn(`Failed to dial peer from options.peers list for Store protocol. Peer:${e.getPeerId()}, error:${t}`)}}return Au.warn(`Passed node to use for Store not found: ${t.toString()}. Attempting to use first available peers.`),e[0]}buildQueryParams(e,t){let r,n,s;if(t?.messageHashes&&t.messageHashes.length>0)r=t.pubsubTopic||e[0]?.pubsubTopic||"",n=[],s=new Map,e.forEach(e=>{s.set(e.contentTopic,e)});else{const t=this.validateDecodersAndPubsubTopic(e);r=t.pubsubTopic,n=t.contentTopics,s=t.decodersAsMap}const i=[];if(t?.timeStart&&t?.timeEnd){let e=t.timeStart;const r=t.timeEnd;for(;r.getTime()-e.getTime()>this.protocol.maxTimeLimit;){const t=new Date(e.getTime()+this.protocol.maxTimeLimit);i.push([e,t]),e=t}0===i.length&&(Au.info("Using single time range"),i.push([e,r]))}return 0===i.length?(Au.info("No sub time ranges"),{decodersAsMap:s,queryOptions:[{pubsubTopic:r,contentTopics:n,includeData:!0,paginationForward:!0,...t}]}):(Au.info(`Building ${i.length} sub time ranges`),{decodersAsMap:s,queryOptions:i.map(([e,s])=>({pubsubTopic:r,contentTopics:n,includeData:!0,paginationForward:!0,...t,timeStart:e,timeEnd:s}))})}}const Cu=new On("wait-for-remote-peer");async function xu(e,t,r){t=t?.length?t:function(e){const t=[];e.relay&&t.push(Vn.Relay);e.filter&&t.push(Vn.Filter);e.store&&t.push(Vn.Store);e.lightPush&&t.push(Vn.LightPush);return t}(e);const n=e.libp2p.getConnections();if(!e.isStarted())throw Error("Waku node is not started");for(const r of t)switch(r){case Vn.Relay:if(!e.relay)throw Error("Cannot wait for Relay peer: protocol not mounted");break;case Vn.LightPush:if(!e.lightPush)throw Error("Cannot wait for LightPush peer: protocol not mounted");break;case Vn.Store:if(!e.store)throw Error("Cannot wait for Store peer: protocol not mounted");break;case Vn.Filter:if(!e.filter)throw Error("Cannot wait for Filter peer: protocol not mounted")}const s=[ku(e,t)];n.length>0&&!t.includes(Vn.Relay)&&s.push(async function(e,t){const r=e.libp2p.getPeers(),n=e.libp2p.services.metadata,s=function(e){const t=new Map,r={[Vn.Filter]:Vs,[Vn.LightPush]:Xs,[Vn.Store]:ni};for(const n of e)r[n]&&t.set(r[n],!1);return t}(t);if(!r.length||!n)return void Cu.info(`Skipping waitForMetadata due to missing connections:${r.length} or metadataService:${!!n}`);for(const t of r)try{const r=await e.libp2p.peerStore.get(t),i=r.protocols.some(e=>s.has(e));if(i){if(!(await n.confirmOrAttemptHandshake(t)).error){r.protocols.forEach(e=>{s.has(e)&&s.set(e,!0)});if(Array.from(s.values()).every(e=>e))return}}}catch(e){"ERR_CONNECTION_BEING_CLOSED"===e.code&&Cu.error("Connection closed. Some peers can be on different shard."),Cu.error("Error while iterating through peers: "+e);continue}}(e,t)),r?await async function(e,t,r){await Promise.race([e,Pu(t,r)])}(Promise.any(s),r,"Timed out waiting for a remote peer."):await Promise.any(s)}async function ku(e,t){const r=[];return e.relay&&t.includes(Vn.Relay)&&r.push(e.relay.waitForPeers()),e.store&&t.includes(Vn.Store)&&r.push(Tu(ni,e.libp2p)),e.lightPush&&t.includes(Vn.LightPush)&&r.push(Tu(Xs,e.libp2p)),e.filter&&t.includes(Vn.Filter)&&r.push(Tu(Vs,e.libp2p)),Promise.all(r)}async function Tu(e,t){Cu.info(`Waiting for ${e} peer.`),await new Promise(r=>{const n=async s=>{if(s.detail?.protocols?.includes(e)){const e=t.services.metadata;if(!e)return t.removeEventListener("peer:identify",n),void r();try{await e.confirmOrAttemptHandshake(s.detail.peerId),t.removeEventListener("peer:identify",n),r()}catch(e){"ERR_CONNECTION_BEING_CLOSED"===e.code&&Cu.error("Connection closed. Some peers can be on different shard."),Cu.error("Error waiting for metadata: "+e)}}};t.addEventListener("peer:identify",n)})}const Pu=(e,t)=>new Promise((r,n)=>setTimeout(()=>n(Error(t)),e));const _u=new On("waku");class Ru{libp2p;relay;store;filter;lightPush;events=new Yi;networkConfig;_nodeStateLock=!1;_nodeStarted=!1;connectionManager;peerManager;healthIndicator;constructor(e,t,r,n){this.relay=n,this.libp2p=t,this.networkConfig=e.networkConfig||Wn,r={filter:!1,lightpush:!1,store:!1,...r};const s=this.libp2p.peerId.toString();this.connectionManager=new eu({libp2p:t,relay:this.relay,events:this.events,networkConfig:this.networkConfig,config:e?.connectionManager}),this.peerManager=new lu({libp2p:t,config:{numPeersToUse:e.numPeersToUse},connectionManager:this.connectionManager}),this.healthIndicator=new mu({libp2p:t,events:this.events}),r.store&&(this.store=new Iu({libp2p:t,peerManager:this.peerManager,options:e?.store})),r.lightpush&&(this.lightPush=new Su({libp2p:t,peerManager:this.peerManager,options:e?.lightPush})),r.filter&&(this.filter=new fu({libp2p:t,peerManager:this.peerManager,options:e.filter})),_u.info("Waku node created",s,`relay: ${!!this.relay}, store: ${!!this.store}, light push: ${!!this.lightPush}, filter: ${!!this.filter}`)}get peerId(){return this.libp2p.peerId}get protocols(){return this.libp2p.getProtocols()}get health(){return this.healthIndicator.toValue()}async dial(e,t){const r=t??[];void 0===t&&(this.relay&&r.push(Vn.Relay),this.store&&r.push(Vn.Store),this.filter&&r.push(Vn.Filter),this.lightPush&&r.push(Vn.LightPush));const n=[];return r.includes(Vn.Relay)&&(this.relay?this.relay.gossipSub.multicodecs.forEach(e=>n.push(e)):_u.error("Relay codec not included in dial codec: protocol not mounted locally")),r.includes(Vn.Store)&&(this.store?n.push(this.store.multicodec):_u.error("Store codec not included in dial codec: protocol not mounted locally")),r.includes(Vn.LightPush)&&(this.lightPush?n.push(this.lightPush.multicodec):_u.error("Light Push codec not included in dial codec: protocol not mounted locally")),r.includes(Vn.Filter)&&(this.filter?n.push(this.filter.multicodec):_u.error("Filter codec not included in dial codec: protocol not mounted locally")),_u.info(`Dialing to ${e?.toString()} with protocols ${r}`),await this.connectionManager.dial(e,n)}async hangUp(e){return _u.info(`Hanging up peer:${e?.toString()}.`),this.connectionManager.hangUp(e)}async start(){this._nodeStateLock||this.isStarted()||(this._nodeStateLock=!0,await this.libp2p.start(),this.connectionManager.start(),this.peerManager.start(),this.healthIndicator.start(),this.lightPush?.start(),this._nodeStateLock=!1,this._nodeStarted=!0)}async stop(){!this._nodeStateLock&&this.isStarted()&&(this._nodeStateLock=!0,this.lightPush?.stop(),this.healthIndicator.stop(),this.peerManager.stop(),this.connectionManager.stop(),await this.libp2p.stop(),this._nodeStateLock=!1,this._nodeStarted=!1)}async getConnectedPeers(){return this.connectionManager.getConnectedPeers()}async waitForPeers(e,t){return xu(this,e,t)}isStarted(){return this._nodeStarted&&"started"===this.libp2p.status}isConnected(){return this.connectionManager.isConnected()}createDecoder(e){const t=this.createRoutingInfo(e.contentTopic,e.shardId);return Kn(e.contentTopic,t)}createEncoder(e){const t=this.createRoutingInfo(e.contentTopic,e.shardId);return $n({contentTopic:e.contentTopic,ephemeral:e.ephemeral,routingInfo:t})}createRoutingInfo(e,t){return bn(this.networkConfig,{contentTopic:e,shardId:t})}}let Lu=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"},Du=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"},Mu=class extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"},Nu=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};var Ou;(e=>{e[e.LENGTH=0]="LENGTH",e[e.DATA=1]="DATA"})(Ou||(Ou={}));const Uu=e=>{const t=d(e);return Uu.bytes=c(t),t};function Fu(e,t){const r=new rs;let n=Ou.LENGTH,s=-1;const i=t?.lengthDecoder??Uu,o=t?.maxLengthLength??8,a=t?.maxDataLength??4194304;function*c(){for(;r.byteLength>0;){if(n===Ou.LENGTH)try{if(s=i(r),s<0)throw new Lu("Invalid message length");if(s>a)throw new Du("Message length too long");const e=i.bytes;r.consume(e),null!=t?.onLength&&t.onLength(s),n=Ou.DATA}catch(e){if(e instanceof RangeError){if(r.byteLength>o)throw new Mu("Message length length too long");break}throw e}if(n===Ou.DATA){if(r.byteLength<s)break;const e=r.sublist(0,s);r.consume(s),null!=t?.onData&&t.onData(e),yield e,n=Ou.LENGTH}}}return null!=e[Symbol.asyncIterator]?async function*(){for await(const t of e)r.append(t),yield*c();if(r.byteLength>0)throw new Nu("Unexpected end of input")}():function*(){for(const t of e)r.append(t),yield*c();if(r.byteLength>0)throw new Nu("Unexpected end of input")}()}Uu.bytes=0,Fu.fromReader=(e,t)=>{let r=1;return Fu(async function*(){for(;;)try{const{done:t,value:n}=await e.next(r);if(!0===t)return;null!=n&&(yield n)}catch(e){if("ERR_UNDER_READ"===e.code)return{done:!0,value:null};throw e}finally{r=1}}(),{...t??{},onLength(e){r=e}})};class Bu extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"}function qu(e,t){const r=Es();e.sink(r).catch(async e=>{await r.end(e)}),e.sink=async e=>{for await(const t of e)await r.push(t);await r.end()};let n=e.source;null!=e.source[Symbol.iterator]?n=e.source[Symbol.iterator]():null!=e.source[Symbol.asyncIterator]&&(n=e.source[Symbol.asyncIterator]());const s=new rs;return{async read(e){if(e?.signal?.throwIfAborted(),null==e?.bytes){const{done:t,value:r}=await ws(n.next(),e?.signal);return!0===t?null:r}for(;s.byteLength<e.bytes;){const{value:t,done:r}=await ws(n.next(),e?.signal);if(!0===r)throw new Bu("unexpected end of input");s.append(t)}const t=s.sublist(0,e.bytes);return s.consume(e.bytes),t},async write(e,t){t?.signal?.throwIfAborted(),e instanceof Uint8Array?await r.push(e,t):await r.push(e.subarray(),t)},unwrap(){if(s.byteLength>0){const r=e.source;e.source=async function*(){!1===t?.yieldBytes?yield s:yield*s,yield*r}()}return e}}}class $u extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"}let zu=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"};class Ku extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"}function Vu(e,t={}){const r=qu(e,t);null!=t.maxDataLength&&null==t.maxLengthLength&&(t.maxLengthLength=c(t.maxDataLength));const n=t?.lengthDecoder??d,s=t?.lengthEncoder??h;return{async read(e){let s=-1;const i=new rs;for(;;){i.append(await r.read({...e,bytes:1}));try{s=n(i)}catch(e){if(e instanceof RangeError)continue;throw e}if(s<0)throw new $u("Invalid message length");if(null!=t?.maxLengthLength&&i.byteLength>t.maxLengthLength)throw new Ku("message length length too long");if(s>-1)break}if(null!=t?.maxDataLength&&s>t.maxDataLength)throw new zu("message length too long");return r.read({...e,bytes:s})},async write(e,t){await r.write(new rs(s(e.byteLength),e),t)},async writeV(e,t){const n=new rs(...e.flatMap(e=>[s(e.byteLength),e]));await r.write(n,t)},unwrap(){return r.unwrap()}}}function Hu(){const e=ps();let t=!1;return{async sink(r){if(t)throw Error("already piped");t=!0,e.resolve(r)},source:async function*(){const t=await e.promise;yield*t}()}}const ju=65535,Gu=!!globalThis.process?.env?.DUMP_SESSION_KEYS;function Wu(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function Xu(e){if("boolean"!=typeof e)throw Error("boolean expected, not "+e)}function Zu(e){if(!Number.isSafeInteger(e)||e<0)throw Error("positive integer expected, got "+e)}function Qu(e,...t){if(!Wu(e))throw Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw Error("Uint8Array expected of length "+t+", got length="+e.length)}function Yu(e,t=!0){if(e.destroyed)throw Error("Hash instance has been destroyed");if(t&&e.finished)throw Error("Hash#digest() has already been called")}function Ju(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function eh(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}const th=(()=>68===new Uint8Array(new Uint32Array([287454020]).buffer)[0])();function rh(e){if("string"==typeof e)e=function(e){if("string"!=typeof e)throw Error("string expected");return new Uint8Array((new TextEncoder).encode(e))}(e);else{if(!Wu(e))throw Error("Uint8Array expected, got "+typeof e);e=ah(e)}return e}const nh=(e,t)=>{function r(r,...n){if(Qu(r),!th)throw Error("Non little-endian hardware is not yet supported");if(void 0!==e.nonceLength){const t=n[0];if(!t)throw Error("nonce / iv required");e.varSizeNonce?Qu(t):Qu(t,e.nonceLength)}const s=e.tagLength;s&&void 0!==n[1]&&Qu(n[1]);const i=t(r,...n),o=(e,t)=>{if(void 0!==t){if(2!==e)throw Error("cipher output not supported");Qu(t)}};let a=!1;return{encrypt(e,t){if(a)throw Error("cannot encrypt() twice with same key + nonce");return a=!0,Qu(e),o(i.encrypt.length,t),i.encrypt(e,t)},decrypt(e,t){if(Qu(e),s&&e.length<s)throw Error("invalid ciphertext length: smaller than tagLength="+s);return o(i.decrypt.length,t),i.decrypt(e,t)}}}return Object.assign(r,e),r};function sh(e,t,r=!0){if(void 0===t)return new Uint8Array(e);if(t.length!==e)throw Error("invalid output length, expected "+e+", got: "+t.length);if(r&&t.byteOffset%4!=0)throw Error("invalid output, must be aligned");return t}function ih(e,t,r,n){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,n);const s=BigInt(32),i=BigInt(4294967295),o=Number(r>>s&i),a=Number(r&i);e.setUint32(t+4,o,n),e.setUint32(t+0,a,n)}function oh(e,t,r){Xu(r);const n=new Uint8Array(16),s=(i=n,new DataView(i.buffer,i.byteOffset,i.byteLength));var i;return ih(s,0,BigInt(t),r),ih(s,8,BigInt(e),r),n}function ah(e){return Uint8Array.from(e)}const ch=e=>Uint8Array.from(e.split("").map(e=>e.charCodeAt(0))),lh=ch("expand 16-byte k"),uh=ch("expand 32-byte k"),hh=Ju(lh),dh=Ju(uh);function ph(e,t){return e<<t|e>>>32-t}function fh(e){return e.byteOffset%4==0}const gh=2**32-1,mh=new Uint32Array;function yh(e,t){const{allowShortKeys:r,extendNonceFn:n,counterLength:s,counterRight:i,rounds:o}=function(e,t){if(null==t||"object"!=typeof t)throw Error("options must be defined");return Object.assign(e,t)}({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},t);if("function"!=typeof e)throw Error("core must be a function");return Zu(s),Zu(o),Xu(i),Xu(r),(t,a,c,l,u=0)=>{Qu(t),Qu(a),Qu(c);const h=c.length;if(void 0===l&&(l=new Uint8Array(h)),Qu(l),Zu(u),u<0||u>=gh)throw Error("arx: counter overflow");if(l.length<h)throw Error(`arx: output (${l.length}) is shorter than data (${h})`);const d=[];let p,f,g=t.length;if(32===g)d.push(p=ah(t)),f=dh;else{if(16!==g||!r)throw Error("arx: invalid 32-byte key, got length="+g);p=new Uint8Array(32),p.set(t),p.set(t,16),f=hh,d.push(p)}fh(a)||d.push(a=ah(a));const m=Ju(p);if(n){if(24!==a.length)throw Error("arx: extended nonce must be 24 bytes");n(f,m,Ju(a.subarray(0,16)),m),a=a.subarray(16)}const y=16-s;if(y!==a.length)throw Error(`arx: nonce must be ${y} or 16 bytes`);if(12!==y){const e=new Uint8Array(12);e.set(a,i?0:12-a.length),a=e,d.push(a)}const b=Ju(a);return function(e,t,r,n,s,i,o,a){const c=s.length,l=new Uint8Array(64),u=Ju(l),h=fh(s)&&fh(i),d=h?Ju(s):mh,p=h?Ju(i):mh;for(let f=0;f<c;o++){if(e(t,r,n,u,o,a),o>=gh)throw Error("arx: counter overflow");const g=Math.min(64,c-f);if(h&&64===g){const e=f/4;if(f%4!=0)throw Error("arx: invalid block position");for(let t,r=0;r<16;r++)t=e+r,p[t]=d[t]^u[r];f+=64;continue}for(let e,t=0;t<g;t++)e=f+t,i[e]=s[e]^l[t];f+=g}}(e,f,m,b,c,l,u,o),eh(...d),l}}const bh=(e,t)=>255&e[t++]|(255&e[t++])<<8;class wh{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,Qu(e=rh(e),32);const t=bh(e,0),r=bh(e,2),n=bh(e,4),s=bh(e,6),i=bh(e,8),o=bh(e,10),a=bh(e,12),c=bh(e,14);this.r[0]=8191&t,this.r[1]=8191&(t>>>13|r<<3),this.r[2]=7939&(r>>>10|n<<6),this.r[3]=8191&(n>>>7|s<<9),this.r[4]=255&(s>>>4|i<<12),this.r[5]=i>>>1&8190,this.r[6]=8191&(i>>>14|o<<2),this.r[7]=8065&(o>>>11|a<<5),this.r[8]=8191&(a>>>8|c<<8),this.r[9]=c>>>5&127;for(let t=0;t<8;t++)this.pad[t]=bh(e,16+2*t)}process(e,t,r=!1){const n=r?0:2048,{h:s,r:i}=this,o=i[0],a=i[1],c=i[2],l=i[3],u=i[4],h=i[5],d=i[6],p=i[7],f=i[8],g=i[9],m=bh(e,t+0),y=bh(e,t+2),b=bh(e,t+4),w=bh(e,t+6),v=bh(e,t+8),E=bh(e,t+10),S=bh(e,t+12),A=bh(e,t+14);let I=s[0]+(8191&m),C=s[1]+(8191&(m>>>13|y<<3)),x=s[2]+(8191&(y>>>10|b<<6)),k=s[3]+(8191&(b>>>7|w<<9)),T=s[4]+(8191&(w>>>4|v<<12)),P=s[5]+(v>>>1&8191),_=s[6]+(8191&(v>>>14|E<<2)),R=s[7]+(8191&(E>>>11|S<<5)),L=s[8]+(8191&(S>>>8|A<<8)),D=s[9]+(A>>>5|n),M=0,N=M+I*o+C*(5*g)+x*(5*f)+k*(5*p)+T*(5*d);M=N>>>13,N&=8191,N+=P*(5*h)+_*(5*u)+R*(5*l)+L*(5*c)+D*(5*a),M+=N>>>13,N&=8191;let O=M+I*a+C*o+x*(5*g)+k*(5*f)+T*(5*p);M=O>>>13,O&=8191,O+=P*(5*d)+_*(5*h)+R*(5*u)+L*(5*l)+D*(5*c),M+=O>>>13,O&=8191;let U=M+I*c+C*a+x*o+k*(5*g)+T*(5*f);M=U>>>13,U&=8191,U+=P*(5*p)+_*(5*d)+R*(5*h)+L*(5*u)+D*(5*l),M+=U>>>13,U&=8191;let F=M+I*l+C*c+x*a+k*o+T*(5*g);M=F>>>13,F&=8191,F+=P*(5*f)+_*(5*p)+R*(5*d)+L*(5*h)+D*(5*u),M+=F>>>13,F&=8191;let B=M+I*u+C*l+x*c+k*a+T*o;M=B>>>13,B&=8191,B+=P*(5*g)+_*(5*f)+R*(5*p)+L*(5*d)+D*(5*h),M+=B>>>13,B&=8191;let q=M+I*h+C*u+x*l+k*c+T*a;M=q>>>13,q&=8191,q+=P*o+_*(5*g)+R*(5*f)+L*(5*p)+D*(5*d),M+=q>>>13,q&=8191;let $=M+I*d+C*h+x*u+k*l+T*c;M=$>>>13,$&=8191,$+=P*a+_*o+R*(5*g)+L*(5*f)+D*(5*p),M+=$>>>13,$&=8191;let z=M+I*p+C*d+x*h+k*u+T*l;M=z>>>13,z&=8191,z+=P*c+_*a+R*o+L*(5*g)+D*(5*f),M+=z>>>13,z&=8191;let K=M+I*f+C*p+x*d+k*h+T*u;M=K>>>13,K&=8191,K+=P*l+_*c+R*a+L*o+D*(5*g),M+=K>>>13,K&=8191;let V=M+I*g+C*f+x*p+k*d+T*h;M=V>>>13,V&=8191,V+=P*u+_*l+R*c+L*a+D*o,M+=V>>>13,V&=8191,M=(M<<2)+M|0,M=M+N|0,N=8191&M,M>>>=13,O+=M,s[0]=N,s[1]=O,s[2]=U,s[3]=F,s[4]=B,s[5]=q,s[6]=$,s[7]=z,s[8]=K,s[9]=V}finalize(){const{h:e,pad:t}=this,r=new Uint16Array(10);let n=e[1]>>>13;e[1]&=8191;for(let t=2;t<10;t++)e[t]+=n,n=e[t]>>>13,e[t]&=8191;e[0]+=5*n,n=e[0]>>>13,e[0]&=8191,e[1]+=n,n=e[1]>>>13,e[1]&=8191,e[2]+=n,r[0]=e[0]+5,n=r[0]>>>13,r[0]&=8191;for(let t=1;t<10;t++)r[t]=e[t]+n,n=r[t]>>>13,r[t]&=8191;r[9]-=8192;let s=(1^n)-1;for(let e=0;e<10;e++)r[e]&=s;s=~s;for(let t=0;t<10;t++)e[t]=e[t]&s|r[t];e[0]=65535&(e[0]|e[1]<<13),e[1]=65535&(e[1]>>>3|e[2]<<10),e[2]=65535&(e[2]>>>6|e[3]<<7),e[3]=65535&(e[3]>>>9|e[4]<<4),e[4]=65535&(e[4]>>>12|e[5]<<1|e[6]<<14),e[5]=65535&(e[6]>>>2|e[7]<<11),e[6]=65535&(e[7]>>>5|e[8]<<8),e[7]=65535&(e[8]>>>8|e[9]<<5);let i=e[0]+t[0];e[0]=65535&i;for(let r=1;r<8;r++)i=(e[r]+t[r]|0)+(i>>>16)|0,e[r]=65535&i;eh(r)}update(e){Yu(this),Qu(e=rh(e));const{buffer:t,blockLen:r}=this,n=e.length;for(let s=0;s<n;){const i=Math.min(r-this.pos,n-s);if(i!==r)t.set(e.subarray(s,s+i),this.pos),this.pos+=i,s+=i,this.pos===r&&(this.process(t,0,!1),this.pos=0);else for(;r<=n-s;s+=r)this.process(e,s)}return this}destroy(){eh(this.h,this.r,this.buffer,this.pad)}digestInto(e){Yu(this),function(e,t){Qu(e);const r=t.outputLen;if(e.length<r)throw Error("digestInto() expects output buffer of length at least "+r)}(e,this),this.finished=!0;const{buffer:t,h:r}=this;let{pos:n}=this;if(n){for(t[n++]=1;n<16;n++)t[n]=0;this.process(t,0,!0)}this.finalize();let s=0;for(let t=0;t<8;t++)e[s++]=r[t]>>>0,e[s++]=r[t]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}}const vh=function(e){const t=(t,r)=>e(r).update(rh(t)).digest(),r=e(new Uint8Array(32));return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=t=>e(t),t}(e=>new wh(e));function Eh(e,t,r,n,s,i=20){let o=e[0],a=e[1],c=e[2],l=e[3],u=t[0],h=t[1],d=t[2],p=t[3],f=t[4],g=t[5],m=t[6],y=t[7],b=s,w=r[0],v=r[1],E=r[2],S=o,A=a,I=c,C=l,x=u,k=h,T=d,P=p,_=f,R=g,L=m,D=y,M=b,N=w,O=v,U=E;for(let e=0;e<i;e+=2)S=S+x|0,M=ph(M^S,16),_=_+M|0,x=ph(x^_,12),S=S+x|0,M=ph(M^S,8),_=_+M|0,x=ph(x^_,7),A=A+k|0,N=ph(N^A,16),R=R+N|0,k=ph(k^R,12),A=A+k|0,N=ph(N^A,8),R=R+N|0,k=ph(k^R,7),I=I+T|0,O=ph(O^I,16),L=L+O|0,T=ph(T^L,12),I=I+T|0,O=ph(O^I,8),L=L+O|0,T=ph(T^L,7),C=C+P|0,U=ph(U^C,16),D=D+U|0,P=ph(P^D,12),C=C+P|0,U=ph(U^C,8),D=D+U|0,P=ph(P^D,7),S=S+k|0,U=ph(U^S,16),L=L+U|0,k=ph(k^L,12),S=S+k|0,U=ph(U^S,8),L=L+U|0,k=ph(k^L,7),A=A+T|0,M=ph(M^A,16),D=D+M|0,T=ph(T^D,12),A=A+T|0,M=ph(M^A,8),D=D+M|0,T=ph(T^D,7),I=I+P|0,N=ph(N^I,16),_=_+N|0,P=ph(P^_,12),I=I+P|0,N=ph(N^I,8),_=_+N|0,P=ph(P^_,7),C=C+x|0,O=ph(O^C,16),R=R+O|0,x=ph(x^R,12),C=C+x|0,O=ph(O^C,8),R=R+O|0,x=ph(x^R,7);let F=0;n[F++]=o+S|0,n[F++]=a+A|0,n[F++]=c+I|0,n[F++]=l+C|0,n[F++]=u+x|0,n[F++]=h+k|0,n[F++]=d+T|0,n[F++]=p+P|0,n[F++]=f+_|0,n[F++]=g+R|0,n[F++]=m+L|0,n[F++]=y+D|0,n[F++]=b+M|0,n[F++]=w+N|0,n[F++]=v+O|0,n[F++]=E+U|0}const Sh=yh(Eh,{counterRight:!1,counterLength:4,allowShortKeys:!1}),Ah=new Uint8Array(16),Ih=(e,t)=>{e.update(t);const r=t.length%16;r&&e.update(Ah.subarray(r))},Ch=new Uint8Array(32);function xh(e,t,r,n,s){const i=e(t,r,Ch),o=vh.create(i);s&&Ih(o,s),Ih(o,n);const a=oh(n.length,s?s.length:0,!0);o.update(a);const c=o.digest();return eh(i,a),c}const kh=nh({blockSize:64,nonceLength:12,tagLength:16},(Th=Sh,(e,t,r)=>{const n=16;return{encrypt(s,i){const o=s.length;(i=sh(o+n,i,!1)).set(s);const a=i.subarray(0,-16);Th(e,t,a,a,1);const c=xh(Th,e,t,a,r);return i.set(c,o),eh(c),i},decrypt(s,i){i=sh(s.length-n,i,!1);const o=s.subarray(0,-16),a=s.subarray(-16),c=xh(Th,e,t,o,r);if(!((e,t)=>{if(e.length!==t.length)return!1;let r=0;for(let n=0;n<e.length;n++)r|=e[n]^t[n];return 0===r})(a,c))throw Error("invalid tag");return i.set(s.subarray(0,-16)),Th(e,t,i,i,1),eh(c),i}}}));var Th;const Ph=Uint8Array.from([0]),_h=Uint8Array.of();const Rh={hashSHA256:e=>cn(e.subarray()),getHKDF(e,t){const r=function(e,t,r){return cr(e),void 0===r&&(r=new Uint8Array(e.outputLen)),Ac(e,Ir(r),Ir(t))}(cn,t,e),n=function(e,t,r,n=32){cr(e),or(n);const s=e.outputLen;if(n>255*s)throw Error("Length should be <= 255*HashLen");const i=Math.ceil(n/s);void 0===r&&(r=_h);const o=new Uint8Array(i*s),a=Ac.create(e,t),c=a._cloneInto(),l=new Uint8Array(a.outputLen);for(let e=0;e<i;e++)Ph[0]=e+1,c.update(0===e?_h:l).update(r).update(Ph).digestInto(l),o.set(l,s*e),a._cloneInto(c);return a.destroy(),c.destroy(),ur(l,Ph),o.slice(0,n)}(cn,r,void 0,96),s=n;return[s.subarray(0,32),s.subarray(32,64),s.subarray(64,96)]},generateX25519KeyPair(){const e=ec.utils.randomPrivateKey();return{publicKey:ec.getPublicKey(e),privateKey:e}},generateX25519KeyPairFromSeed:e=>({publicKey:ec.getPublicKey(e),privateKey:e}),generateX25519SharedKey:(e,t)=>ec.getSharedSecret(e.subarray(),t.subarray()),chaCha20Poly1305Encrypt:(e,t,r,n)=>kh(n,t,r).encrypt(e.subarray()),chaCha20Poly1305Decrypt:(e,t,r,n,s)=>kh(n,t,r).decrypt(e.subarray(),s)},Lh=Rh;const Dh=e=>{const r=t(2);return r[0]=e>>8,r[1]=e,r};Dh.bytes=2;const Mh=e=>{if(e.length<2)throw RangeError("Could not decode int16BE");if(e instanceof Uint8Array){let t=0;return t+=e[0]<<8,t+=e[1],t}return e.getUint16(0)};function Nh(e,t){t.enabled&&Gu&&(e?(t("LOCAL_STATIC_PUBLIC_KEY "+ln(e.publicKey,"hex")),t("LOCAL_STATIC_PRIVATE_KEY "+ln(e.privateKey,"hex"))):t("Missing local static keys."))}function Oh(e,t){t.enabled&&Gu&&(e?(t("LOCAL_PUBLIC_EPHEMERAL_KEY "+ln(e.publicKey,"hex")),t("LOCAL_PRIVATE_EPHEMERAL_KEY "+ln(e.privateKey,"hex"))):t("Missing local ephemeral keys."))}function Uh(e,t){t.enabled&&Gu&&t(e?"REMOTE_EPHEMERAL_PUBLIC_KEY "+ln(e.subarray(),"hex"):"Missing remote ephemeral keys.")}function Fh(e,t,r){r.enabled&&Gu&&(r(`CIPHER_STATE_1 ${e.n.getUint64()} ${e.k&&ln(e.k,"hex")}`),r(`CIPHER_STATE_2 ${t.n.getUint64()} ${t.k&&ln(t.k,"hex")}`))}Mh.bytes=2;class Bh extends Error{code;constructor(e="Invalid crypto exchange"){super(e),this.code=Bh.code}static code="ERR_INVALID_CRYPTO_EXCHANGE"}class qh{n;bytes;view;constructor(t=0){this.n=t,this.bytes=e(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,t,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>4294967295)throw Error("Cipherstate has reached maximum n, a new handshake must be performed")}}const $h=e(0);class zh{k;n;crypto;constructor(e,t,r=0){this.crypto=e,this.k=t,this.n=new qh(r)}hasKey(){return!!this.k}encryptWithAd(e,t){if(!this.hasKey())return t;this.n.assertValue();const r=this.crypto.encrypt(t,this.n.getBytes(),e,this.k);return this.n.increment(),r}decryptWithAd(e,t,r){if(!this.hasKey())return t;this.n.assertValue();const n=this.crypto.decrypt(t,this.n.getBytes(),e,this.k,r);return this.n.increment(),n}}class Kh{cs;ck;h;crypto;constructor(t,r){this.crypto=t;const n=rt(r,"utf-8");this.h=function(t,r){if(r.length<=32){const t=e(32);return t.set(r),t}return t.hash(r)}(t,n),this.ck=this.h,this.cs=new zh(t)}mixKey(e){const[t,r]=this.crypto.hkdf(this.ck,e);this.ck=t,this.cs=new zh(this.crypto,r)}mixHash(e){this.h=this.crypto.hash(new rs(this.h,e))}encryptAndHash(e){const t=this.cs.encryptWithAd(this.h,e);return this.mixHash(t),t}decryptAndHash(e){const t=this.cs.decryptWithAd(this.h,e);return this.mixHash(e),t}split(){const[e,t]=this.crypto.hkdf(this.ck,$h);return[new zh(this.crypto,e),new zh(this.crypto,t)]}}class Vh{ss;s;e;rs;re;initiator;crypto;constructor(e){const{crypto:t,protocolName:r,prologue:n,initiator:s,s:i,e:o,rs:a,re:c}=e;this.crypto=t,this.ss=new Kh(t,r),this.ss.mixHash(n),this.initiator=s,this.s=i,this.e=o,this.rs=a,this.re=c}writeE(){if(this.e)throw Error("ephemeral keypair is already set");const e=this.crypto.generateKeypair();return this.ss.mixHash(e.publicKey),this.e=e,e.publicKey}writeS(){if(!this.s)throw Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw Error("ephemeral keypair is not set");if(!this.re)throw Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw Error("ephemeral keypair is not set");if(!this.rs)throw Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw Error("static keypair is not set");if(!this.re)throw Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw Error("static keypair is not set");if(!this.re)throw Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw Error("ephemeral keypair is not set");if(!this.rs)throw Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(e,t=0){if(this.re)throw Error("remote ephemeral public key is already set");if(e.byteLength<t+32)throw Error("message is not long enough");this.re=e.sublist(t,t+32),this.ss.mixHash(this.re)}readS(e,t=0){if(this.rs)throw Error("remote static public key is already set");const r=32+(this.ss.cs.hasKey()?16:0);if(e.byteLength<t+r)throw Error("message is not long enough");const n=e.sublist(t,t+r);return this.rs=this.ss.decryptAndHash(n),r}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class Hh extends Vh{writeMessageA(e){return new rs(this.writeE(),this.ss.encryptAndHash(e))}writeMessageB(e){const t=this.writeE();this.writeEE();const r=this.writeS();return this.writeES(),new rs(t,r,this.ss.encryptAndHash(e))}writeMessageC(e){const t=this.writeS();return this.writeSE(),new rs(t,this.ss.encryptAndHash(e))}readMessageA(e){try{return this.readE(e),this.ss.decryptAndHash(e.sublist(32))}catch(e){throw new Bh("handshake stage 0 validation fail: "+e.message)}}readMessageB(e){try{this.readE(e),this.readEE();const t=this.readS(e,32);return this.readES(),this.ss.decryptAndHash(e.sublist(32+t))}catch(e){throw new Bh("handshake stage 1 validation fail: "+e.message)}}readMessageC(e){try{const t=this.readS(e);return this.readSE(),this.ss.decryptAndHash(e.sublist(t))}catch(e){throw new Bh("handshake stage 2 validation fail: "+e.message)}}}var jh,Gh;async function Wh(e,t,r){const n=await e.sign(Zh(t));return Gh.encode({identityKey:Zc(e.publicKey),identitySig:n,extensions:r})}async function Xh(e,t,r){try{const n=Gh.decode(e),s=Xc(n.identityKey);if(!1===r?.equals(s))throw Error(`Payload identity key ${s} does not match expected remote identity key ${r}`);if(!t)throw Error("Remote static does not exist");const i=Zh(t);if(!await s.verify(i,n.identitySig))throw Error("Invalid payload signature");return n}catch(e){throw new ki(e.message)}}function Zh(e){const t=rt("noise-libp2p-static-key:");return e instanceof Uint8Array?Qn([t,e],t.length+e.length):(e.prepend(t),e)}async function Qh(e,t){const{log:r,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=e,u=await Wh(i,a.publicKey,l),h=new Hh({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:o,s:a});Nh(h.s,r),r.trace("Stage 0 - Initiator starting to send first message."),await n.write(h.writeMessageA($h),t),r.trace("Stage 0 - Initiator finished sending first message."),Oh(h.e,r),r.trace("Stage 1 - Initiator waiting to receive first message from responder...");const d=h.readMessageB(await n.read(t));var p,f;r.trace("Stage 1 - Initiator received the message."),Uh(h.re,r),p=h.rs,(f=r).enabled&&Gu&&f(p?"REMOTE_STATIC_PUBLIC_KEY "+ln(p.subarray(),"hex"):"Missing remote static public key."),r.trace("Initiator going to check remote's signature...");const g=await Xh(d,h.rs,c);r.trace("All good with the signature!"),r.trace("Stage 2 - Initiator sending third handshake message."),await n.write(h.writeMessageC(u),t),r.trace("Stage 2 - Initiator sent message with signed payload.");const[m,y]=h.ss.split();return Fh(m,y,r),{payload:g,encrypt(e){return m.encryptWithAd($h,e)},decrypt(e,t){return y.decryptWithAd($h,e,t)}}}(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.webtransportCerthashes)for(const r of e.webtransportCerthashes)t.uint32(10),t.bytes(r);if(null!=e.streamMuxers)for(const r of e.streamMuxers)t.uint32(18),t.string(r);!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{const n={webtransportCerthashes:[],streamMuxers:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:if(null!=r.limits?.webtransportCerthashes&&n.webtransportCerthashes.length===r.limits.webtransportCerthashes)throw new er('Decode error - map field "webtransportCerthashes" had too many elements');n.webtransportCerthashes.push(e.bytes());break;case 2:if(null!=r.limits?.streamMuxers&&n.streamMuxers.length===r.limits.streamMuxers)throw new er('Decode error - map field "streamMuxers" had too many elements');n.streamMuxers.push(e.string());break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(jh||(jh={})),(t=>{let r;t.codec=()=>(null==r&&(r=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.identityKey&&e.identityKey.byteLength>0&&(t.uint32(10),t.bytes(e.identityKey)),null!=e.identitySig&&e.identitySig.byteLength>0&&(t.uint32(18),t.bytes(e.identitySig)),null!=e.extensions&&(t.uint32(34),jh.codec().encode(e.extensions,t)),!1!==r.lengthDelimited&&t.ldelim()},(t,r,n={})=>{const s={identityKey:e(0),identitySig:e(0)},i=null==r?t.len:t.pos+r;for(;t.pos<i;){const e=t.uint32();switch(e>>>3){case 1:s.identityKey=t.bytes();break;case 2:s.identitySig=t.bytes();break;case 4:s.extensions=jh.codec().decode(t,t.uint32(),{limits:n.limits?.extensions});break;default:t.skipType(7&e)}}return s})),r),t.encode=e=>mt(e,t.codec()),t.decode=(e,r)=>T(e,t.codec(),r)})(Gh||(Gh={}));class Yh{protocol="/noise";crypto;prologue;staticKey;extensions;metrics;components;constructor(t,r={}){const{staticNoiseKey:n,extensions:s,crypto:i,prologueBytes:o}=r,{metrics:a}=t;this.components=t;const c=i??Lh;this.crypto=function(e){return{generateKeypair:e.generateX25519KeyPair,dh:(t,r)=>e.generateX25519SharedKey(t.privateKey,r).subarray(0,32),encrypt:e.chaCha20Poly1305Encrypt,decrypt:e.chaCha20Poly1305Decrypt,hash:e.hashSHA256,hkdf:e.getHKDF}}(c),this.extensions={webtransportCerthashes:[],...s},this.metrics=a?function(e){return{xxHandshakeSuccesses:e.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:e.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:e.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:e.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:e.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}(a):void 0,this.staticKey=n?c.generateX25519KeyPairFromSeed(n):c.generateX25519KeyPair(),this.prologue=o??e(0)}[Symbol.toStringTag]="@chainsafe/libp2p-noise";[eo]=["@libp2p/connection-encryption","@chainsafe/libp2p-noise"];async secureOutbound(e,t){const r=Vu(e,{lengthEncoder:Dh,lengthDecoder:Mh,maxDataLength:ju}),n=await this.performHandshakeInitiator(r,this.components.privateKey,t?.remotePeer?.publicKey,t),s=await this.createSecureConnection(r,n);e.source=s.source,e.sink=s.sink;const i=Xc(n.payload.identityKey);return{conn:e,remoteExtensions:n.payload.extensions,remotePeer:sl(i),streamMuxer:!0===t?.skipStreamMuxerNegotiation?void 0:this.getStreamMuxer(n.payload.extensions?.streamMuxers)}}getStreamMuxer(e){if(null==e||0===e.length)return;const t=this.components.upgrader.getStreamMuxers();if(null!=t)for(const r of e){const e=t.get(r);if(null!=e)return e}if(e.length)throw new Ti("Early muxer negotiation was requested but the initiator and responder had no common muxers")}async secureInbound(e,t){const r=Vu(e,{lengthEncoder:Dh,lengthDecoder:Mh,maxDataLength:ju}),n=await this.performHandshakeResponder(r,this.components.privateKey,t?.remotePeer?.publicKey,t),s=await this.createSecureConnection(r,n);e.source=s.source,e.sink=s.sink;const i=Xc(n.payload.identityKey);return{conn:e,remoteExtensions:n.payload.extensions,remotePeer:sl(i),streamMuxer:!0===t?.skipStreamMuxerNegotiation?void 0:this.getStreamMuxer(n.payload.extensions?.streamMuxers)}}async performHandshakeInitiator(e,t,r,n){let s;const i=!0===n?.skipStreamMuxerNegotiation?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{s=await Qh({connection:e,privateKey:t,remoteIdentityKey:r,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:i,webtransportCerthashes:[],...this.extensions}},n),this.metrics?.xxHandshakeSuccesses.increment()}catch(e){throw this.metrics?.xxHandshakeErrors.increment(),e}return s}async performHandshakeResponder(e,t,r,n){let s;const i=!0===n?.skipStreamMuxerNegotiation?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{s=await async function(e,t){const{log:r,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=e,u=await Wh(i,a.publicKey,l),h=new Hh({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:o,s:a});Nh(h.s,r),r.trace("Stage 0 - Responder waiting to receive first message."),h.readMessageA(await n.read(t)),r.trace("Stage 0 - Responder received first message."),Uh(h.re,r),r.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await n.write(h.writeMessageB(u),t),r.trace("Stage 1 - Responder sent the second handshake message with signed payload."),Oh(h.e,r),r.trace("Stage 2 - Responder waiting for third handshake message...");const d=h.readMessageC(await n.read(t));r.trace("Stage 2 - Responder received the message, finished handshake.");const p=await Xh(d,h.rs,c),[f,g]=h.ss.split();return Fh(f,g,r),{payload:p,encrypt:e=>g.encryptWithAd($h,e),decrypt:(e,t)=>f.decryptWithAd($h,e,t)}}({connection:e,privateKey:t,remoteIdentityKey:r,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:i,webtransportCerthashes:[],...this.extensions}},n),this.metrics?.xxHandshakeSuccesses.increment()}catch(e){throw this.metrics?.xxHandshakeErrors.increment(),e}return s}async createSecureConnection(e,t){const[r,n]=function(){const e=Hu(),t=Hu();return[{source:e.source,sink:t.sink},{source:t.source,sink:e.sink}]}(),s=e.unwrap();return await Cs(r,function(e,t){return async function*(r){for await(const n of r)for(let r=0;r<n.length;r+=65519){let s,i=r+65519;i>n.length&&(i=n.length),s=n instanceof Uint8Array?e.encrypt(n.subarray(r,i)):e.encrypt(n.sublist(r,i)),t?.encryptedPackets.increment(),yield new rs(Dh(s.byteLength),s)}}}(t,this.metrics),s,e=>Fu(e,{lengthDecoder:Mh}),function(e,t){return async function*(r){for await(const n of r)for(let r=0;r<n.length;r+=ju){let s=r+ju;if(s>n.length&&(s=n.length),s-16<r)throw Error("Invalid chunk");const i=n.sublist(r,s),o=n.subarray(r,s-16);try{const r=e.decrypt(i,o);t?.decryptedPackets.increment(),yield r}catch(e){throw t?.decryptErrors.increment(),e}}}}(t,this.metrics),r),n}}function Jh(e={}){return t=>new Yh(t,e)}const ed=Rd("dns4"),td=Rd("dns6"),rd=Rd("dnsaddr"),nd=_d(Rd("dns"),rd,ed,td),sd=_d(Rd("ip4"),Rd("ip6")),id=_d(Pd(sd,Rd("tcp")),Pd(nd,Rd("tcp"))),od=Pd(sd,Rd("udp")),ad=Pd(od,Rd("utp")),cd=Pd(od,Rd("quic")),ld=Pd(od,Rd("quic-v1")),ud=_d(Pd(id,Rd("ws")),Pd(nd,Rd("ws"))),hd=_d(Pd(ud,Rd("p2p")),ud),dd=_d(Pd(id,Rd("wss")),Pd(nd,Rd("wss")),Pd(id,Rd("tls"),Rd("ws")),Pd(nd,Rd("tls"),Rd("ws"))),pd=_d(Pd(dd,Rd("p2p")),dd),fd=_d(Pd(id,Rd("http")),Pd(sd,Rd("http")),Pd(nd,Rd("http"))),gd=_d(Pd(id,Rd("https")),Pd(sd,Rd("https")),Pd(nd,Rd("https"))),md=Pd(od,Rd("webrtc-direct"),Rd("certhash")),yd=_d(Pd(md,Rd("p2p")),md),bd=Pd(ld,Rd("webtransport"),Rd("certhash"),Rd("certhash")),wd=_d(Pd(bd,Rd("p2p")),bd),vd=_d(Pd(hd,Rd("p2p-webrtc-star"),Rd("p2p")),Pd(pd,Rd("p2p-webrtc-star"),Rd("p2p")),Pd(hd,Rd("p2p-webrtc-star")),Pd(pd,Rd("p2p-webrtc-star")));_d(Pd(hd,Rd("p2p-websocket-star"),Rd("p2p")),Pd(pd,Rd("p2p-websocket-star"),Rd("p2p")),Pd(hd,Rd("p2p-websocket-star")),Pd(pd,Rd("p2p-websocket-star")));const Ed=_d(Pd(fd,Rd("p2p-webrtc-direct"),Rd("p2p")),Pd(gd,Rd("p2p-webrtc-direct"),Rd("p2p")),Pd(fd,Rd("p2p-webrtc-direct")),Pd(gd,Rd("p2p-webrtc-direct"))),Sd=_d(ud,dd,fd,gd,vd,Ed,id,ad,cd,nd,yd,wd);_d(Pd(Sd,Rd("p2p-stardust"),Rd("p2p")),Pd(Sd,Rd("p2p-stardust")));const Ad=_d(Pd(Sd,Rd("p2p")),vd,Ed,yd,wd,Rd("p2p")),Id=_d(Pd(Ad,Rd("p2p-circuit"),Ad),Pd(Ad,Rd("p2p-circuit")),Pd(Rd("p2p-circuit"),Ad),Pd(Sd,Rd("p2p-circuit")),Pd(Rd("p2p-circuit"),Sd),Rd("p2p-circuit")),Cd=()=>_d(Pd(Id,Cd),Id),xd=Cd(),kd=_d(Pd(xd,Ad,xd),Pd(Ad,xd),Pd(xd,Ad),xd,Ad);function Td(e){return function(t){let r;try{r=Zl(t)}catch(e){return!1}const n=e(r.protoNames());return null!==n&&(!0===n||!1===n?n:0===n.length)}}function Pd(...e){function t(t){if(t.length<e.length)return null;let r=t;return e.some(e=>(r="function"==typeof e?e().partialMatch(t):e.partialMatch(t),Array.isArray(r)&&(t=r),null===r)),r}return{toString(){return"{ "+e.join(" ")+" }"},input:e,matches:Td(t),partialMatch:t}}function _d(...e){function t(t){let r=null;return e.some(e=>{const n="function"==typeof e?e().partialMatch(t):e.partialMatch(t);return null!=n&&(r=n,!0)}),r}return{toString(){return"{ "+e.join(" ")+" }"},input:e,matches:Td(t),partialMatch:t}}function Rd(e){const t=e;return{toString(){return t},matches(e){let r;try{r=Zl(e)}catch(e){return!1}const n=r.protoNames();return 1===n.length&&n[0]===t},partialMatch(e){return 0===e.length?null:e[0]===t?e.slice(1):null}}}_d(Pd(xd,Rd("webrtc"),Rd("p2p")),Pd(xd,Rd("webrtc")),Pd(Sd,Rd("webrtc"),Rd("p2p")),Pd(Sd,Rd("webrtc")),Rd("webrtc"));class Ld extends Yi{static tag="bootstrap";log;timer;list;timeout;components;_init;constructor(e,t={list:[]}){if(null==t.list||0===t.list.length)throw Error("Bootstrap requires a list of peer addresses");super(),this.components=e,this.log=e.logger.forComponent("libp2p:bootstrap"),this.timeout=t.timeout??1e3,this.list=[];for(const e of t.list){if(!kd.matches(e)){this.log.error("Invalid multiaddr");continue}const t=Zl(e),r=t.getPeerId();if(null==r){this.log.error("Invalid bootstrap multiaddr without peer id");continue}const n={id:nl(r),multiaddrs:[t]};this.list.push(n)}this._init=t}[wi]=this;[Symbol.toStringTag]="@libp2p/bootstrap";[eo]=["@libp2p/peer-discovery"];isStarted(){return!!this.timer}start(){this.isStarted()||(this.log("Starting bootstrap node discovery, discovering peers after %s ms",this.timeout),this.timer=setTimeout(()=>{this._discoverBootstrapPeers().catch(e=>{this.log.error(e)})},this.timeout))}async _discoverBootstrapPeers(){if(null!=this.timer)for(const e of this.list){if(await this.components.peerStore.merge(e.id,{tags:{[this._init.tagName??"bootstrap"]:{value:this._init.tagValue??50,ttl:this._init.tagTTL}},multiaddrs:e.multiaddrs}),null==this.timer)return;this.safeDispatchEvent("peer",{detail:e}),this.components.connectionManager.openConnection(e.id).catch(t=>{this.log.error("could not dial bootstrap peer %p",e.id,t)})}}stop(){null!=this.timer&&clearTimeout(this.timer),this.timer=void 0}}var Dd;(t=>{let r;t.codec=()=>(null==r&&(r=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.publicKey&&e.publicKey.byteLength>0&&(t.uint32(10),t.bytes(e.publicKey)),null!=e.payloadType&&e.payloadType.byteLength>0&&(t.uint32(18),t.bytes(e.payloadType)),null!=e.payload&&e.payload.byteLength>0&&(t.uint32(26),t.bytes(e.payload)),null!=e.signature&&e.signature.byteLength>0&&(t.uint32(42),t.bytes(e.signature)),!1!==r.lengthDelimited&&t.ldelim()},(t,r)=>{const n={publicKey:e(0),payloadType:e(0),payload:e(0),signature:e(0)},s=null==r?t.len:t.pos+r;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:n.publicKey=t.bytes();break;case 2:n.payloadType=t.bytes();break;case 3:n.payload=t.bytes();break;case 5:n.signature=t.bytes();break;default:t.skipType(7&e)}}return n})),r),t.encode=e=>mt(e,t.codec()),t.decode=(e,r)=>T(e,t.codec(),r)})(Dd||(Dd={}));class Md extends Error{constructor(e="Invalid signature"){super(e),this.name="InvalidSignatureError"}}class Nd{static createFromProtobuf=e=>{const t=Dd.decode(e),r=Xc(t.publicKey);return new Nd({publicKey:r,payloadType:t.payloadType,payload:t.payload,signature:t.signature})};static seal=async(e,t,r)=>{if(null==t)throw Error("Missing private key");const n=e.domain,s=e.codec,i=e.marshal(),o=Od(n,s,i),a=await t.sign(o.subarray(),r);return new Nd({publicKey:t.publicKey,payloadType:s,payload:i,signature:a})};static openAndCertify=async(e,t,r)=>{const n=Nd.createFromProtobuf(e);if(!await n.validate(t,r))throw new Md("Envelope signature is not valid for the given domain");return n};publicKey;payloadType;payload;signature;marshaled;constructor(e){const{publicKey:t,payloadType:r,payload:n,signature:s}=e;this.publicKey=t,this.payloadType=r,this.payload=n,this.signature=s}marshal(){return null==this.marshaled&&(this.marshaled=Dd.encode({publicKey:Zc(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return null!=e&&Yn(this.marshal(),e.marshal())}async validate(e,t){const r=Od(e,this.payloadType,this.payload);return this.publicKey.verify(r.subarray(),this.signature,t)}}const Od=(e,t,r)=>{const n=rt(e),s=h(n.byteLength),i=h(t.length),o=h(r.length);return new rs(s,n,i,t,o,r)};const Ud=Uint8Array.from([3,1]);var Fd;(t=>{let r;(t=>{let r;t.codec=()=>(null==r&&(r=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.multiaddr&&e.multiaddr.byteLength>0&&(t.uint32(10),t.bytes(e.multiaddr)),!1!==r.lengthDelimited&&t.ldelim()},(t,r)=>{const n={multiaddr:e(0)},s=null==r?t.len:t.pos+r;for(;t.pos<s;){const e=t.uint32();if(e>>>3==1)n.multiaddr=t.bytes();else t.skipType(7&e)}return n})),r),t.encode=e=>mt(e,t.codec()),t.decode=(e,r)=>T(e,t.codec(),r)})(t.AddressInfo||(t.AddressInfo={})),t.codec=()=>(null==r&&(r=Jt((e,r,n={})=>{if(!1!==n.lengthDelimited&&r.fork(),null!=e.peerId&&e.peerId.byteLength>0&&(r.uint32(10),r.bytes(e.peerId)),null!=e.seq&&0n!==e.seq&&(r.uint32(16),r.uint64(e.seq)),null!=e.addresses)for(const n of e.addresses)r.uint32(26),t.AddressInfo.codec().encode(n,r);!1!==n.lengthDelimited&&r.ldelim()},(r,n,s={})=>{const i={peerId:e(0),seq:0n,addresses:[]},o=null==n?r.len:r.pos+n;for(;r.pos<o;){const e=r.uint32();switch(e>>>3){case 1:i.peerId=r.bytes();break;case 2:i.seq=r.uint64();break;case 3:if(null!=s.limits?.addresses&&i.addresses.length===s.limits.addresses)throw new er('Decode error - map field "addresses" had too many elements');i.addresses.push(t.AddressInfo.codec().decode(r,r.uint32(),{limits:s.limits?.addresses$}));break;default:r.skipType(7&e)}}return i})),r),t.encode=e=>mt(e,t.codec()),t.decode=(e,r)=>T(e,t.codec(),r)})(Fd||(Fd={}));class Bd{static createFromProtobuf=e=>{const t=Fd.decode(e),r=il(Oe(t.peerId)),n=(t.addresses??[]).map(e=>Zl(e.multiaddr)),s=t.seq;return new Bd({peerId:r,multiaddrs:n,seqNumber:s})};static DOMAIN="libp2p-peer-record";static CODEC=Ud;peerId;multiaddrs;seqNumber;domain=Bd.DOMAIN;codec=Bd.CODEC;marshaled;constructor(e){const{peerId:t,multiaddrs:r,seqNumber:n}=e;this.peerId=t,this.multiaddrs=r??[],this.seqNumber=n??BigInt(Date.now())}marshal(){return null==this.marshaled&&(this.marshaled=Fd.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(e=>({multiaddr:e.bytes}))})),this.marshaled}equals(e){return e instanceof Bd&&(!!this.peerId.equals(e.peerId)&&(this.seqNumber===e.seqNumber&&!!function(e,t){const r=(e,t)=>e.toString().localeCompare(t.toString());return e.length===t.length&&(t.sort(r),e.sort(r).every((e,r)=>t[r].equals(e)))}(this.multiaddrs,e.multiaddrs)))}}function qd(e,t){let r;const n=()=>{clearTimeout(r),r=setTimeout(()=>{r=void 0,e()},t)};return n.start=()=>{},n.stop=()=>{clearTimeout(r)},n}function $d(e){if(null!=e[Symbol.asyncIterator])return(async()=>{for await(const t of e);})();for(const t of e);}const zd=globalThis.CustomEvent??Event;function Kd(e,t){const r=Vu(e,t),n={async read(e,t){const n=await r.read(t);return e.decode(n)},async write(e,t,n){await r.write(t.encode(e),n)},async writeV(e,t,n){await r.writeV(e.map(e=>t.encode(e)),n)},pb(e){return{async read(t){return n.read(e,t)},async write(t,r){return n.write(t,e,r)},async writeV(t,r){return n.writeV(t,e,r)},unwrap(){return n}}},unwrap(){return r.unwrap()}};return n}var Vd;(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.protocolVersion&&(t.uint32(42),t.string(e.protocolVersion)),null!=e.agentVersion&&(t.uint32(50),t.string(e.agentVersion)),null!=e.publicKey&&(t.uint32(10),t.bytes(e.publicKey)),null!=e.listenAddrs)for(const r of e.listenAddrs)t.uint32(18),t.bytes(r);if(null!=e.observedAddr&&(t.uint32(34),t.bytes(e.observedAddr)),null!=e.protocols)for(const r of e.protocols)t.uint32(26),t.string(r);null!=e.signedPeerRecord&&(t.uint32(66),t.bytes(e.signedPeerRecord)),!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{const n={listenAddrs:[],protocols:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 5:n.protocolVersion=e.string();break;case 6:n.agentVersion=e.string();break;case 1:n.publicKey=e.bytes();break;case 2:if(null!=r.limits?.listenAddrs&&n.listenAddrs.length===r.limits.listenAddrs)throw new er('Decode error - map field "listenAddrs" had too many elements');n.listenAddrs.push(e.bytes());break;case 4:n.observedAddr=e.bytes();break;case 3:if(null!=r.limits?.protocols&&n.protocols.length===r.limits.protocols)throw new er('Decode error - map field "protocols" had too many elements');n.protocols.push(e.string());break;case 8:n.signedPeerRecord=e.bytes();break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(Vd||(Vd={}));const Hd={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:8192,runOnConnectionOpen:!0,runOnLimitedConnection:!0};class jd{host;protocol;started;timeout;peerId;privateKey;peerStore;registrar;addressManager;maxInboundStreams;maxOutboundStreams;maxMessageSize;maxObservedAddresses;events;runOnLimitedConnection;log;constructor(e,t){var r,n;this.protocol=t.protocol,this.started=!1,this.peerId=e.peerId,this.privateKey=e.privateKey,this.peerStore=e.peerStore,this.registrar=e.registrar,this.addressManager=e.addressManager,this.events=e.events,this.log=t.log,this.timeout=t.timeout??Hd.timeout,this.maxInboundStreams=t.maxInboundStreams??Hd.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams??Hd.maxOutboundStreams,this.maxMessageSize=t.maxMessageSize??Hd.maxMessageSize,this.maxObservedAddresses=t.maxObservedAddresses??Hd.maxObservedAddresses,this.runOnLimitedConnection=t.runOnLimitedConnection??Hd.runOnLimitedConnection,this.host={protocolVersion:(t.protocolPrefix??Hd.protocolPrefix)+"/0.1.0",agentVersion:(r=e.nodeInfo,n=t.agentVersion,null!=n?n:r.userAgent)}}isStarted(){return this.started}async start(){this.started||(await this.peerStore.merge(this.peerId,{metadata:{AgentVersion:rt(this.host.agentVersion),ProtocolVersion:rt(this.host.protocolVersion)}}),await this.registrar.handle(this.protocol,e=>{this.handleProtocol(e).catch(e=>{this.log.error(e)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.registrar.unhandle(this.protocol),this.started=!1}}var Gd,Wd={};var Xd=(Gd||(Gd=1,function(){var e,t,r,n,s,i,o,a;a=e=>[(e&255<<24)>>>24,(e&255<<16)>>>16,(65280&e)>>>8,255&e].join("."),o=e=>{var r,n,s,i,o,a;for(r=[],s=i=0;i<=3&&0!==e.length;s=++i){if(s>0){if("."!==e[0])throw Error("Invalid IP");e=e.substring(1)}o=(a=t(e))[0],n=a[1],e=e.substring(n),r.push(o)}if(0!==e.length)throw Error("Invalid IP");switch(r.length){case 1:if(r[0]>4294967295)throw Error("Invalid IP");return r[0]>>>0;case 2:if(r[0]>255||r[1]>16777215)throw Error("Invalid IP");return(r[0]<<24|r[1])>>>0;case 3:if(r[0]>255||r[1]>255||r[2]>65535)throw Error("Invalid IP");return(r[0]<<24|r[1]<<16|r[2])>>>0;case 4:if(r[0]>255||r[1]>255||r[2]>255||r[3]>255)throw Error("Invalid IP");return(r[0]<<24|r[1]<<16|r[2]<<8|r[3])>>>0;default:throw Error("Invalid IP")}},n=(r=e=>e.charCodeAt(0))("0"),i=r("a"),s=r("A"),t=e=>{var t,o,a,c,l;for(c=0,t=10,o="9",a=0,e.length>1&&"0"===e[a]&&("x"===e[a+1]||"X"===e[a+1]?(a+=2,t=16):"0"<=e[a+1]&&e[a+1]<="9"&&(a++,t=8,o="7")),l=a;a<e.length;){if("0"<=e[a]&&e[a]<=o)c=c*t+(r(e[a])-n)>>>0;else{if(16!==t)break;if("a"<=e[a]&&e[a]<="f")c=c*t+(10+r(e[a])-i)>>>0;else{if(!("A"<=e[a]&&e[a]<="F"))break;c=c*t+(10+r(e[a])-s)>>>0}}if(c>4294967295)throw Error("too large");a++}if(a===l)throw Error("empty octet");return[c,a]},e=function(){function e(e,t){var r,n,s;if("string"!=typeof e)throw Error("Missing `net' parameter");if(t||(s=e.split("/",2),e=s[0],t=s[1]),t||(t=32),"string"==typeof t&&t.indexOf(".")>-1){try{this.maskLong=o(t)}catch(e){throw Error("Invalid mask: "+t)}for(r=n=32;n>=0;r=--n)if(this.maskLong===4294967295<<32-r>>>0){this.bitmask=r;break}}else{if(!t&&0!==t)throw Error("Invalid mask: empty");this.bitmask=parseInt(t,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0)}try{this.netLong=(o(e)&this.maskLong)>>>0}catch(t){throw Error("Invalid net address: "+e)}if(!(this.bitmask<=32))throw Error("Invalid mask for ip4: "+t);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return e.prototype.contains=function(t){return"string"==typeof t&&(t.indexOf("/")>0||4!==t.split(".").length)&&(t=new e(t)),t instanceof e?this.contains(t.base)&&this.contains(t.broadcast||t.last):(o(t)&this.maskLong)>>>0==(this.netLong&this.maskLong)>>>0},e.prototype.next=function(t){return null==t&&(t=1),new e(a(this.netLong+this.size*t),this.mask)},e.prototype.forEach=function(e){var t,r,n;for(n=o(this.first),r=o(this.last),t=0;n<=r;)e(a(n),n,t),t++,n++},e.prototype.toString=function(){return this.base+"/"+this.bitmask},e}(),Wd.ip2long=o,Wd.long2ip=a,Wd.Netmask=e}()),Wd);const Zd=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"].map(e=>new Xd.Netmask(e));function Qd(e){for(const t of Zd)if(t.contains(e))return!0;return!1}function Yd(e){return gl(e)?Qd(e):/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(e)?function(e){const t=e.split(":");if(t.length<2)return!1;const r=t[t.length-1].padStart(4,"0"),n=t[t.length-2].padStart(4,"0");return Qd(`${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}.${parseInt(r.substring(0,2),16)}.${parseInt(r.substring(2),16)}`)}(e):function(e){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(e)}(e)?function(e){const t=e.split(":");return Qd(t[t.length-1])}(e):ml(e)?function(e){return/^::$/.test(e)||/^::1$/.test(e)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(e)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(e)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(e)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(e)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(e)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(e)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(e)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(e)||/^ff([0-9a-fA-F]{2,2}):/i.test(e)}(e):void 0}function Jd(e){try{for(const{code:t}of e.getComponents())if(t!==bl)return 4===t||t===yl}catch{}return!1}function ep(e){try{if(!Jd(e))return!1;const[[,t]]=e.stringTuples();return null!=t&&(Yd(t)??!1)}catch{}return!0}const tp=e=>({match(t){return!(t.length<1)&&(!!e(t[0])&&t.slice(1))},pattern:"fn"}),rp=e=>({match(t){return tp(t=>t===e).match(t)},pattern:e}),np=()=>({match(e){return tp(e=>"string"==typeof e).match(e)},pattern:"{string}"}),sp=()=>({match(e){return tp(e=>!isNaN(parseInt(e))).match(e)},pattern:"{number}"}),ip=()=>({match(e){if(e.length<2)return!1;if("p2p"!==e[0]&&"ipfs"!==e[0])return!1;if(!e[1].startsWith("Q")&&!e[1].startsWith("1"))return!1;try{he.decode("z"+e[1])}catch(e){return!1}return e.slice(2)},pattern:"/p2p/{peerid}"}),op=()=>({match(e){if(e.length<2)return!1;if("certhash"!==e[0])return!1;try{me.decode(e[1])}catch{return!1}return e.slice(2)},pattern:"/certhash/{certhash}"}),ap=e=>({match(t){const r=e.match(t);return!1===r?t:r},pattern:`optional(${e.pattern})`}),cp=(...e)=>({match(t){let r;for(const n of e){const e=n.match(t);!1!==e&&((null==r||e.length<r.length)&&(r=e))}return null!=r&&r},pattern:`or(${e.map(e=>e.pattern).join(", ")})`}),lp=(...e)=>({match(t){for(const r of e){const e=r.match(t);if(!1===e)return!1;t=e}return t},pattern:`and(${e.map(e=>e.pattern).join(", ")})`});function up(...e){function t(t){let r=(e=>e.toString().split("/").slice(1))(t);for(const t of e){const e=t.match(r);if(!1===e)return!1;r=e}return r}return{matchers:e,matches(e){return!1!==t(e)},exactMatch(e){const r=t(e);return!1!==r&&0===r.length}}}const hp=up(ip()),dp=lp(rp("dns4"),np()),pp=lp(rp("dns6"),np()),fp=lp(rp("dnsaddr"),np()),gp=lp(rp("dns"),np());up(dp,ap(ip())),up(pp,ap(ip())),up(fp,ap(ip())),up(cp(gp,fp,dp,pp),ap(ip()));const mp=lp(rp("ip4"),tp(gl)),yp=lp(rp("ip6"),tp(ml)),bp=cp(mp,yp),wp=cp(bp,gp,dp,pp,fp),vp=up(cp(bp,lp(cp(gp,fp,dp,pp),ap(ip())))),Ep=up(mp),Sp=up(yp);up(bp);const Ap=lp(wp,rp("tcp"),sp()),Ip=lp(wp,rp("udp"),sp()),Cp=up(lp(Ap,ap(ip())));up(Ip);const xp=lp(Ip,rp("quic"),ap(ip())),kp=lp(Ip,rp("quic-v1"),ap(ip())),Tp=cp(xp,kp);up(xp);const Pp=up(kp),_p=cp(wp,Ap,Ip,xp,kp),Rp=cp(lp(_p,rp("ws"),ap(ip()))),Lp=up(Rp),Dp=cp(lp(_p,rp("wss"),ap(ip())),lp(_p,rp("tls"),ap(lp(rp("sni"),np())),rp("ws"),ap(ip()))),Mp=up(Dp),Np=lp(Ip,rp("webrtc-direct"),ap(op()),ap(op()),ap(ip())),Op=up(Np),Up=lp(kp,rp("webtransport"),ap(op()),ap(op()),ap(ip())),Fp=up(Up),Bp=cp(Rp,Dp,lp(Ap,ap(ip())),lp(Tp,ap(ip())),lp(wp,ap(ip())),Np,Up,ip());up(Bp);const qp=up(lp(Bp,rp("p2p-circuit"),ip())),$p=up(cp(lp(Bp,rp("p2p-circuit"),rp("webrtc"),ap(ip())),lp(Bp,rp("webrtc"),ap(ip())),lp(rp("webrtc"),ap(ip()))));up(cp(lp(wp,rp("tcp"),sp(),rp("http"),ap(ip())),lp(wp,rp("http"),ap(ip()))));up(cp(lp(wp,rp("tcp"),cp(lp(rp("443"),rp("http")),lp(sp(),rp("https")),lp(sp(),rp("tls"),rp("http"))),ap(ip())),lp(wp,rp("tls"),rp("http"),ap(ip())),lp(wp,rp("https"),ap(ip()))));up(cp(lp(rp("memory"),np(),ap(ip()))));up(cp(lp(rp("unix"),np(),ap(ip()))));class zp extends jd{constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??Hd.protocolPrefix}/id/1.0.0`,log:e.logger.forComponent("libp2p:identify")}),(t.runOnConnectionOpen??Hd.runOnConnectionOpen)&&e.events.addEventListener("connection:open",e=>{const t=e.detail;this.identify(t).catch(e=>{e.name!==zi.name&&this.log.error("error during identify trigged by connection:open",e)})})}[eo]=["@libp2p/identify"];async _identify(e,t={}){let r;if(null==t.signal){const e=AbortSignal.timeout(this.timeout);t={...t,signal:e}}try{r=await e.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const n=Kd(r,{maxDataLength:this.maxMessageSize}).pb(Vd),s=await n.read(t);return await r.close(t),s}catch(e){throw r?.abort(e),e}}async identify(e,t={}){const r=await this._identify(e,t),{publicKey:n,protocols:s,observedAddr:i}=r;if(null==n)throw new Ki("public key was missing from identify message");const o=ol(Xc(n).toCID());if(!e.remotePeer.equals(o))throw new Ki("identified peer does not match the expected peer");if(this.peerId.equals(o))throw new Ki("identified peer is our own peer id?");return this.maybeAddObservedAddress(i),this.log("identify completed for peer %p and protocols %o",o,s),async function(e,t,r,n,s){if(r("received identify from %p",n.remotePeer),null==s)throw new Ki("message was null or undefined");const i={};if(s.listenAddrs.length>0&&(i.addresses=s.listenAddrs.map(e=>({isCertified:!1,multiaddr:Zl(e)}))),s.protocols.length>0&&(i.protocols=s.protocols),null!=s.publicKey){const e=Xc(s.publicKey);if(!sl(e).equals(n.remotePeer))throw new Ki("public key did not match remote PeerId");i.publicKey=e}let o;if(null!=s.signedPeerRecord){r.trace("received signedPeerRecord from %p",n.remotePeer);let t=s.signedPeerRecord;const a=await Nd.openAndCertify(t,Bd.DOMAIN);let c=Bd.createFromProtobuf(a.payload);const l=ol(a.publicKey.toCID());if(!c.peerId.equals(l))throw new Ki("signing key does not match PeerId in the PeerRecord");if(!n.remotePeer.equals(c.peerId))throw new Ki("signing key does not match remote PeerId");let u;try{u=await e.get(c.peerId)}catch(e){if("NotFoundError"!==e.name)throw e}if(null!=u&&(i.metadata=u.metadata,null!=u.peerRecordEnvelope)){const e=Nd.createFromProtobuf(u.peerRecordEnvelope),n=Bd.createFromProtobuf(e.payload);n.seqNumber>=c.seqNumber&&(r("sequence number was lower or equal to existing sequence number - stored: %d received: %d",n.seqNumber,c.seqNumber),c=n,t=u.peerRecordEnvelope)}i.peerRecordEnvelope=t,i.addresses=c.multiaddrs.map(e=>({isCertified:!0,multiaddr:e})),o={seq:c.seqNumber,addresses:c.multiaddrs}}else r("%p did not send a signed peer record",n.remotePeer);if(r.trace("patching %p with",n.remotePeer,i),await e.patch(n.remotePeer,i),null!=s.agentVersion||null!=s.protocolVersion){const t={};null!=s.agentVersion&&(t.AgentVersion=rt(s.agentVersion)),null!=s.protocolVersion&&(t.ProtocolVersion=rt(s.protocolVersion)),r.trace("merging %p metadata",n.remotePeer,t),await e.merge(n.remotePeer,{metadata:t})}const a={peerId:n.remotePeer,protocolVersion:s.protocolVersion,agentVersion:s.agentVersion,publicKey:s.publicKey,listenAddrs:s.listenAddrs.map(e=>Zl(e)),observedAddr:null==s.observedAddr?void 0:Zl(s.observedAddr),protocols:s.protocols,signedPeerRecord:o,connection:n};return t.safeDispatchEvent("peer:identify",{detail:a}),a}(this.peerStore,this.events,this.log,e,r)}maybeAddObservedAddress(e){const t=function(e){if(null!=e&&e.length>0)try{return Zl(e)}catch{}}(e);if(null==t)return;if(this.log.trace("our observed address was %a",t),ep(t))return void this.log.trace("our observed address was private");const r=t.getComponents();r[0].code!==yl&&(r[0].code!==bl||r[1].code!==yl)||function(e){try{for(const{code:t,value:r}of e.getComponents())if(null!=r&&t===yl)return Hl("2000::/3",r)}catch{}return!1}(t)?Cp.exactMatch(t)||(this.log.trace("storing the observed address"),this.addressManager.addObservedAddr(t)):this.log.trace("our observed address was IPv6 but not a global unicast address")}async handleProtocol(e){const{connection:t,stream:r}=e,n=AbortSignal.timeout(this.timeout);try{const e=await this.peerStore.get(this.peerId),s=this.addressManager.getAddresses().map(e=>e.decapsulateCode(Ql("p2p").code));let i=e.peerRecordEnvelope;if(s.length>0&&null==i){const e=new Bd({peerId:this.peerId,multiaddrs:s});i=(await Nd.seal(e,this.privateKey)).marshal().subarray()}let o=t.remoteAddr.bytes;vp.matches(t.remoteAddr)||(o=void 0);const a=Kd(r).pb(Vd);await a.write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:Zc(this.privateKey.publicKey),listenAddrs:s.map(e=>e.bytes),signedPeerRecord:i,observedAddr:o,protocols:e.protocols},{signal:n}),await r.close({signal:n})}catch(e){this.log.error("could not respond to identify request",e),r.abort(e)}}}function Kp(e={}){return t=>new zp(t,e)}function Vp(e,t){const r=function(e){if(null!=e){if("function"==typeof e[Symbol.iterator])return e[Symbol.iterator]();if("function"==typeof e[Symbol.asyncIterator])return e[Symbol.asyncIterator]();if("function"==typeof e.next)return e}throw Error("argument is not an iterator or iterable")}(e).return?.();var n;null!=(n=r)&&"function"==typeof n.then&&"function"==typeof n.catch&&"function"==typeof n.finally&&r.catch(e=>{t.error("could not cause iterator to return",e)})}const Hp=()=>{const e=Error("Delay aborted");return e.name="AbortError",e},jp=new WeakMap;const Gp=function({clearTimeout:e,setTimeout:t}={}){return(r,{value:n,signal:s}={})=>{if(s?.aborted)return Promise.reject(Hp());let i,o,a;const c=e??clearTimeout,l=()=>{c(i),a(Hp())},u=new Promise((e,c)=>{o=()=>{s&&s.removeEventListener("abort",l),e(n)},a=c,i=(t??setTimeout)(o,r)});return s&&s.addEventListener("abort",l,{once:!0}),jp.set(u,()=>{c(i),i=null,o()}),u}}();class Wp extends Error{remainingPoints;msBeforeNext;consumedPoints;isFirstInDuration;constructor(e="Rate limit exceeded",t){super(e),this.name="RateLimitError",this.remainingPoints=t.remainingPoints,this.msBeforeNext=t.msBeforeNext,this.consumedPoints=t.consumedPoints,this.isFirstInDuration=t.isFirstInDuration}}let Xp=class extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}};class Zp{memoryStorage;points;duration;blockDuration;execEvenly;execEvenlyMinDelayMs;keyPrefix;constructor(e={}){this.points=e.points??4,this.duration=e.duration??1,this.blockDuration=e.blockDuration??0,this.execEvenly=e.execEvenly??!1,this.execEvenlyMinDelayMs=e.execEvenlyMinDelayMs??1e3*this.duration/this.points,this.keyPrefix=e.keyPrefix??"rlflx",this.memoryStorage=new Qp}async consume(e,t=1,r={}){const n=this.getKey(e),s=this._getKeySecDuration(r);let i=this.memoryStorage.incrby(n,t,s);if(i.remainingPoints=Math.max(this.points-i.consumedPoints,0),i.consumedPoints>this.points)throw this.blockDuration>0&&i.consumedPoints<=this.points+t&&(i=this.memoryStorage.set(n,i.consumedPoints,this.blockDuration)),new Wp("Rate limit exceeded",i);if(this.execEvenly&&i.msBeforeNext>0&&!i.isFirstInDuration){let e=Math.ceil(i.msBeforeNext/(i.remainingPoints+2));e<this.execEvenlyMinDelayMs&&(e=i.consumedPoints*this.execEvenlyMinDelayMs),await Gp(e)}return i}penalty(e,t=1,r={}){const n=this.getKey(e),s=this._getKeySecDuration(r),i=this.memoryStorage.incrby(n,t,s);return i.remainingPoints=Math.max(this.points-i.consumedPoints,0),i}reward(e,t=1,r={}){const n=this.getKey(e),s=this._getKeySecDuration(r),i=this.memoryStorage.incrby(n,-t,s);return i.remainingPoints=Math.max(this.points-i.consumedPoints,0),i}block(e,t){const r=1e3*t,n=this.points+1;return this.memoryStorage.set(this.getKey(e),n,t),{remainingPoints:0,msBeforeNext:0===r?-1:r,consumedPoints:n,isFirstInDuration:!1}}set(e,t,r=0){const n=1e3*(r>=0?r:this.duration);return this.memoryStorage.set(this.getKey(e),t,r),{remainingPoints:0,msBeforeNext:0===n?-1:n,consumedPoints:t,isFirstInDuration:!1}}get(e){const t=this.memoryStorage.get(this.getKey(e));return null!=t&&(t.remainingPoints=Math.max(this.points-t.consumedPoints,0)),t}delete(e){this.memoryStorage.delete(this.getKey(e))}_getKeySecDuration(e){return null!=e?.customDuration&&e.customDuration>=0?e.customDuration:this.duration}getKey(e){return this.keyPrefix.length>0?`${this.keyPrefix}:${e}`:e}parseKey(e){return e.substring(this.keyPrefix.length)}}class Qp{storage;constructor(){this.storage=new Map}incrby(e,t,r){const n=this.storage.get(e);if(null!=n){const s=null!=n.expiresAt?n.expiresAt.getTime()-(new Date).getTime():-1;return null==n.expiresAt||s>0?(n.value+=t,{remainingPoints:0,msBeforeNext:s,consumedPoints:n.value,isFirstInDuration:!1}):this.set(e,t,r)}return this.set(e,t,r)}set(e,t,r){const n=1e3*r,s=this.storage.get(e);null!=s&&clearTimeout(s.timeoutId);const i={value:t,expiresAt:n>0?new Date(Date.now()+n):void 0};return this.storage.set(e,i),n>0&&(i.timeoutId=setTimeout(()=>{this.storage.delete(e)},n),null!=i.timeoutId.unref&&i.timeoutId.unref()),{remainingPoints:0,msBeforeNext:0===n?-1:n,consumedPoints:i.value,isFirstInDuration:!0}}get(e){const t=this.storage.get(e);if(null!=t){return{remainingPoints:0,msBeforeNext:null!=t.expiresAt?t.expiresAt.getTime()-(new Date).getTime():-1,consumedPoints:t.value,isFirstInDuration:!1}}}delete(e){const t=this.storage.get(e);return null!=t&&(null!=t.timeoutId&&clearTimeout(t.timeoutId),this.storage.delete(e),!0)}}var Yp;(e=>{e[e.NEW_STREAM=0]="NEW_STREAM",e[e.MESSAGE_RECEIVER=1]="MESSAGE_RECEIVER",e[e.MESSAGE_INITIATOR=2]="MESSAGE_INITIATOR",e[e.CLOSE_RECEIVER=3]="CLOSE_RECEIVER",e[e.CLOSE_INITIATOR=4]="CLOSE_INITIATOR",e[e.RESET_RECEIVER=5]="RESET_RECEIVER",e[e.RESET_INITIATOR=6]="RESET_INITIATOR"})(Yp||(Yp={}));const Jp=Object.freeze({0:"NEW_STREAM",1:"MESSAGE_RECEIVER",2:"MESSAGE_INITIATOR",3:"CLOSE_RECEIVER",4:"CLOSE_INITIATOR",5:"RESET_RECEIVER",6:"RESET_INITIATOR"}),ef=Object.freeze({NEW_STREAM:Yp.NEW_STREAM,MESSAGE:Yp.MESSAGE_INITIATOR,CLOSE:Yp.CLOSE_INITIATOR,RESET:Yp.RESET_INITIATOR}),tf=Object.freeze({MESSAGE:Yp.MESSAGE_RECEIVER,CLOSE:Yp.CLOSE_RECEIVER,RESET:Yp.RESET_RECEIVER}),rf=1<<20;class nf{_buffer;_headerInfo;_maxMessageSize;_maxUnprocessedMessageQueueSize;constructor(e=rf,t=4194304){this._buffer=new rs,this._headerInfo=null,this._maxMessageSize=e,this._maxUnprocessedMessageQueueSize=t}write(e){if(null==e||0===e.length)return[];if(this._buffer.append(e),this._buffer.byteLength>this._maxUnprocessedMessageQueueSize)throw new Ki("Unprocessed message queue size too large!");const t=[];for(;0!==this._buffer.length;){if(null==this._headerInfo)try{this._headerInfo=this._decodeHeader(this._buffer)}catch(e){if("InvalidMessageError"===e.name)throw e;break}const{id:e,type:r,length:n,offset:s}=this._headerInfo;if(this._buffer.length-s<n)break;const i={id:e,type:r};r!==Yp.NEW_STREAM&&r!==Yp.MESSAGE_INITIATOR&&r!==Yp.MESSAGE_RECEIVER||(i.data=this._buffer.sublist(s,s+n)),t.push(i),this._buffer.consume(s+n),this._headerInfo=null}return t}_decodeHeader(e){const{value:t,offset:r}=af(e),{value:n,offset:s}=af(e,r),i=7&t;if(null==Jp[i])throw Error("Invalid type received: "+i);if(n>this._maxMessageSize)throw new Ki("Message size too large");return{id:t>>3,type:i,offset:r+s,length:n}}}const sf=128,of=127;function af(e,t=0){let r,n=0,s=0,i=t;const o=e.length;do{if(i>=o||s>49)throw t=0,new RangeError("Could not decode varint");r=e.get(i++),n+=s<28?(r&of)<<s:(r&of)*Math.pow(2,s),s+=7}while(r>=sf);return{value:n,offset:t=i-t}}const cf=10240;const lf=new class{_pool;_poolOffset;constructor(){this._pool=t(cf),this._poolOffset=0}write(e,r){const n=this._pool;let s=this._poolOffset;h(e.id<<3|e.type,n,s),s+=c(e.id<<3|e.type),e.type!==Yp.NEW_STREAM&&e.type!==Yp.MESSAGE_INITIATOR&&e.type!==Yp.MESSAGE_RECEIVER||null==e.data?(h(0,n,s),s+=c(0)):(h(e.data.length,n,s),s+=c(e.data.length));const i=n.subarray(this._poolOffset,s);cf-s<100?(this._pool=t(cf),this._poolOffset=0):this._poolOffset=s,r.append(i),e.type!==Yp.NEW_STREAM&&e.type!==Yp.MESSAGE_INITIATOR&&e.type!==Yp.MESSAGE_RECEIVER||null==e.data||r.append(e.data)}};class uf extends Error{constructor(e="Stream input buffer error"){super(e),this.name="StreamInputBufferError"}}function hf(e){return null!=e&&("function"==typeof e.then&&"function"==typeof e.catch&&"function"==typeof e.finally)}class df{id;direction;timeline;protocol;metadata;source;status;readStatus;writeStatus;log;sinkController;sinkEnd;closed;endErr;streamSource;onEnd;onCloseRead;onCloseWrite;onReset;onAbort;sendCloseWriteTimeout;sendingData;constructor(e){this.sinkController=new AbortController,this.sinkEnd=ps(),this.closed=ps(),this.log=e.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=e.id,this.metadata=e.metadata??{},this.direction=e.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=e.sendCloseWriteTimeout??5e3,this.onEnd=e.onEnd,this.onCloseRead=e.onCloseRead,this.onCloseWrite=e.onCloseWrite,this.onReset=e.onReset,this.onAbort=e.onAbort,this.source=this.streamSource=ys({onEnd:e=>{null!=e?this.log.trace("source ended with error",e):this.log.trace("source ended"),this.onSourceEnd(e)}}),this.sink=this.sink.bind(this)}async sink(e){if("ready"!==this.writeStatus)throw new Oi(`writable end state is "${this.writeStatus}" not "ready"`);try{this.writeStatus="writing";const t={signal:this.sinkController.signal};if("outbound"===this.direction){const e=this.sendNewStream(t);hf(e)&&await e}const r=()=>{Vp(e,this.log)};try{this.sinkController.signal.addEventListener("abort",r),this.log.trace("sink reading from source");for await(let r of e){r=r instanceof Uint8Array?new rs(r):r;const e=this.sendData(r,t);hf(e)&&(this.sendingData=ps(),await e,this.sendingData.resolve(),this.sendingData=void 0)}}finally{this.sinkController.signal.removeEventListener("abort",r)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),"writing"===this.writeStatus&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(e){throw this.log.trace("sink ended with error, calling abort with error",e),this.abort(e),e}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(e){null==this.timeline.closeRead&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",null!=e&&null==this.endErr&&(this.endErr=e),this.onCloseRead?.(),null!=this.timeline.closeWrite?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),"aborted"!==this.status&&"reset"!==this.status&&(this.status="closed"),null!=this.onEnd&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(e){null==this.timeline.closeWrite&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",null!=e&&null==this.endErr&&(this.endErr=e),this.onCloseWrite?.(),null!=this.timeline.closeRead?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),"aborted"!==this.status&&"reset"!==this.status&&(this.status="closed"),null!=this.onEnd&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(e){"open"===this.status&&(this.log.trace("closing gracefully"),this.status="closing",await ws(Promise.all([this.closeWrite(e),this.closeRead(e),this.closed.promise]),e?.signal),this.status="closed",this.log.trace("closed gracefully"))}async closeRead(e={}){if("closing"===this.readStatus||"closed"===this.readStatus)return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);const t=this.readStatus;this.readStatus="closing","reset"!==this.status&&"aborted"!==this.status&&null==this.timeline.closeRead&&(this.log.trace("send close read to remote"),await this.sendCloseRead(e)),"ready"===t&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(e={}){"closing"!==this.writeStatus&&"closed"!==this.writeStatus&&(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),"ready"===this.writeStatus&&(this.log.trace("sink was never sunk, sink an empty array"),await ws(this.sink([]),e.signal)),"writing"===this.writeStatus&&(null!=this.sendingData&&await ws(this.sendingData.promise,e.signal),this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),await ws(this.sinkEnd.promise,e.signal)),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(e){if("closed"===this.status||"aborted"===this.status||"reset"===this.status)return;this.log("abort with error",e),this.log("try to send reset to remote");const t=this.sendReset();hf(t)&&t.catch(e=>{this.log.error("error sending reset message",e)}),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(e),this.onAbort?.(e)}reset(){if("closed"===this.status||"aborted"===this.status||"reset"===this.status)return;const e=new Ni("stream reset");this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(e),this.onReset?.()}_closeSinkAndSource(e){this._closeSink(e),this._closeSource(e)}_closeSink(e){"writing"===this.writeStatus&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(e)}_closeSource(e){"closing"!==this.readStatus&&"closed"!==this.readStatus&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(e))}remoteCloseWrite(){"closing"!==this.readStatus&&"closed"!==this.readStatus?(this.log.trace("remote close write"),this._closeSource()):this.log("received remote close write but local source is already closed")}remoteCloseRead(){"closing"!==this.writeStatus&&"closed"!==this.writeStatus?(this.log.trace("remote close read"),this._closeSink()):this.log("received remote close read but local sink is already closed")}destroy(){"closed"!==this.status&&"aborted"!==this.status&&"reset"!==this.status?(this.log.trace("stream destroyed"),this._closeSinkAndSource()):this.log("received destroy but we are already closed")}sourcePush(e){this.streamSource.push(e)}sourceReadableLength(){return this.streamSource.readableLength}}class pf extends df{name;streamId;send;types;maxDataSize;constructor(e){super(e),this.types="outbound"===e.direction?ef:tf,this.send=e.send,this.name=e.name,this.streamId=e.streamId,this.maxDataSize=e.maxDataSize}async sendNewStream(){await this.send({id:this.streamId,type:ef.NEW_STREAM,data:new rs(rt(this.name))})}async sendData(e){for(e=e.sublist();e.byteLength>0;){const t=Math.min(e.byteLength,this.maxDataSize);await this.send({id:this.streamId,type:this.types.MESSAGE,data:e.sublist(0,t)}),e.consume(t)}}async sendReset(){await this.send({id:this.streamId,type:this.types.RESET})}async sendCloseWrite(){await this.send({id:this.streamId,type:this.types.CLOSE})}async sendCloseRead(){}}function ff(e){const t={...e,type:`${Jp[e.type]} (${e.type})`};return e.type===Yp.NEW_STREAM&&(t.data=ln(e.data instanceof Uint8Array?e.data:e.data.subarray())),e.type!==Yp.MESSAGE_INITIATOR&&e.type!==Yp.MESSAGE_RECEIVER||(t.data=ln(e.data instanceof Uint8Array?e.data:e.data.subarray(),"base16")),t}class gf{protocol="/mplex/6.7.0";sink;source;log;_streamId;_streams;_init;_source;closeController;rateLimiter;closeTimeout;logger;constructor(e,t){t=t??{},this.log=e.logger.forComponent("libp2p:mplex"),this.logger=e.logger,this._streamId=0,this._streams={initiators:new Map,receivers:new Map},this._init=t,this.closeTimeout=t.closeTimeout??500,this.sink=this._createSink(),this._source=ys({objectMode:!0,onEnd:()=>{for(const e of this._streams.initiators.values())e.destroy();for(const e of this._streams.receivers.values())e.destroy()}}),this.source=Cs(this._source,e=>async function*(e){for await(const t of e){const e=new rs;lf.write(t,e),yield e}}(e)),this.closeController=new AbortController,this.rateLimiter=new Zp({points:t.disconnectThreshold??5,duration:1})}get streams(){const e=[];for(const t of this._streams.initiators.values())e.push(t);for(const t of this._streams.receivers.values())e.push(t);return e}newStream(e){if(this.closeController.signal.aborted)throw new Mi("Muxer already closed");const t=this._streamId++;e=null==e?t.toString():e.toString();const r=this._streams.initiators;return this._newStream({id:t,name:e,type:"initiator",registry:r})}async close(e){if(this.closeController.signal.aborted)return;const t=e?.signal??AbortSignal.timeout(this.closeTimeout);try{await Promise.all(this.streams.map(async e=>e.close({signal:t}))),this._source.end(),await this._source.onEmpty({signal:t}),this.closeController.abort()}catch(e){this.abort(e)}}abort(e){this.closeController.signal.aborted||(this.streams.forEach(t=>{t.abort(e)}),this.closeController.abort(e))}_newReceiverStream(e){const{id:t,name:r}=e,n=this._streams.receivers;return this._newStream({id:t,name:r,type:"receiver",registry:n})}_newStream(e){const{id:t,name:r,type:n,registry:s}=e;if(this.log("new %s stream %s",n,t),"initiator"===n&&this._streams.initiators.size===(this._init.maxOutboundStreams??1024))throw new Zi("Too many outbound streams open");if(s.has(t))throw Error(`${n} stream ${t} already exists!`);const i=function(e){const{id:t,name:r,send:n,onEnd:s,type:i="initiator",maxMsgSize:o=rf}=e;return new pf({id:"initiator"===i?"i"+t:"r"+t,streamId:t,name:""+(r??t),direction:"initiator"===i?"outbound":"inbound",maxDataSize:o,onEnd:s,send:n,log:e.logger.forComponent(`libp2p:mplex:stream:${i}:${t}`)})}({id:t,name:r,send:async e=>{this.log.enabled&&this.log.trace("%s stream %s send",n,t,ff(e)),this._source.push(e)},type:n,onEnd:()=>{this.log("%s stream with id %s and protocol %s ended",n,t,i.protocol),s.delete(t),null!=this._init.onStreamEnd&&this._init.onStreamEnd(i)},maxMsgSize:this._init.maxMsgSize,logger:this.logger});return s.set(t,i),i}_createSink(){return async e=>{const t=()=>{Vp(e,this.log)};this.closeController.signal.addEventListener("abort",t);try{const t=new nf(this._init.maxMsgSize,this._init.maxUnprocessedMessageQueueSize);for await(const r of e)for(const e of t.write(r))await this._handleIncoming(e);this._source.end()}catch(e){this.log("error in sink",e),this._source.end(e)}finally{this.closeController.signal.removeEventListener("abort",t)}}}async _handleIncoming(e){const{id:t,type:r}=e;if(this.log.enabled&&this.log.trace("incoming message",ff(e)),e.type===Yp.NEW_STREAM){if(this._streams.receivers.size===(this._init.maxInboundStreams??1024)){this.log("too many inbound streams open"),this._source.push({id:t,type:Yp.RESET_RECEIVER});try{await this.rateLimiter.consume("new-stream",1)}catch{return this.log("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection"),void this.abort(Error("Too many open streams"))}return}const r=this._newReceiverStream({id:t,name:ln(e.data instanceof Uint8Array?e.data:e.data.subarray())});return void(null!=this._init.onIncomingStream&&this._init.onIncomingStream(r))}const n=(1&~r?this._streams.receivers:this._streams.initiators).get(t);if(null==n){this.log("missing stream %s for message type %s",t,Jp[r]);try{await this.rateLimiter.consume("missing-stream",1)}catch{return this.log("rate limit hit when receiving messages for streams that do not exist - closing remote connection"),void this.abort(Error("Too many messages for missing streams"))}return}const s=this._init.maxStreamBufferSize??4194304;try{switch(r){case Yp.MESSAGE_INITIATOR:case Yp.MESSAGE_RECEIVER:if(n.sourceReadableLength()>s)throw this._source.push({id:e.id,type:r===Yp.MESSAGE_INITIATOR?Yp.RESET_RECEIVER:Yp.RESET_INITIATOR}),new uf("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers");n.sourcePush(e.data);break;case Yp.CLOSE_INITIATOR:case Yp.CLOSE_RECEIVER:n.remoteCloseWrite();break;case Yp.RESET_INITIATOR:case Yp.RESET_RECEIVER:n.reset();break;default:this.log("unknown message type %s",r)}}catch(e){this.log.error("error while processing message",e),n.abort(e)}}}class mf{protocol="/mplex/6.7.0";_init;components;constructor(e,t={}){this.components=e,this._init=t}[Symbol.toStringTag]="@libp2p/mplex";[eo]=["@libp2p/stream-multiplexing"];createStreamMuxer(e={}){return new gf(this.components,{...e,...this._init})}}function yf(e={}){return t=>new mf(t,e)}class bf{protocol;components;started;timeout;maxInboundStreams;maxOutboundStreams;runOnLimitedConnection;log;constructor(e,t={}){this.components=e,this.log=e.logger.forComponent("libp2p:ping"),this.started=!1,this.protocol=`/${t.protocolPrefix??"ipfs"}/ping/1.0.0`,this.timeout=t.timeout??1e4,this.maxInboundStreams=t.maxInboundStreams??2,this.maxOutboundStreams=t.maxOutboundStreams??1,this.runOnLimitedConnection=t.runOnLimitedConnection??!0,this.handleMessage=this.handleMessage.bind(this)}[Symbol.toStringTag]="@libp2p/ping";[eo]=["@libp2p/ping"];async start(){await this.components.registrar.handle(this.protocol,this.handleMessage,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}handleMessage(e){this.log("incoming ping from %p",e.connection.remotePeer);const{stream:t}=e,r=Date.now(),n=qu(t);let s=!1;Promise.resolve().then(async()=>{for(;;){const e=AbortSignal.timeout(this.timeout);e.addEventListener("abort",()=>{t?.abort(new Hi("ping timeout"))});const r=await n.read({bytes:32,signal:e});await n.write(r,{signal:e}),s=!0}}).catch(r=>{s&&"UnexpectedEOFError"===r.name&&"ready"!==t.readStatus||(this.log.error("incoming ping from %p failed with error - %e",e.connection.remotePeer,r),t?.abort(r))}).finally(()=>{const n=Date.now()-r;this.log("incoming ping from %p complete in %dms",e.connection.remotePeer,n);const s=AbortSignal.timeout(this.timeout);t.close({signal:s}).catch(r=>{this.log.error("error closing ping stream from %p - %e",e.connection.remotePeer,r),t?.abort(r)})})}async ping(e,t={}){this.log("pinging %p",e);const r=Date.now(),n=bc(32),s=await this.components.connectionManager.openConnection(e,t);let i;if(null==t.signal){const e=AbortSignal.timeout(this.timeout);t={...t,signal:e}}try{i=await s.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const e=qu(i),[,o]=await Promise.all([e.write(n,t),e.read({...t,bytes:32})]),a=Date.now()-r;if(!Yn(n,o.subarray()))throw new Vi(`Received wrong ping ack after ${a}ms`);return this.log("ping %p complete in %dms",s.remotePeer,a),a}catch(e){throw this.log.error("error while pinging %p",s.remotePeer,e),i?.abort(e),e}finally{null!=i&&await i.close(t)}}}function wf(e={}){return t=>new bf(t,e)}const vf=[6,53,56,54,55];function Ef(e){return Af("sni",e)?.value}function Sf(e){const t=Af("tcp",e)?.value;return null==t?"":":"+t}function Af(e,t){return t.find(t=>t.name===e)}function If(e){return e.some(({code:e})=>448===e)}function Cf(e,t){const r=xf[e.name];if(null==r)throw Error("Can't interpret protocol "+e.name);const n=r(e,t);return e.code===yl?`[${n}]`:n}const xf={ip4(e){return e.value},ip6(e,t){return 0===t.length?e.value:`[${e.value}]`},tcp(e,t){const r=t.pop();if(null==r)throw Error("Unexpected end of multiaddr");return`tcp://${Cf(r,t)}:${e.value}`},udp(e,t){const r=t.pop();if(null==r)throw Error("Unexpected end of multiaddr");return`udp://${Cf(r,t)}:${e.value}`},dnsaddr(e){return e.value},dns4(e){return e.value},dns6(e){return e.value},dns(e){return e.value},ipfs(e,t){const r=t.pop();if(null==r)throw Error("Unexpected end of multiaddr");return""+Cf(r,t)},p2p(e,t){const r=t.pop();if(null==r)throw Error("Unexpected end of multiaddr");return""+Cf(r,t)},http(e,t){const r=If(t),n=Ef(t),s=Sf(t);if(r&&null!=n)return`https://${n}${s}`;const i=r?"https://":"http://",o=t.pop();if(null==o)throw Error("Unexpected end of multiaddr");let a=Cf(o,t);return a=a?.replace("tcp://",""),`${i}${a}`},"http-path"(e,t){const r=t.pop();if(null==r)throw Error("Unexpected end of multiaddr");return`${Cf(r,t)}${decodeURIComponent(e.value??"")}`},tls(e,t){const r=t.pop();if(null==r)throw Error("Unexpected end of multiaddr");return Cf(r,t)},sni(e,t){const r=t.pop();if(null==r)throw Error("Unexpected end of multiaddr");return Cf(r,t)},https(e,t){const r=t.pop();if(null==r)throw Error("Unexpected end of multiaddr");let n=Cf(r,t);return n=n?.replace("tcp://",""),"https://"+n},ws(e,t){const r=If(t),n=Ef(t),s=Sf(t);if(r&&null!=n)return`wss://${n}${s}`;const i=r?"wss://":"ws://",o=t.pop();if(null==o)throw Error("Unexpected end of multiaddr");let a=Cf(o,t);return a=a?.replace("tcp://",""),`${i}${a}`},wss(e,t){const r=t.pop();if(null==r)throw Error("Unexpected end of multiaddr");let n=Cf(r,t);return n=n?.replace("tcp://",""),"wss://"+n}};var kf,Tf,Pf=async e=>{if(e.readyState>=2)throw Error("socket closed");1!==e.readyState&&await new Promise((t,r)=>{function n(){e.removeEventListener("open",s),e.removeEventListener("error",i)}function s(){n(),t()}function i(t){n(),r(t.error??Error("connect ECONNREFUSED "+e.url))}e.addEventListener("open",s),e.addEventListener("error",i)})},_f=(e,t)=>{(t=t??{}).closeOnEnd=!1!==t.closeOnEnd;return async r=>{for await(const t of r){try{await Pf(e)}catch(e){if("socket closed"===e.message)break;throw e}if(e.readyState===e.CLOSING||e.readyState===e.CLOSED)break;e.send(t)}null!=t.closeOnEnd&&e.readyState<=1&&await new Promise((t,r)=>{e.addEventListener("close",e=>{if(e.wasClean||1006===e.code)t();else{const t=Object.assign(Error("ws error"),{event:e});r(t)}}),setTimeout(()=>{e.close()})})}},Rf={},Lf={};var Df=function(){if(Tf)return Rf;Tf=1,Object.defineProperty(Rf,"__esModule",{value:!0});const e=function(){if(kf)return Lf;kf=1,Object.defineProperty(Lf,"__esModule",{value:!0});class e{constructor(){this.pullQueue=[],this.pushQueue=[],this.eventHandlers={},this.isPaused=!1,this.isStopped=!1}push(e){if(this.isStopped)return;const t={value:e,done:!1};if(this.pullQueue.length){const e=this.pullQueue.shift();e&&e.resolve(t)}else this.pushQueue.push(Promise.resolve(t)),void 0!==this.highWaterMark&&this.pushQueue.length>=this.highWaterMark&&!this.isPaused&&(this.isPaused=!0,this.eventHandlers.highWater?this.eventHandlers.highWater():console&&console.warn(`EventIterator queue reached ${this.pushQueue.length} items`))}stop(){if(!this.isStopped){this.isStopped=!0,this.remove();for(const e of this.pullQueue)e.resolve({value:void 0,done:!0});this.pullQueue.length=0}}fail(e){if(!this.isStopped)if(this.isStopped=!0,this.remove(),this.pullQueue.length){for(const t of this.pullQueue)t.reject(e);this.pullQueue.length=0}else{const t=Promise.reject(e);t.catch(()=>{}),this.pushQueue.push(t)}}remove(){Promise.resolve().then(()=>{this.removeCallback&&this.removeCallback()})}[Symbol.asyncIterator](){return{next:()=>{const e=this.pushQueue.shift();return e?(void 0!==this.lowWaterMark&&this.pushQueue.length<=this.lowWaterMark&&this.isPaused&&(this.isPaused=!1,this.eventHandlers.lowWater&&this.eventHandlers.lowWater()),e):this.isStopped?Promise.resolve({value:void 0,done:!0}):new Promise((e,t)=>{this.pullQueue.push({resolve:e,reject:t})})},return:()=>(this.isStopped=!0,this.pushQueue.length=0,this.remove(),Promise.resolve({value:void 0,done:!0}))}}}class t{constructor(t,{highWaterMark:r=100,lowWaterMark:n=1}={}){const s=new e;s.highWaterMark=r,s.lowWaterMark=n,s.removeCallback=t({push:e=>s.push(e),stop:()=>s.stop(),fail:e=>s.fail(e),on(e,t){s.eventHandlers[e]=t}})||(()=>{}),this[Symbol.asyncIterator]=()=>s[Symbol.asyncIterator](),Object.freeze(this)}}return Lf.EventIterator=t,Lf.default=t,Lf}();return Rf.EventIterator=e.EventIterator,Rf.subscribe=function(t,r,n){return new e.EventIterator(({push:e})=>(this.addEventListener(t,e,r),()=>this.removeEventListener(t,e,r)),n)},Rf.default=e.EventIterator,Rf}();function Mf(e){return e instanceof ArrayBuffer||"ArrayBuffer"===e?.constructor?.name&&"number"==typeof e?.byteLength}var Nf=(e,t)=>{t=t??{};const r=(e=>{e.binaryType="arraybuffer";const t=async()=>{await new Promise((t,r)=>{if(s)return void t();if(null!=n)return void r(n);const i=t=>{e.removeEventListener("open",o),e.removeEventListener("error",a),t()},o=()=>{i(t)},a=t=>{i(()=>{r(t.error??Error("connect ECONNREFUSED "+e.url))})};e.addEventListener("open",o),e.addEventListener("error",a)})},r=async function*(){const r=new Df.EventIterator(({push:t,stop:r,fail:n})=>{const s=e=>{let r=null;"string"==typeof e.data&&(r=rt(e.data)),Mf(e.data)&&(r=new Uint8Array(e.data)),e.data instanceof Uint8Array&&(r=e.data),null!=r&&t(r)},i=e=>{n(e.error??Error("Socket error"))};return e.addEventListener("message",s),e.addEventListener("error",i),e.addEventListener("close",r),()=>{e.removeEventListener("message",s),e.removeEventListener("error",i),e.removeEventListener("close",r)}},{highWaterMark:1/0});await t();for await(const e of r)yield Mf(e)?new Uint8Array(e):e}();let n,s=1===e.readyState;return e.addEventListener("open",()=>{s=!0,n=null}),e.addEventListener("close",()=>{s=!1,n=null}),e.addEventListener("error",t=>{s||(n=t.error??Error("connect ECONNREFUSED "+e.url))}),Object.assign(r,{connected:t})})(e);let n=t.remoteAddress,s=t.remotePort;if(null!=e.url)try{const t=new URL(e.url);n=t.hostname,s=parseInt(t.port,10)}catch{}if(null==n||null==s)throw Error("Remote connection did not have address and/or port");return{sink:_f(e,t),source:r,async connected(){await r.connected()},async close(){e.readyState!==e.CONNECTING&&e.readyState!==e.OPEN||await new Promise(t=>{e.addEventListener("close",()=>{t()}),e.close()})},destroy(){null!=e.terminate?e.terminate():e.close()},remoteAddress:n,remotePort:s,socket:e}},Of=WebSocket;const Uf={"http:":"ws:","https:":"wss:"};function Ff(e,t){t=t??{};const r=((e,t)=>{if(e.startsWith("//")&&(e=`${t?.protocol??"ws:"}${e}`),e.startsWith("/")&&null!=t){const r=t.protocol??"ws:",n=t.host,s=null!=t.port&&!0!==n?.endsWith(":"+t.port)?":"+t.port:"";e=`${r}//${n}${s}${e}`}const r=new URL(e);for(const[e,t]of Object.entries(Uf))r.protocol===e&&(r.protocol=t);return r})(e,"undefined"==typeof window?void 0:window.location),n=new Of(r.toString(),t.websocket);return Nf(n,t)}class Bf extends Event{type;detail;constructor(e,t){super(e),this.type=e,this.detail=t}}function qf(e){return e.filter(e=>Mp.exactMatch(e)||Lp.exactMatch(e))}function $f(e){return e.filter(e=>Mp.exactMatch(e))}class zf{log;init;logger;metrics;components;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:websockets"),this.logger=e.logger,this.components=e,this.init=t,null!=e.metrics&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total",{label:"event",help:"Total count of WebSockets dialer events by type"})})}[Ii]=!0;[Symbol.toStringTag]="@libp2p/websockets";[eo]=["@libp2p/transport"];async dial(e,t){this.log("dialing %s",e),t=t??{};const r=function(e,t,r){const n=r.logger.forComponent("libp2p:websockets:maconn"),s=r.metrics,i=r.metricPrefix??"",o={log:n,async sink(t){try{await e.sink(async function*(){for await(const e of t)e instanceof Uint8Array?yield e:yield e.subarray()}())}catch(e){"aborted"!==e.type&&n.error(e)}},source:e.source,remoteAddr:t,timeline:{open:Date.now()},async close(t={}){const r=Date.now();if(null==t.signal){const e=AbortSignal.timeout(500);t={...t,signal:e}}const s=()=>{const{host:e,port:t}=o.remoteAddr.toOptions();n("timeout closing stream to %s:%s after %dms, destroying it manually",e,t,Date.now()-r),this.abort(new xi("Socket close timeout"))};t.signal?.addEventListener("abort",s);try{await e.close()}catch(e){n.error("error closing WebSocket gracefully",e),this.abort(e)}finally{t.signal?.removeEventListener("abort",s),o.timeline.close=Date.now()}},abort(t){const{host:r,port:a}=o.remoteAddr.toOptions();n("timeout closing stream to %s:%s due to error",r,a,t),e.destroy(),o.timeline.close=Date.now(),s?.increment({[i+"error"]:!0})}};return e.socket.addEventListener("close",()=>{s?.increment({[i+"close"]:!0}),null==o.timeline.close&&(o.timeline.close=Date.now())},{once:!0}),o}(await this._connect(e,t),e,{logger:this.logger,metrics:this.metrics?.dialerEvents});this.log("new outbound connection %s",r.remoteAddr);const n=await t.upgrader.upgradeOutbound(r,t);return this.log("outbound connection %s upgraded",r.remoteAddr),n}async _connect(e,t){t?.signal?.throwIfAborted();const r=e.toOptions();this.log("dialing %s:%s",r.host,r.port);const n=ps(),s=Ff(function(e){const t=Zl(e).getComponents(),r=t.pop();if(null==r)throw Error("Unexpected end of multiaddr");const n=xf[r.name];if(null==n)throw Error("No interpreter found for "+r.name);let s=n(r,t)??"";return vf.includes(r.code)&&(s=s.replace(/^.*:\/\//,""),s="443"===r.value?"https://"+s:"http://"+s),(s.startsWith("http://")||s.startsWith("https://")||s.startsWith("ws://")||s.startsWith("wss://"))&&(s=new URL(s).toString(),s.endsWith("/")&&(s=s.substring(0,s.length-1))),s}(e),this.init);s.socket.addEventListener("error",()=>{const t=new Di("Could not connect to "+e.toString());this.log.error("connection error:",t),this.metrics?.dialerEvents.increment({error:!0}),n.reject(t)});try{t.onProgress?.(new Bf("websockets:open-connection")),await ws(Promise.race([s.connected(),n.promise]),t.signal)}catch(e){throw t.signal?.aborted&&this.metrics?.dialerEvents.increment({abort:!0}),s.close().catch(e=>{this.log.error("error closing raw socket",e)}),e}return this.log("connected %s",e),this.metrics?.dialerEvents.increment({connect:!0}),s}createListener(e){return function(){throw Error("WebSocket Servers can not be created in the browser!")}((this.logger,this.components.events,this.components.metrics),this.init)}listenFilter(e){return e=Array.isArray(e)?e:[e],null!=this.init?.filter?this.init?.filter(e):qf(e)}dialFilter(e){return this.listenFilter(e)}}function Kf(e={}){return t=>new zf(t,e)}function Vf(e){if("object"!=typeof e||null===e)return!1;const t=Object.getPrototypeOf(e);return!(null!==t&&t!==Object.prototype&&null!==Object.getPrototypeOf(t)||Symbol.toStringTag in e||Symbol.iterator in e)}const{hasOwnProperty:Hf}=Object.prototype,{propertyIsEnumerable:jf}=Object,Gf=(e,t,r)=>{Object.defineProperty(e,t,{value:r,writable:!0,enumerable:!0,configurable:!0})},Wf=globalThis,Xf={concatArrays:!1,ignoreUndefined:!1},Zf=e=>{const t=[];for(const r in e)Hf.call(e,r)&&t.push(r);if(Object.getOwnPropertySymbols){const r=Object.getOwnPropertySymbols(e);for(const n of r)jf.call(e,n)&&t.push(n)}return t};function Qf(e){return Array.isArray(e)?function(e){const t=e.slice(0,0);return Zf(e).forEach(r=>{Gf(t,r,Qf(e[r]))}),t}(e):Vf(e)?function(e){const t=null===Object.getPrototypeOf(e)?Object.create(null):{};return Zf(e).forEach(r=>{Gf(t,r,Qf(e[r]))}),t}(e):e}const Yf=(e,t,r,n)=>(r.forEach(r=>{void 0===t[r]&&n.ignoreUndefined||(r in e&&e[r]!==Object.getPrototypeOf(e)?Gf(e,r,eg(e[r],t[r],n)):Gf(e,r,Qf(t[r])))}),e),Jf=(e,t,r)=>{let n=e.slice(0,0),s=0;return[e,t].forEach(t=>{const i=[];for(let r=0;r<t.length;r++)Hf.call(t,r)&&(i.push(r+""),Gf(n,s++,t===e?t[r]:Qf(t[r])));n=Yf(n,t,Zf(t).filter(e=>!i.includes(e)),r)}),n};function eg(e,t,r){return r.concatArrays&&Array.isArray(e)&&Array.isArray(t)?Jf(e,t,r):Vf(t)&&Vf(e)?Yf(e,t,Zf(t),r):Qf(t)}function tg(...e){const t=eg(Qf(Xf),this!==Wf&&this||{},Xf);let r={_:{}};for(const n of e)if(void 0!==n){if(!Vf(n))throw new TypeError("`"+n+"` is not an Option Object");r=eg(r,{_:n},t)}return r._}var rg,ng={exports:{}};var sg=(rg||(rg=1,function(e){var t={}.hasOwnProperty,r="~";function n(){}function s(e,t,r){this.fn=e,this.context=t,this.once=r||!1}function i(e,t,n,i,o){if("function"!=typeof n)throw new TypeError("The listener must be a function");var a=new s(n,i||e,o),c=r?r+t:t;return e._events[c]?e._events[c].fn?e._events[c]=[e._events[c],a]:e._events[c].push(a):(e._events[c]=a,e._eventsCount++),e}function o(e,t){0===--e._eventsCount?e._events=new n:delete e._events[t]}function a(){this._events=new n,this._eventsCount=0}Object.create&&(n.prototype=Object.create(null),(new n).__proto__||(r=!1)),a.prototype.eventNames=function(){var e,n,s=[];if(0===this._eventsCount)return s;for(n in e=this._events)t.call(e,n)&&s.push(r?n.slice(1):n);return Object.getOwnPropertySymbols?s.concat(Object.getOwnPropertySymbols(e)):s},a.prototype.listeners=function(e){var t=r?r+e:e,n=this._events[t];if(!n)return[];if(n.fn)return[n.fn];for(var s=0,i=n.length,o=Array(i);s<i;s++)o[s]=n[s].fn;return o},a.prototype.listenerCount=function(e){var t=r?r+e:e,n=this._events[t];return n?n.fn?1:n.length:0},a.prototype.emit=function(e,t,n,s,i,o){var a=r?r+e:e;if(!this._events[a])return!1;var c,l,u=this._events[a],h=arguments.length;if(u.fn){switch(u.once&&this.removeListener(e,u.fn,void 0,!0),h){case 1:return u.fn.call(u.context),!0;case 2:return u.fn.call(u.context,t),!0;case 3:return u.fn.call(u.context,t,n),!0;case 4:return u.fn.call(u.context,t,n,s),!0;case 5:return u.fn.call(u.context,t,n,s,i),!0;case 6:return u.fn.call(u.context,t,n,s,i,o),!0}for(l=1,c=Array(h-1);l<h;l++)c[l-1]=arguments[l];u.fn.apply(u.context,c)}else{var d,p=u.length;for(l=0;l<p;l++)switch(u[l].once&&this.removeListener(e,u[l].fn,void 0,!0),h){case 1:u[l].fn.call(u[l].context);break;case 2:u[l].fn.call(u[l].context,t);break;case 3:u[l].fn.call(u[l].context,t,n);break;case 4:u[l].fn.call(u[l].context,t,n,s);break;default:if(!c)for(d=1,c=Array(h-1);d<h;d++)c[d-1]=arguments[d];u[l].fn.apply(u[l].context,c)}}return!0},a.prototype.on=function(e,t,r){return i(this,e,t,r,!1)},a.prototype.once=function(e,t,r){return i(this,e,t,r,!0)},a.prototype.removeListener=function(e,t,n,s){var i=r?r+e:e;if(!this._events[i])return this;if(!t)return o(this,i),this;var a=this._events[i];if(a.fn)a.fn!==t||s&&!a.once||n&&a.context!==n||o(this,i);else{for(var c=0,l=[],u=a.length;c<u;c++)(a[c].fn!==t||s&&!a[c].once||n&&a[c].context!==n)&&l.push(a[c]);l.length?this._events[i]=1===l.length?l[0]:l:o(this,i)}return this},a.prototype.removeAllListeners=function(e){var t;return e?(t=r?r+e:e,this._events[t]&&o(this,t)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=r,a.EventEmitter=a,e.exports=a}(ng)),ng.exports),ig=Cn(sg);class og extends Error{constructor(e){super(e),this.name="TimeoutError"}}let ag=class extends Error{constructor(e){super(),this.name="AbortError",this.message=e}};const cg=e=>void 0===globalThis.DOMException?new ag(e):new DOMException(e),lg=e=>{const t=void 0===e.reason?cg("This operation was aborted."):e.reason;return t instanceof Error?t:cg(t)};let ug=class{#s=[];enqueue(e,t){const r={priority:(t={priority:0,...t}).priority,id:t.id,run:e};if(0===this.size||this.#s[this.size-1].priority>=t.priority)return void this.#s.push(r);const n=function(e,t,r){let n=0,s=e.length;for(;s>0;){const i=Math.trunc(s/2);let o=n+i;r(e[o],t)<=0?(n=++o,s-=i+1):s=i}return n}(this.#s,r,(e,t)=>t.priority-e.priority);this.#s.splice(n,0,r)}setPriority(e,t){const r=this.#s.findIndex(t=>t.id===e);if(-1===r)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[n]=this.#s.splice(r,1);this.enqueue(n.run,{priority:t,id:e})}dequeue(){const e=this.#s.shift();return e?.run}filter(e){return this.#s.filter(t=>t.priority===e.priority).map(e=>e.run)}get size(){return this.#s.length}};class hg extends ig{#i;#o;#a=0;#c;#l;#u=0;#h;#d;#s;#p;#f=0;#g;#m;#y;#b=1n;timeout;constructor(e){if(super(),!("number"==typeof(e={carryoverConcurrencyCount:!1,intervalCap:1/0,interval:0,concurrency:1/0,autoStart:!0,queueClass:ug,...e}).intervalCap&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${e.intervalCap?.toString()??""}\` (${typeof e.intervalCap})`);if(void 0===e.interval||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${e.interval?.toString()??""}\` (${typeof e.interval})`);this.#i=e.carryoverConcurrencyCount,this.#o=e.intervalCap===1/0||0===e.interval,this.#c=e.intervalCap,this.#l=e.interval,this.#s=new e.queueClass,this.#p=e.queueClass,this.concurrency=e.concurrency,this.timeout=e.timeout,this.#y=!0===e.throwOnTimeout,this.#m=!1===e.autoStart}get#w(){return this.#o||this.#a<this.#c}get#v(){return this.#f<this.#g}#E(){this.#f--,this.#S(),this.emit("next")}#A(){this.#I(),this.#C(),this.#d=void 0}get#x(){const e=Date.now();if(void 0===this.#h){const t=this.#u-e;if(!(t<0))return void 0===this.#d&&(this.#d=setTimeout(()=>{this.#A()},t)),!0;this.#a=this.#i?this.#f:0}return!1}#S(){if(0===this.#s.size)return this.#h&&clearInterval(this.#h),this.#h=void 0,this.emit("empty"),0===this.#f&&this.emit("idle"),!1;if(!this.#m){const e=!this.#x;if(this.#w&&this.#v){const t=this.#s.dequeue();return!!t&&(this.emit("active"),t(),e&&this.#C(),!0)}}return!1}#C(){this.#o||void 0!==this.#h||(this.#h=setInterval(()=>{this.#I()},this.#l),this.#u=Date.now()+this.#l)}#I(){0===this.#a&&0===this.#f&&this.#h&&(clearInterval(this.#h),this.#h=void 0),this.#a=this.#i?this.#f:0,this.#k()}#k(){for(;this.#S(););}get concurrency(){return this.#g}set concurrency(e){if(!("number"==typeof e&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);this.#g=e,this.#k()}async#T(e){return new Promise((t,r)=>{e.addEventListener("abort",()=>{r(e.reason)},{once:!0})})}setPriority(e,t){this.#s.setPriority(e,t)}async add(e,t={}){return t.id??=""+this.#b++,t={timeout:this.timeout,throwOnTimeout:this.#y,...t},new Promise((r,n)=>{this.#s.enqueue(async()=>{this.#f++,this.#a++;try{t.signal?.throwIfAborted();let n=e({signal:t.signal});t.timeout&&(n=function(e,t){const{milliseconds:r,fallback:n,message:s,customTimers:i={setTimeout,clearTimeout}}=t;let o,a;const c=new Promise((c,l)=>{if("number"!=typeof r||1!==Math.sign(r))throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${r}\``);if(t.signal){const{signal:e}=t;e.aborted&&l(lg(e)),a=()=>{l(lg(e))},e.addEventListener("abort",a,{once:!0})}if(r===1/0)return void e.then(c,l);const u=new og;o=i.setTimeout.call(void 0,()=>{if(n)try{c(n())}catch(e){l(e)}else"function"==typeof e.cancel&&e.cancel(),!1===s?c():s instanceof Error?l(s):(u.message=s??`Promise timed out after ${r} milliseconds`,l(u))},r),(async()=>{try{c(await e)}catch(e){l(e)}})()}).finally(()=>{c.clear(),a&&t.signal&&t.signal.removeEventListener("abort",a)});return c.clear=()=>{i.clearTimeout.call(void 0,o),o=void 0},c}(Promise.resolve(n),{milliseconds:t.timeout})),t.signal&&(n=Promise.race([n,this.#T(t.signal)]));const s=await n;r(s),this.emit("completed",s)}catch(e){if(e instanceof og&&!t.throwOnTimeout)return void r();n(e),this.emit("error",e)}finally{this.#E()}},t),this.emit("add"),this.#S()})}async addAll(e,t){return Promise.all(e.map(async e=>this.add(e,t)))}start(){return this.#m?(this.#m=!1,this.#k(),this):this}pause(){this.#m=!0}clear(){this.#s=new this.#p}async onEmpty(){0!==this.#s.size&&await this.#P("empty")}async onSizeLessThan(e){this.#s.size<e||await this.#P("next",()=>this.#s.size<e)}async onIdle(){0===this.#f&&0===this.#s.size||await this.#P("idle")}async#P(e,t){return new Promise(r=>{const n=()=>{t&&!t()||(this.off(e,n),r())};this.on(e,n)})}get size(){return this.#s.size}sizeBy(e){return this.#s.filter(e).length}get pending(){return this.#f}get isPaused(){return this.#m}}function dg(e){const t=[Eg.A];return null==e?t:Array.isArray(e)?0===e.length?t:e:[e]}function pg(e){return{Status:e.Status??0,TC:e.TC??e.flag_tc??!1,RD:e.RD??e.flag_rd??!1,RA:e.RA??e.flag_ra??!1,AD:e.AD??e.flag_ad??!1,CD:e.CD??e.flag_cd??!1,Question:(e.Question??e.questions??[]).map(e=>({name:e.name,type:Eg[e.type]})),Answer:(e.Answer??e.answers??[]).map(e=>({name:e.name,type:Eg[e.type],TTL:e.TTL??e.ttl??60,data:e.data instanceof Uint8Array?ln(e.data):e.data}))}}function fg(e,t={}){const r=new hg({concurrency:t.queryConcurrency??4});return async(t,n={})=>{const s=new URLSearchParams;s.set("name",t),dg(n.types).forEach(e=>{s.append("type",Eg[e])}),n.onProgress?.(new Bf("dns:query",{detail:t}));const i=await r.add(async()=>{const t=await fetch(`${e}?${s}`,{headers:{accept:"application/dns-json"},signal:n?.signal});if(200!==t.status)throw Error(`Unexpected HTTP status: ${t.status} - ${t.statusText}`);const r=pg(await t.json());return n.onProgress?.(new Bf("dns:response",{detail:r})),r},{signal:n.signal});if(null==i)throw Error("No DNS response received");return i}}var gg,mg;var yg=(mg||(mg=1,gg=e=>{if(!e)throw Error("hashlru must have a max value, of type number, greater than 0");var t=0,r=Object.create(null),n=Object.create(null);function s(s,i){r[s]=i,++t>=e&&(t=0,n=r,r=Object.create(null))}return{has:e=>void 0!==r[e]||void 0!==n[e],remove(e){void 0!==r[e]&&(r[e]=void 0),void 0!==n[e]&&(n[e]=void 0)},get(e){var t=r[e];return void 0!==t?t:void 0!==(t=n[e])?(s(e,t),t):void 0},set(e,t){void 0!==r[e]?r[e]=t:s(e,t)},clear(){r=Object.create(null),n=Object.create(null)}}}),gg),bg=Cn(yg);class wg{lru;constructor(e){this.lru=bg(e)}get(e,t){let r=!0;const n=[];for(const s of t){const t=this.getAnswers(e,s);if(0===t.length){r=!1;break}n.push(...t)}if(r)return pg({answers:n})}getAnswers(e,t){const r=`${e.toLowerCase()}-${t}`,n=this.lru.get(r);if(null!=n){const e=n.filter(e=>e.expires>Date.now()).map(({expires:e,value:t})=>({...t,TTL:Math.round((e-Date.now())/1e3),type:Eg[t.type]}));return 0===e.length&&this.lru.remove(r),e}return[]}add(e,t){const r=`${e.toLowerCase()}-${t.type}`,n=this.lru.get(r)??[];n.push({expires:Date.now()+1e3*(t.TTL??60),value:t}),this.lru.set(r,n)}remove(e,t){const r=`${e.toLowerCase()}-${t}`;this.lru.remove(r)}clear(){this.lru.clear()}}class vg{resolvers;cache;constructor(e){var t;this.resolvers={},this.cache=(t=e.cacheSize??1e3,new wg(t)),Object.entries(e.resolvers??{}).forEach(([e,t])=>{Array.isArray(t)||(t=[t]),e.endsWith(".")||(e+="."),this.resolvers[e]=t}),null==this.resolvers["."]&&(this.resolvers["."]=[fg("https://cloudflare-dns.com/dns-query"),fg("https://dns.google/resolve")])}async query(e,t={}){const r=dg(t.types),n=!1!==t.cached?this.cache.get(e,r):void 0;if(null!=n)return t.onProgress?.(new Bf("dns:cache",{detail:n})),n;const s=e.split(".").pop()+".",i=(this.resolvers[s]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),o=[];for(const n of i){if(!0===t.signal?.aborted)break;try{const s=await n(e,{...t,types:r});for(const t of s.Answer)this.cache.add(e,t);return s}catch(e){o.push(e),t.onProgress?.(new Bf("dns:error",{detail:e}))}}if(1===o.length)throw o[0];throw new AggregateError(o,`DNS lookup of ${e} ${r} failed`)}}var Eg;(e=>{e[e.A=1]="A",e[e.CNAME=5]="CNAME",e[e.TXT=16]="TXT",e[e.AAAA=28]="AAAA"})(Eg||(Eg={}));const Sg=-1,Ag={},Ig={};[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,Sg,"ip6zone"],[43,8,"ipcidr"],[53,Sg,"dns",!0],[54,Sg,"dns4",!0],[55,Sg,"dns6",!0],[56,Sg,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,Sg,"unix",!1,!0],[421,Sg,"ipfs"],[421,Sg,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,Sg,"garlic64"],[448,0,"tls"],[449,Sg,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,Sg,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[481,Sg,"http-path"],[777,Sg,"memory"]].forEach(e=>{const t=function(e,t,r,n,s){return{code:e,size:t,name:r,resolvable:!!n,path:!!s}}(...e);Ig[t.code]=t,Ag[t.name]=t});const{code:Cg}=function(e){if(null!=Ag[e])return Ag[e];throw Error("no protocol with name: "+e)}("dnsaddr");class xg extends Error{constructor(e="Max recursive depth reached"){super(e),this.name="RecursionLimitError"}}const kg=async function(e,t={}){const r=t.maxRecursiveDepth??32;if(0===r)throw new xg("Max recursive depth reached");const[,n]=e.stringTuples().find(([e])=>e===Cg)??[],s=t?.dns??function(e={}){return new vg(e)}(),i=await s.query("_dnsaddr."+n,{signal:t?.signal,types:[Eg.TXT]}),o=e.getPeerId(),a=[];for(const e of i.Answer){const n=e.data.replace(/["']/g,"").trim().split("=")[1];if(null==n)continue;if(null!=o&&!n.includes(o))continue;const s=Zl(n);if(n.startsWith("/dnsaddr")){const e=await s.resolve({...t,maxRecursiveDepth:r-1});a.push(...e.map(e=>e.toString()))}else a.push(s.toString())}return a},Tg={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter(e){return e}},connectionManager:{resolvers:{dnsaddr:kg}},transportManager:{faultTolerance:Ci.FATAL_ALL}};async function Pg(e){const t=tg(Tg,e);if(null===t.connectionProtector&&null!=globalThis.process?.env?.LIBP2P_FORCE_PNET)throw new Pi("Private network is enforced, but no protector was provided");return t}const _g=1e3,Rg=60*_g,Lg=60*Rg,Dg=24*Lg,Mg=7*Dg,Ng=365.25*Dg,Og=Ng/12;var Ug=function(e,t){if("string"==typeof e)return Fg(e);if("number"==typeof e)return function(e,t){if("number"!=typeof e||!Number.isFinite(e))throw Error("Value provided to ms.format() must be of type number.");return t?.long?qg(e):Bg(e)}(e,t);throw Error("Value provided to ms() must be a string or number. value="+JSON.stringify(e))};function Fg(e){if("string"!=typeof e||0===e.length||e.length>100)throw Error("Value provided to ms.parse() must be a string with length between 1 and 99. value="+JSON.stringify(e));let t=/^(?<value>-?\d*\.?\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(e);if(!t?.groups)return NaN;let{value:r,unit:n="ms"}=t.groups,s=parseFloat(r),i=n.toLowerCase();switch(i){case"years":case"year":case"yrs":case"yr":case"y":return s*Ng;case"months":case"month":case"mo":return s*Og;case"weeks":case"week":case"w":return s*Mg;case"days":case"day":case"d":return s*Dg;case"hours":case"hour":case"hrs":case"hr":case"h":return s*Lg;case"minutes":case"minute":case"mins":case"min":case"m":return s*Rg;case"seconds":case"second":case"secs":case"sec":case"s":return s*_g;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return s;default:throw Error(`Unknown unit "${i}" provided to ms.parse(). value=${JSON.stringify(e)}`)}}function Bg(e){let t=Math.abs(e);return t>=Ng?Math.round(e/Ng)+"y":t>=Og?Math.round(e/Og)+"mo":t>=Mg?Math.round(e/Mg)+"w":t>=Dg?Math.round(e/Dg)+"d":t>=Lg?Math.round(e/Lg)+"h":t>=Rg?Math.round(e/Rg)+"m":t>=_g?Math.round(e/_g)+"s":e+"ms"}function qg(e){let t=Math.abs(e);return t>=Ng?$g(e,t,Ng,"year"):t>=Og?$g(e,t,Og,"month"):t>=Mg?$g(e,t,Mg,"week"):t>=Dg?$g(e,t,Dg,"day"):t>=Lg?$g(e,t,Lg,"hour"):t>=Rg?$g(e,t,Rg,"minute"):t>=_g?$g(e,t,_g,"second"):e+" ms"}function $g(e,t,r,n){let s=t>=1.5*r;return`${Math.round(e/r)} ${n}${s?"s":""}`}const zg=function(){try{return localStorage}catch(e){}}();const Kg=console.debug??console.log??(()=>{});var Vg=function(e){function t(e){let n,s,i,o=null;function a(...e){if(!a.enabled)return;const r=a,s=Number(new Date),i=s-(n||s);r.diff=i,r.prev=n,r.curr=s,n=s,e[0]=t.coerce(e[0]),"string"!=typeof e[0]&&e.unshift("%O");let o=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,(n,s)=>{if("%%"===n)return"%";o++;const i=t.formatters[s];if("function"==typeof i){const t=e[o];n=i.call(r,t),e.splice(o,1),o--}return n}),t.formatArgs.call(r,e);(r.log||t.log).apply(r,e)}return a.namespace=e,a.useColors=t.useColors(),a.color=t.selectColor(e),a.extend=r,a.destroy=t.destroy,Object.defineProperty(a,"enabled",{enumerable:!0,configurable:!1,get(){return null!==o?o:(s!==t.namespaces&&(s=t.namespaces,i=t.enabled(e)),i)},set(e){o=e}}),"function"==typeof t.init&&t.init(a),a}function r(e,r){const n=t(this.namespace+(void 0===r?":":r)+e);return n.log=this.log,n}function n(e){return e.toString().substring(2,e.toString().length-2).replace(/\.\*\?$/,"*")}return t.debug=t,t.default=t,t.coerce=function(e){if(e instanceof Error)return e.stack??e.message;return e},t.disable=function(){const e=[...t.names.map(n),...t.skips.map(n).map(e=>"-"+e)].join(",");return t.enable(""),e},t.enable=function(e){let r;t.save(e),t.namespaces=e,t.names=[],t.skips=[];const n=("string"==typeof e?e:"").split(/[\s,]+/),s=n.length;for(r=0;r<s;r++)n[r]&&("-"===(e=n[r].replace(/\*/g,".*?"))[0]?t.skips.push(RegExp("^"+e.substr(1)+"$")):t.names.push(RegExp("^"+e+"$")))},t.enabled=function(e){if("*"===e[e.length-1])return!0;let r,n;for(r=0,n=t.skips.length;r<n;r++)if(t.skips[r].test(e))return!1;for(r=0,n=t.names.length;r<n;r++)if(t.names[r].test(e))return!0;return!1},t.humanize=Ug,t.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(e).forEach(r=>{t[r]=e[r]}),t.names=[],t.skips=[],t.formatters={},t.selectColor=function(e){let r=0;for(let t=0;t<e.length;t++)r=(r<<5)-r+e.charCodeAt(t),r|=0;return t.colors[Math.abs(r)%t.colors.length]},t.setupFormatters(t.formatters),t.enable(t.load()),t}({formatArgs(e){if(e[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+e[0]+(this.useColors?"%c ":" ")+"+"+Ug(this.diff),!this.useColors)return;const t="color: "+this.color;e.splice(1,0,t,"color: inherit");let r=0,n=0;e[0].replace(/%[a-zA-Z%]/g,e=>{"%%"!==e&&(r++,"%c"===e&&(n=r))}),e.splice(n,0,t)},save(e){try{e?zg?.setItem("debug",e):zg?.removeItem("debug")}catch(e){}},load(){let e;try{e=zg?.getItem("debug")}catch(e){}return!e&&void 0!==globalThis.process&&"env"in globalThis.process&&(e=globalThis.process.env.DEBUG),e},useColors(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type&&!window.process.__nwjs)||("undefined"==typeof navigator||null==navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/))&&("undefined"!=typeof document&&document.documentElement?.style?.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&null!=navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/))},setupFormatters(e){e.j=e=>{try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}},colors:["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],storage:zg,log:Kg});function Hg(){return{forComponent:e=>jg(e)}}function jg(e){let t=function(e){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=e,t.destroy=()=>!0,t.extend=()=>t,t}(e+":trace");return Vg.enabled(e+":trace")&&null!=Vg.names.map(e=>e.toString()).find(e=>e.includes(":trace"))&&(t=Vg(e+":trace")),Object.assign(Vg(e),{error:Vg(e+":error"),trace:t,newScope(t){return jg(`${e}:${t}`)}})}function Gg(e){if(null!=e&&0!==(e=e.trim()).length)return e}function Wg(e,t){const r={[Symbol.iterator](){return r},next(){const r=e.next(),n=r.value;if(!0===r.done||null==n){return{done:!0,value:void 0}}return{done:!1,value:t(n)}}};return r}function Xg(e){return il(Oe(he.decode("z"+e)))}Vg.formatters.b=e=>null==e?"undefined":he.baseEncode(e),Vg.formatters.t=e=>null==e?"undefined":Y.baseEncode(e),Vg.formatters.m=e=>null==e?"undefined":fe.baseEncode(e),Vg.formatters.p=e=>null==e?"undefined":e.toString(),Vg.formatters.c=e=>null==e?"undefined":e.toString(),Vg.formatters.k=e=>null==e?"undefined":e.toString(),Vg.formatters.a=e=>null==e?"undefined":e.toString(),Vg.formatters.e=e=>null==e?"undefined":Gg(e.stack)??Gg(e.message)??e.toString();class Zg{map;constructor(e){if(this.map=new Map,null!=e)for(const[t,r]of e.entries())this.map.set(t.toString(),{key:t,value:r})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return Wg(this.map.entries(),e=>[e[1].key,e[1].value])}forEach(e){this.map.forEach(t=>{e(t.value,t.key,this)})}get(e){return this.map.get(e.toString())?.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return Wg(this.map.values(),e=>e.key)}values(){return Wg(this.map.values(),e=>e.value)}get size(){return this.map.size}}class Qg{set;constructor(e){if(this.set=new Set,null!=e)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return Wg(this.set.entries(),e=>{const t=Xg(e[0]);return[t,t]})}forEach(e){this.set.forEach(t=>{const r=Xg(t);e(r,r,this)})}has(e){return this.set.has(e.toString())}values(){return Wg(this.set.values(),e=>Xg(e))}intersection(e){const t=new Qg;for(const r of e)this.has(r)&&t.add(r);return t}difference(e){const t=new Qg;for(const r of this)e.has(r)||t.add(r);return t}union(e){const t=new Qg;for(const r of e)t.add(r);for(const e of this)t.add(e);return t}}const Yg={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},Jg={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},em=new globalThis.TextEncoder;function tm(e,{size:t=32,utf8Buffer:r}={}){if(!Yg[t])throw Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if("string"==typeof e){if(r)return function(e,t,r){if(0===r.length)throw Error("The `utf8Buffer` option must have a length greater than zero");const n=Yg[t];let s=Jg[t],i=e;for(;i.length>0;){const e=em.encodeInto(i,r);i=i.slice(e.read);for(let i=0;i<e.written;i++)s^=BigInt(r[i]),s=BigInt.asUintN(t,s*n)}return s}(e,t,r);e=em.encode(e)}return function(e,t){const r=Yg[t];let n=Jg[t];for(let s=0;s<e.length;s++)n^=BigInt(e[s]),n=BigInt.asUintN(t,n*r);return n}(e,t)}const rm={hash(e){return Number(tm(e,{size:32}))},hashV(e,t){return function(e){let t=e.toString(16);t.length%2==1&&(t="0"+t);return rt(t,"base16")}(rm.hash(e,t))}};class nm{fp;h;seed;constructor(t,r,n,s=2){if(s>64)throw new TypeError("Invalid Fingerprint Size");const i=r.hashV(t,n),o=e(s);for(let e=0;e<o.length;e++)o[e]=i[e];0===o.length&&(o[0]=7),this.fp=o,this.h=r,this.seed=n}hash(){return this.h.hash(this.fp,this.seed)}equals(e){return e?.fp instanceof Uint8Array&&Yn(this.fp,e.fp)}}function sm(e,t){return Math.floor(Math.random()*(t-e))+e}class im{contents;constructor(e){this.contents=Array(e).fill(null)}has(e){if(!(e instanceof nm))throw new TypeError("Invalid Fingerprint");return this.contents.some(t=>e.equals(t))}add(e){if(!(e instanceof nm))throw new TypeError("Invalid Fingerprint");for(let t=0;t<this.contents.length;t++)if(null==this.contents[t])return this.contents[t]=e,!0;return!0}swap(e){if(!(e instanceof nm))throw new TypeError("Invalid Fingerprint");const t=sm(0,this.contents.length-1),r=this.contents[t];return this.contents[t]=e,r}remove(e){if(!(e instanceof nm))throw new TypeError("Invalid Fingerprint");const t=this.contents.findIndex(t=>e.equals(t));return t>-1&&(this.contents[t]=null,!0)}}class om{bucketSize;filterSize;fingerprintSize;buckets;count;hash;seed;constructor(e){this.filterSize=e.filterSize,this.bucketSize=e.bucketSize??4,this.fingerprintSize=e.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=e.hash??rm,this.seed=e.seed??sm(0,1024)}add(e){"string"==typeof e&&(e=rt(e));const t=new nm(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,n=(r^t.hash())%this.filterSize;if(null==this.buckets[r]&&(this.buckets[r]=new im(this.bucketSize)),null==this.buckets[n]&&(this.buckets[n]=new im(this.bucketSize)),this.buckets[r].add(t)||this.buckets[n].add(t))return this.count++,!0;const s=[r,n];let i=s[sm(0,s.length-1)];null==this.buckets[i]&&(this.buckets[i]=new im(this.bucketSize));for(let e=0;e<500;e++){const e=this.buckets[i].swap(t);if(null!=e&&(i=(i^e.hash())%this.filterSize,null==this.buckets[i]&&(this.buckets[i]=new im(this.bucketSize)),this.buckets[i].add(e)))return this.count++,!0}return!1}has(e){"string"==typeof e&&(e=rt(e));const t=new nm(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,n=this.buckets[r]?.has(t)??!1;if(n)return n;const s=(r^t.hash())%this.filterSize;return this.buckets[s]?.has(t)??!1}remove(e){"string"==typeof e&&(e=rt(e));const t=new nm(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,n=this.buckets[r]?.remove(t)??!1;if(n)return this.count--,n;const s=(r^t.hash())%this.filterSize,i=this.buckets[s]?.remove(t)??!1;return i&&this.count--,i}get reliable(){return Math.floor(this.count/this.filterSize*100)<=90}}const am={1:.5,2:.84,4:.95,8:.98};function cm(e,t=.001){const r=function(e=.001){return e>.002?2:e>1e-5?4:8}(t);return{filterSize:Math.round(e/am[r]),bucketSize:r,fingerprintSize:Math.min(Math.ceil(Math.log2(1/t)+Math.log2(2*r)),64)}}class lm{filterSize;bucketSize;fingerprintSize;scale;filterSeries;hash;seed;constructor(e){this.bucketSize=e.bucketSize??4,this.filterSize=e.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=e.fingerprintSize??2,this.scale=e.scale??2,this.hash=e.hash??rm,this.seed=e.seed??sm(0,1024),this.filterSeries=[new om({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(e){if("string"==typeof e&&(e=rt(e)),this.has(e))return!0;let t=this.filterSeries.find(e=>e.reliable);if(null==t){const e=this.filterSize*Math.pow(this.scale,this.filterSeries.length);t=new om({filterSize:e,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(t)}return t.add(e)}has(e){"string"==typeof e&&(e=rt(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].has(e))return!0;return!1}remove(e){"string"==typeof e&&(e=rt(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].remove(e))return!0;return!1}get count(){return this.filterSeries.reduce((e,t)=>e+t.count,0)}}function um(e,t=.001){return new lm({...cm(e,t)})}class hm extends Zg{metric;constructor(e){super();const{name:t,metrics:r}=e;this.metric=r.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}let dm=class extends Error{static name="AbortError";name="AbortError";constructor(e="The operation was aborted",...t){super(e,...t)}};async function pm(e,t,r,n){const s=new dm(n?.errorMessage);null!=n?.errorCode&&(s.code=n.errorCode);const i=n?.errorEvent??"error";return!0===r?.aborted?Promise.reject(s):new Promise((o,a)=>{function c(){gm(r,"abort",h),gm(e,t,l),gm(e,i,u)}const l=e=>{try{if(!1===n?.filter?.(e))return}catch(e){return c(),void a(e)}c(),o(e)},u=e=>{c(),a(e instanceof Error?e:e.detail??n?.error??Error(`The "${n?.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`))},h=()=>{c(),a(s)};fm(r,"abort",h),fm(e,t,l),fm(e,i,u)})}function fm(e,t,r){null!=e&&(mm(e)?e.addEventListener(t,r):e.addListener(t,r))}function gm(e,t,r){null!=e&&(mm(e)?e.removeEventListener(t,r):e.removeListener(t,r))}function mm(e){return"function"==typeof e.addEventListener&&"function"==typeof e.removeEventListener}class ym extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}}let bm=class{deferred;signal;constructor(e){this.signal=e,this.deferred=Promise.withResolvers(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new dm)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}};let wm=class{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=`${parseInt(1e9*Math.random()+"",10).toString()}${Date.now()}`,this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((e,t)=>e&&!0===t.signal?.aborted,!0)&&(this.controller.abort(new dm),this.cleanup())}async join(e={}){const t=new bm(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await ws(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)})}};function vm(e,t){let r;const n=()=>{clearTimeout(r),r=setTimeout(()=>{r=void 0,e()},t)};return n.start=()=>{},n.stop=()=>{clearTimeout(r)},n}let Em=class extends Yi{concurrency;maxSize;queue;pending;sort;autoStart;constructor(e={}){super(),this.concurrency=e.concurrency??1/0,this.maxSize=e.maxSize??1/0,this.pending=0,this.autoStart=e.autoStart??!0,this.sort=e.sort,this.queue=[],this.emitEmpty=vm(this.emitEmpty.bind(this),1),this.emitIdle=vm(this.emitIdle.bind(this),1)}[Symbol.asyncIterator](){return this.toGenerator()}emitEmpty(){0===this.size&&this.safeDispatchEvent("empty")}emitIdle(){0===this.running&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(0===this.size)return this.emitEmpty(),0===this.running&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const t of this.queue)if("queued"===t.status){e=t;break}return null!=e&&(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.safeDispatchEvent("next"),this.autoStart&&this.tryToStartAnother()}),!0)}return!1}enqueue(e){this.queue.push(e),null!=this.sort&&this.queue.sort(this.sort)}start(){!1===this.autoStart&&(this.autoStart=!0,this.tryToStartAnother())}pause(){this.autoStart=!1}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new ym;const r=new wm(e,t);return this.enqueue(r),this.safeDispatchEvent("add"),this.autoStart&&this.tryToStartAnother(),r.join(t).then(e=>(this.safeDispatchEvent("success",{detail:{job:r,result:e}}),e)).catch(e=>{if("queued"===r.status)for(let e=0;e<this.queue.length;e++)if(this.queue[e]===r){this.queue.splice(e,1);break}throw this.safeDispatchEvent("failure",{detail:{job:r,error:e}}),e})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new dm)}),this.clear()}async onEmpty(e){0!==this.size&&await pm(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await pm(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){0===this.pending&&0===this.size||await pm(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();const t=ys({objectMode:!0}),r=e=>{null!=e?this.abort():this.clear(),t.end(e)},n=e=>{null!=e.detail&&t.push(e.detail.result)},s=e=>{r(e.detail.error)},i=()=>{r()},o=()=>{r(new dm("Queue aborted"))};this.addEventListener("success",n),this.addEventListener("failure",s),this.addEventListener("idle",i),e?.signal?.addEventListener("abort",o);try{yield*t}finally{this.removeEventListener("success",n),this.removeEventListener("failure",s),this.removeEventListener("idle",i),e?.signal?.removeEventListener("abort",o),r()}}};const Sm="lock:worker:request-read",Am="lock:worker:abort-read-request",Im="lock:worker:release-read",Cm="lock:master:grant-read",xm="lock:master:error-read",km="lock:worker:request-write",Tm="lock:worker:abort-write-request",Pm="lock:worker:release-write",_m="lock:master:grant-write",Rm="lock:master:error-write",Lm="lock:worker:finalize",Dm="mortice",Mm={singleProcess:!1},Nm=(e,t,r,n,s,i,o,a,c)=>l=>{if(null==l.data)return;const u={type:l.data.type,name:l.data.name,identifier:l.data.identifier};u.type===s&&e.safeDispatchEvent(r,{detail:{name:u.name,identifier:u.identifier,async handler(){t.postMessage({type:c,name:u.name,identifier:u.identifier}),await new Promise(e=>{const r=n=>{if(null==n?.data)return;const s=n.data.type,i=(n.data.name,n.data.identifier);s===a&&i===u.identifier&&(t.removeEventListener("message",r),e())};t.addEventListener("message",r)})},onError(e){t.postMessage({type:o,name:u.name,identifier:u.identifier,error:{message:e.message,name:e.name,stack:e.stack}})}}}),u.type===i&&e.safeDispatchEvent(n,{detail:{name:u.name,identifier:u.identifier}}),u.type===Lm&&e.safeDispatchEvent("finalizeRequest",{detail:{name:u.name}})};class Om{name;channel;constructor(e){this.name=e,this.channel=new BroadcastChannel(Dm)}readLock(e){return this.sendRequest(Sm,Am,Cm,xm,Im,e)}writeLock(e){return this.sendRequest(km,Tm,_m,Rm,Pm,e)}finalize(){this.channel.postMessage({type:Lm,name:this.name}),this.channel.close()}async sendRequest(e,t,r,n,s,i){i?.signal?.throwIfAborted();const o=((e=10)=>Math.random().toString().substring(2,e+2))();return this.channel.postMessage({type:e,identifier:o,name:this.name}),new Promise((e,a)=>{const c=()=>{this.channel.postMessage({type:t,identifier:o,name:this.name})};i?.signal?.addEventListener("abort",c,{once:!0});const l=t=>{if(t.data?.identifier===o&&(t.data?.type===r&&(this.channel.removeEventListener("message",l),i?.signal?.removeEventListener("abort",c),e(()=>{this.channel.postMessage({type:s,identifier:o,name:this.name})})),t.data.type===n)){this.channel.removeEventListener("message",l),i?.signal?.removeEventListener("abort",c);const e=Error();null!=t.data.error&&(e.message=t.data.error.message,e.name=t.data.error.name,e.stack=t.data.error.stack),a(e)}};this.channel.addEventListener("message",l)})}}const Um=new Map;let Fm;function Bm(e){return"function"==typeof e?.readLock&&"function"==typeof e?.writeLock}function qm(e){if(null==Fm&&(Fm=(e=>{if(e=Object.assign({},Mm,e),!!globalThis.document||e.singleProcess){const e=new BroadcastChannel(Dm),t=new Yi;return e.addEventListener("message",Nm(t,e,"requestReadLock","abortReadLockRequest",Sm,Am,xm,Im,Cm)),e.addEventListener("message",Nm(t,e,"requestWriteLock","abortWriteLockRequest",km,Tm,Rm,Pm,_m)),t}return new Om(e.name)})(e),!Bm(Fm))){const e=Fm;e.addEventListener("requestReadLock",t=>{const r=t.detail.name,n=t.detail.identifier,s=Um.get(r);if(null==s)return;const i=new AbortController,o=e=>{e.detail.name===r&&e.detail.identifier===n&&i.abort()};e.addEventListener("abortReadLockRequest",o),s.readLock({signal:i.signal}).then(async e=>{await t.detail.handler().finally(()=>{e()})}).catch(e=>{t.detail.onError(e)}).finally(()=>{e.removeEventListener("abortReadLockRequest",o)})}),e.addEventListener("requestWriteLock",t=>{const r=t.detail.name,n=t.detail.identifier,s=Um.get(r);if(null==s)return;const i=new AbortController,o=e=>{e.detail.name===r&&e.detail.identifier===n&&i.abort()};e.addEventListener("abortWriteLockRequest",o),s.writeLock({signal:i.signal}).then(async e=>{await t.detail.handler().finally(()=>{e()})}).catch(e=>{t.detail.onError(e)}).finally(()=>{e.removeEventListener("abortWriteLockRequest",o)})}),e.addEventListener("finalizeRequest",e=>{const t=e.detail.name,r=Um.get(t);null!=r&&r.finalize()})}return Fm}async function $m(e,t){let r,n;const s=new Promise((e,t)=>{r=e,n=t}),i=()=>{n(new dm)};return t?.signal?.addEventListener("abort",i,{once:!0}),e.add(async()=>{await new Promise(e=>{r(()=>{t?.signal?.removeEventListener("abort",i),e()})})},{signal:t?.signal}).catch(e=>{n(e)}),s}const zm={name:"lock",concurrency:1/0,singleProcess:!1,autoFinalize:!1};function Km(e){const t=Object.assign({},zm,e);return((e,t)=>{let r=Um.get(e);if(null!=r)return r;const n=qm(t);if(Bm(n))return r=n,Um.set(e,r),r;const s=new Em({concurrency:1});let i;return r={async readLock(e){if(null!=i)return $m(i,e);i=new Em({concurrency:t.concurrency,autoStart:!1});const r=i,n=$m(i,e);return s.add(async()=>{r.start(),await r.onIdle().then(()=>{i===r&&(i=null)})}),n},async writeLock(e){return i=null,$m(s,e)},finalize(){Um.delete(e)},queue:s},Um.set(e,r),!0===t.autoFinalize&&s.addEventListener("idle",()=>{r.finalize()},{once:!0}),r})(t.name,t)}var Vm,Hm,jm;function Gm(e,t){if(null!=e.publicKey||null==t.publicKey)return e;let r;"RSA"===e.type&&(r=e.toMultihash());return sl(Xc(t.publicKey,r))}function Wm(e,t,r){const n=new Map,s=BigInt(Date.now());for(const[e,r]of t.tags.entries())null!=r.expiry&&r.expiry<s||n.set(e,r);return{...t,id:Gm(e,t),addresses:t.addresses.filter(({observed:e})=>null!=e&&e>Date.now()-r).map(({multiaddr:e,isCertified:t})=>({multiaddr:Zl(e),isCertified:t??!1})),metadata:t.metadata,peerRecordEnvelope:t.peerRecordEnvelope??void 0,tags:n}}function Xm(e,t){return u=e.addresses,h=t.addresses,Qm(u,h,(e,t)=>e.isCertified===t.isCertified&&!!Yn(e.multiaddr,t.multiaddr))&&(c=e.protocols,l=t.protocols,Qm(c,l,(e,t)=>e===t))&&(o=e.publicKey,a=t.publicKey,Zm(o,a))&&(s=e.peerRecordEnvelope,i=t.peerRecordEnvelope,Zm(s,i))&&(r=e.metadata,n=t.metadata,Ym(r,n,(e,t)=>Yn(e,t)))&&function(e,t){return Ym(e,t,(e,t)=>e.value===t.value&&e.expiry===t.expiry)}(e.tags,t.tags);var r,n,s,i,o,a,c,l,u,h}function Zm(e,t){return null==e&&null==t||null!=e&&null!=t&&Yn(e,t)}function Qm(e,t,r){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(!r(e[n],t[n]))return!1;return!0}function Ym(e,t,r){if(e.size!==t.size)return!1;for(const[n,s]of e.entries()){const e=t.get(n);if(null==e)return!1;if(!r(s,e))return!1}return!0}(t=>{let r;(t=>{let r;t.codec=()=>(null==r&&(r=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.key&&""!==e.key&&(t.uint32(10),t.string(e.key)),null!=e.value&&e.value.byteLength>0&&(t.uint32(18),t.bytes(e.value)),!1!==r.lengthDelimited&&t.ldelim()},(t,r)=>{const n={key:"",value:e(0)},s=null==r?t.len:t.pos+r;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:n.key=t.string();break;case 2:n.value=t.bytes();break;default:t.skipType(7&e)}}return n})),r),t.encode=e=>mt(e,t.codec()),t.decode=(e,r)=>T(e,t.codec(),r)})(t.Peer$metadataEntry||(t.Peer$metadataEntry={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.key&&""!==e.key&&(t.uint32(10),t.string(e.key)),null!=e.value&&(t.uint32(18),jm.codec().encode(e.value,t)),!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{const n={key:""},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.key=e.string();break;case 2:n.value=jm.codec().decode(e,e.uint32(),{limits:r.limits?.value});break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(t.Peer$tagsEntry||(t.Peer$tagsEntry={})),t.codec=()=>(null==r&&(r=Jt((e,r,n={})=>{if(!1!==n.lengthDelimited&&r.fork(),null!=e.addresses)for(const t of e.addresses)r.uint32(10),Hm.codec().encode(t,r);if(null!=e.protocols)for(const t of e.protocols)r.uint32(18),r.string(t);if(null!=e.publicKey&&(r.uint32(34),r.bytes(e.publicKey)),null!=e.peerRecordEnvelope&&(r.uint32(42),r.bytes(e.peerRecordEnvelope)),null!=e.metadata&&0!==e.metadata.size)for(const[n,s]of e.metadata.entries())r.uint32(50),t.Peer$metadataEntry.codec().encode({key:n,value:s},r);if(null!=e.tags&&0!==e.tags.size)for(const[n,s]of e.tags.entries())r.uint32(58),t.Peer$tagsEntry.codec().encode({key:n,value:s},r);null!=e.updated&&(r.uint32(64),r.uint64Number(e.updated)),!1!==n.lengthDelimited&&r.ldelim()},(e,r,n={})=>{const s={addresses:[],protocols:[],metadata:new Map,tags:new Map},i=null==r?e.len:e.pos+r;for(;e.pos<i;){const r=e.uint32();switch(r>>>3){case 1:if(null!=n.limits?.addresses&&s.addresses.length===n.limits.addresses)throw new er('Decode error - map field "addresses" had too many elements');s.addresses.push(Hm.codec().decode(e,e.uint32(),{limits:n.limits?.addresses$}));break;case 2:if(null!=n.limits?.protocols&&s.protocols.length===n.limits.protocols)throw new er('Decode error - map field "protocols" had too many elements');s.protocols.push(e.string());break;case 4:s.publicKey=e.bytes();break;case 5:s.peerRecordEnvelope=e.bytes();break;case 6:{if(null!=n.limits?.metadata&&s.metadata.size===n.limits.metadata)throw new tr('Decode error - map field "metadata" had too many elements');const r=t.Peer$metadataEntry.codec().decode(e,e.uint32());s.metadata.set(r.key,r.value);break}case 7:{if(null!=n.limits?.tags&&s.tags.size===n.limits.tags)throw new tr('Decode error - map field "tags" had too many elements');const r=t.Peer$tagsEntry.codec().decode(e,e.uint32(),{limits:{value:n.limits?.tags$value}});s.tags.set(r.key,r.value);break}case 8:s.updated=e.uint64Number();break;default:e.skipType(7&r)}}return s})),r),t.encode=e=>mt(e,t.codec()),t.decode=(e,r)=>T(e,t.codec(),r)})(Vm||(Vm={})),(t=>{let r;t.codec=()=>(null==r&&(r=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.multiaddr&&e.multiaddr.byteLength>0&&(t.uint32(10),t.bytes(e.multiaddr)),null!=e.isCertified&&(t.uint32(16),t.bool(e.isCertified)),null!=e.observed&&(t.uint32(24),t.uint64Number(e.observed)),!1!==r.lengthDelimited&&t.ldelim()},(t,r)=>{const n={multiaddr:e(0)},s=null==r?t.len:t.pos+r;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:n.multiaddr=t.bytes();break;case 2:n.isCertified=t.bool();break;case 3:n.observed=t.uint64Number();break;default:t.skipType(7&e)}}return n})),r),t.encode=e=>mt(e,t.codec()),t.decode=(e,r)=>T(e,t.codec(),r)})(Hm||(Hm={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.value&&0!==e.value&&(t.uint32(8),t.uint32(e.value)),null!=e.expiry&&(t.uint32(16),t.uint64(e.expiry)),!1!==r.lengthDelimited&&t.ldelim()},(e,t)=>{const r={value:0},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();switch(t>>>3){case 1:r.value=e.uint32();break;case 2:r.expiry=e.uint64();break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(jm||(jm={}));const Jm="/",ey=(new TextEncoder).encode(Jm),ty=ey[0];class ry{_buf;constructor(e,t){if("string"==typeof e)this._buf=rt(e);else{if(!(e instanceof Uint8Array))throw Error("Invalid key, should be String of Uint8Array");this._buf=e}if(null==t&&(t=!0),t&&this.clean(),0===this._buf.byteLength||this._buf[0]!==ty)throw Error("Invalid key")}toString(e="utf8"){return ln(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new ry(e.join(Jm))}static random(){return new ry(Math.random().toString().substring(2))}static asKey(e){return e instanceof Uint8Array||"string"==typeof e?new ry(e):"function"==typeof e.uint8Array?new ry(e.uint8Array()):null}clean(){if(null!=this._buf&&0!==this._buf.byteLength||(this._buf=ey),this._buf[0]!==ty){const e=new Uint8Array(this._buf.byteLength+1);e.fill(ty,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===ty;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),r=e.list();for(let e=0;e<t.length;e++){if(r.length<e+1)return!1;const n=t[e],s=r[e];if(n<s)return!0;if(n>s)return!1}return t.length<r.length}reverse(){return ry.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(Jm).slice(1)}type(){return function(e){const t=e.split(":");if(t.length<2)return"";return t.slice(0,-1).join(":")}(this.baseNamespace())}name(){return function(e){const t=e.split(":");return t[t.length-1]}(this.baseNamespace())}instance(e){return new ry(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(Jm)||(e+=Jm),e+=this.type(),new ry(e)}parent(){const e=this.list();return 1===e.length?new ry(Jm):new ry(e.slice(0,-1).join(Jm))}child(e){return this.toString()===Jm?e:e.toString()===Jm?this:new ry(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()!==this.toString()&&e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()!==this.toString()&&this.toString().startsWith(e.toString())}isTopLevel(){return 1===this.list().length}concat(...e){return ry.withNamespaces([...this.namespaces(),...(t=e.map(e=>e.namespaces()),[].concat(...t))]);var t}}const ny="/peers/";function sy(e){if(!Ei(e)||null==e.type)throw new Pi("Invalid PeerId");const t=e.toCID().toString();return new ry(`${ny}${t}`)}async function iy(e,t,r,n,s){const i=new Map;for(const n of r){if(null==n)continue;if(n.multiaddr instanceof Uint8Array&&(n.multiaddr=Zl(n.multiaddr)),!Xl(n.multiaddr))throw new Pi("Multiaddr was invalid");if(!await t(e,n.multiaddr,s))continue;const r=n.isCertified??!1,o=n.multiaddr.toString(),a=i.get(o);null!=a?n.isCertified=a.isCertified||r:i.set(o,{multiaddr:n.multiaddr,isCertified:r})}return[...i.values()].sort((e,t)=>e.multiaddr.toString().localeCompare(t.multiaddr.toString())).map(({isCertified:t,multiaddr:r})=>{const n=r.getPeerId();return e.equals(n)&&(r=r.decapsulate(Zl("/p2p/"+e))),{isCertified:t,multiaddr:r.bytes}})}async function oy(e,t,r,n){if(null==t)throw new Pi("Invalid PeerData");if(null!=t.publicKey&&null!=e.publicKey&&!t.publicKey.equals(e.publicKey))throw new Pi("publicKey bytes do not match peer id publicKey bytes");const s=n.existingPeer?.peer;if(null!=s&&!e.equals(s.id))throw new Pi("peer id did not match existing peer id");let i,o=s?.addresses??[],a=new Set(s?.protocols??[]),c=s?.metadata??new Map,l=s?.tags??new Map,u=s?.peerRecordEnvelope;if("patch"===r){if(null==t.multiaddrs&&null==t.addresses||(o=[],null!=t.multiaddrs&&o.push(...t.multiaddrs.map(e=>({isCertified:!1,multiaddr:e}))),null!=t.addresses&&o.push(...t.addresses)),null!=t.protocols&&(a=new Set(t.protocols)),null!=t.metadata){c=ay(t.metadata instanceof Map?[...t.metadata.entries()]:Object.entries(t.metadata),{validate:cy})}if(null!=t.tags){l=ay(t.tags instanceof Map?[...t.tags.entries()]:Object.entries(t.tags),{validate:ly,map:uy})}null!=t.peerRecordEnvelope&&(u=t.peerRecordEnvelope)}if("merge"===r){if(null!=t.multiaddrs&&o.push(...t.multiaddrs.map(e=>({isCertified:!1,multiaddr:e}))),null!=t.addresses&&o.push(...t.addresses),null!=t.protocols&&(a=new Set([...a,...t.protocols])),null!=t.metadata){const e=t.metadata instanceof Map?[...t.metadata.entries()]:Object.entries(t.metadata);for(const[t,r]of e)null==r?c.delete(t):c.set(t,r);c=ay([...c.entries()],{validate:cy})}if(null!=t.tags){const e=t.tags instanceof Map?[...t.tags.entries()]:Object.entries(t.tags),r=new Map(l);for(const[t,n]of e)null==n?r.delete(t):r.set(t,n);l=ay([...r.entries()],{validate:ly,map:uy})}null!=t.peerRecordEnvelope&&(u=t.peerRecordEnvelope)}null!=s?.id.publicKey?i=Zc(s.id.publicKey):null!=t.publicKey?i=Zc(t.publicKey):null!=e.publicKey&&(i=Zc(e.publicKey));const h={addresses:await iy(e,n.addressFilter??(async()=>!0),o,n.existingPeer?.peerPB.addresses,n),protocols:[...a.values()].sort((e,t)=>e.localeCompare(t)),metadata:c,tags:l,publicKey:i,peerRecordEnvelope:u};return h.addresses.forEach(e=>{e.observed=n.existingPeer?.peerPB.addresses?.find(e=>Yn(e.multiaddr,e.multiaddr))?.observed??Date.now()}),"RSA"!==e.type&&delete h.publicKey,h}function ay(e,t){const r=new Map;for(const[r,n]of e)null!=n&&t.validate(r,n);for(const[n,s]of e.sort(([e],[t])=>e.localeCompare(t)))null!=s&&r.set(n,t.map?.(n,s)??s);return r}function cy(e,t){if("string"!=typeof e)throw new Pi("Metadata key must be a string");if(!(t instanceof Uint8Array))throw new Pi("Metadata value must be a Uint8Array")}function ly(e,t){if("string"!=typeof e)throw new Pi("Tag name must be a string");if(null!=t.value){if(parseInt(""+t.value,10)!==t.value)throw new Pi("Tag value must be an integer");if(t.value<0||t.value>100)throw new Pi("Tag value must be between 0-100")}if(null!=t.ttl){if(parseInt(""+t.ttl,10)!==t.ttl)throw new Pi("Tag ttl must be an integer");if(t.ttl<0)throw new Pi("Tag ttl must be between greater than 0")}}function uy(e,t){let r;null!=t.expiry&&(r=t.expiry),null!=t.ttl&&(r=BigInt(Date.now()+Number(t.ttl)));const n={value:t.value??0};return null!=r&&(n.expiry=r),n}function hy(e){const t=e.toString().split("/")[2];return ol(je.parse(t,Y))}function dy(e,t,r){return function(e,t,r){return Wm(e,Vm.decode(t),r)}(hy(e),t,r)}class py{peerId;datastore;locks;addressFilter;log;maxAddressAge;maxPeerAge;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.peerId=e.peerId,this.datastore=e.datastore,this.addressFilter=t.addressFilter,this.locks=function(e){const{name:t,metrics:r}=e;let n;return n=null!=r?new hm({name:t,metrics:r}):new Zg,n}({name:"libp2p_peer_store_locks",metrics:e.metrics}),this.maxAddressAge=t.maxAddressAge??36e5,this.maxPeerAge=t.maxPeerAge??216e5}getLock(e){let t=this.locks.get(e);return null==t&&(t={refs:0,lock:Km({name:e.toString(),singleProcess:!0})},this.locks.set(e,t)),t.refs++,t}maybeRemoveLock(e,t){t.refs--,0===t.refs&&(t.lock.finalize(),this.locks.delete(e))}async getReadLock(e,t){const r=this.getLock(e);try{const n=await r.lock.readLock(t);return()=>{n(),this.maybeRemoveLock(e,r)}}catch(t){throw this.maybeRemoveLock(e,r),t}}async getWriteLock(e,t){const r=this.getLock(e);try{const n=await r.lock.writeLock(t);return()=>{n(),this.maybeRemoveLock(e,r)}}catch(t){throw this.maybeRemoveLock(e,r),t}}async has(e,t){try{return await this.load(e,t),!0}catch(e){if("NotFoundError"!==e.name)throw e}return!1}async delete(e,t){this.peerId.equals(e)||await this.datastore.delete(sy(e),t)}async load(e,t){const r=sy(e),n=await this.datastore.get(r,t),s=Vm.decode(n);if(this.#_(e,s))throw await this.datastore.delete(r,t),new Ui;return Wm(e,s,this.peerId.equals(e)?1/0:this.maxAddressAge)}async save(e,t,r){const n=await this.#R(e,r),s=await oy(e,t,"patch",{...r,addressFilter:this.addressFilter});return this.#L(e,s,n)}async patch(e,t,r){const n=await this.#R(e,r),s=await oy(e,t,"patch",{...r,addressFilter:this.addressFilter,existingPeer:n});return this.#L(e,s,n)}async merge(e,t,r){const n=await this.#R(e,r),s=await oy(e,t,"merge",{addressFilter:this.addressFilter,existingPeer:n});return this.#L(e,s,n)}async*all(e){for await(const{key:t,value:r}of this.datastore.query(function(e,t){return{prefix:ny,filters:(e.filters??[]).map(e=>({key:r,value:n})=>e(dy(r,n,t))),orders:(e.orders??[]).map(e=>(r,n)=>e(dy(r.key,r.value,t),dy(n.key,n.value,t)))}}(e??{},this.maxAddressAge),e)){const n=hy(t);if(n.equals(this.peerId))continue;const s=Vm.decode(r);this.#_(n,s)?await this.datastore.delete(t,e):yield Wm(n,s,this.peerId.equals(n)?1/0:this.maxAddressAge)}}async#R(e,t){try{const r=sy(e),n=await this.datastore.get(r,t),s=Vm.decode(n);if(this.#_(e,s))throw await this.datastore.delete(r,t),new Ui;return{peerPB:s,peer:Wm(e,s,this.maxAddressAge)}}catch(e){"NotFoundError"!==e.name&&this.log.error("invalid peer data found in peer store - %e",e)}}async#L(e,t,r,n){t.updated=Date.now();const s=Vm.encode(t);return await this.datastore.put(sy(e),s,n),{peer:Wm(e,t,this.maxAddressAge),previous:r?.peer,updated:null==r||!Xm(t,r.peerPB)}}#_(e,t){if(null==t.updated)return!0;if(this.peerId.equals(e))return!1;const r=t.updated<Date.now()-this.maxPeerAge,n=Date.now()-this.maxAddressAge,s=t.addresses.filter(e=>null!=e.observed&&e.observed>n);return r&&0===s.length}}class fy{store;events;peerId;log;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.events=e.events,this.peerId=e.peerId,this.store=new py(e,t)}[Symbol.toStringTag]="@libp2p/peer-store";async forEach(e,t){for await(const r of this.store.all(t))e(r)}async all(e){return Zn(this.store.all(e))}async delete(e,t){const r=await this.store.getReadLock(e,t);try{await this.store.delete(e,t)}finally{r()}}async has(e,t){const r=await this.store.getReadLock(e,t);try{return await this.store.has(e,t)}finally{this.log.trace("has release read lock"),r?.()}}async get(e,t){const r=await this.store.getReadLock(e,t);try{return await this.store.load(e,t)}finally{r?.()}}async getInfo(e,t){const r=await this.get(e,t);return{id:r.id,multiaddrs:r.addresses.map(({multiaddr:e})=>e)}}async save(e,t,r){const n=await this.store.getWriteLock(e,r);try{const n=await this.store.save(e,t,r);return this.#D(e,n),n.peer}finally{n?.()}}async patch(e,t,r){const n=await this.store.getWriteLock(e,r);try{const n=await this.store.patch(e,t,r);return this.#D(e,n),n.peer}finally{n?.()}}async merge(e,t,r){const n=await this.store.getWriteLock(e,r);try{const n=await this.store.merge(e,t,r);return this.#D(e,n),n.peer}finally{n?.()}}async consumePeerRecord(e,t,r){const n=Ei(t)?t:Ei(t?.expectedPeer)?t.expectedPeer:void 0,s=Ei(t)||void 0===t?r:t,i=await Nd.openAndCertify(e,Bd.DOMAIN,s),o=ol(i.publicKey.toCID());if(!1===n?.equals(o))return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",n,o),!1;const a=Bd.createFromProtobuf(i.payload);let c;try{c=await this.get(o,s)}catch(e){if("NotFoundError"!==e.name)throw e}if(null!=c?.peerRecordEnvelope){const e=Nd.createFromProtobuf(c.peerRecordEnvelope),t=Bd.createFromProtobuf(e.payload);if(t.seqNumber>=a.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",t.seqNumber,a.seqNumber),!1}return await this.patch(a.peerId,{peerRecordEnvelope:e,addresses:a.multiaddrs.map(e=>({isCertified:!0,multiaddr:e}))},s),!0}#D(e,t){t.updated&&(this.peerId.equals(e)?this.events.safeDispatchEvent("self:peer:update",{detail:t}):this.events.safeDispatchEvent("peer:update",{detail:t}))}}class gy extends Error{static name="NotFoundError";static code="ERR_NOT_FOUND";name=gy.name;code=gy.code;constructor(e="Not Found"){super(e)}}function my(e,t){let r=0;if(null!=e[Symbol.asyncIterator])return async function*(){for await(const n of e)await t(n,r++)&&(yield n)}();const n=function(e){const[t,r]=null!=e[Symbol.asyncIterator]?[e[Symbol.asyncIterator](),Symbol.asyncIterator]:[e[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>t.next(),push(e){n.push(e)},next:()=>n.length>0?{done:!1,value:n.shift()}:t.next(),[r](){return this}}}(e),{value:s,done:i}=n.next();if(!0===i)return function*(){}();const o=t(s,r++);if("function"==typeof o.then)return async function*(){await o&&(yield s);for(const e of n)await t(e,r++)&&(yield e)}();const a=t;return function*(){!0===o&&(yield s);for(const e of n)a(e,r++)&&(yield e)}()}function yy(e,t){return null!=e[Symbol.asyncIterator]?async function*(){const r=await Zn(e);yield*r.sort(t)}():function*(){const r=Zn(e);yield*r.sort(t)}()}function by(e,t){return null!=e[Symbol.asyncIterator]?async function*(){let r=0;if(!(t<1))for await(const n of e)if(yield n,r++,r===t)return}():function*(){let r=0;if(!(t<1))for(const n of e)if(yield n,r++,r===t)return}()}class wy{put(e,t,r){return Promise.reject(Error(".put is not implemented"))}get(e,t){return Promise.reject(Error(".get is not implemented"))}has(e,t){return Promise.reject(Error(".has is not implemented"))}delete(e,t){return Promise.reject(Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:r,value:n}of e)await this.put(r,n,t),yield r}async*getMany(e,t={}){for await(const r of e)yield{key:r,value:await this.get(r,t)}}async*deleteMany(e,t={}){for await(const r of e)await this.delete(r,t),yield r}batch(){let e=[],t=[];return{put(t,r){e.push({key:t,value:r})},delete(e){t.push(e)},commit:async r=>{await $d(this.putMany(e,r)),e=[],await $d(this.deleteMany(t,r)),t=[]}}}async*_all(e,t){throw Error("._all is not implemented")}async*_allKeys(e,t){throw Error("._allKeys is not implemented")}query(e,t){let r=this._all(e,t);if(null!=e.prefix){const t=e.prefix;r=my(r,e=>e.key.toString().startsWith(t))}if(Array.isArray(e.filters)&&(r=e.filters.reduce((e,t)=>my(e,t),r)),Array.isArray(e.orders)&&(r=e.orders.reduce((e,t)=>yy(e,t),r)),null!=e.offset){let t=0;const n=e.offset;r=my(r,()=>t++>=n)}return null!=e.limit&&(r=by(r,e.limit)),r}queryKeys(e,t){let r=this._allKeys(e,t);if(null!=e.prefix){const t=e.prefix;r=my(r,e=>e.toString().startsWith(t))}if(Array.isArray(e.filters)&&(r=e.filters.reduce((e,t)=>my(e,t),r)),Array.isArray(e.orders)&&(r=e.orders.reduce((e,t)=>yy(e,t),r)),null!=e.offset){const t=e.offset;let n=0;r=my(r,()=>n++>=t)}return null!=e.limit&&(r=by(r,e.limit)),r}}class vy extends wy{data;constructor(){super(),this.data=new Map}put(e,t,r){return r?.signal?.throwIfAborted(),this.data.set(e.toString(),t),e}get(e,t){t?.signal?.throwIfAborted();const r=this.data.get(e.toString());if(null==r)throw new gy;return r}has(e,t){return t?.signal?.throwIfAborted(),this.data.has(e.toString())}delete(e,t){t?.signal?.throwIfAborted(),this.data.delete(e.toString())}*_all(e,t){t?.signal?.throwIfAborted();for(const[e,r]of this.data.entries())yield{key:new ry(e),value:r},t?.signal?.throwIfAborted()}*_allKeys(e,t){t?.signal?.throwIfAborted();for(const e of this.data.keys())yield new ry(e),t?.signal?.throwIfAborted()}}class Ey extends Map{metric;constructor(e){super();const{name:t,metrics:r}=e;this.metric=r.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function Sy(e){const{name:t,metrics:r}=e;let n;return n=null!=r?new Ey({name:t,metrics:r}):new Map,n}const Ay=864e13;class Iy{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=Sy({name:"libp2p_address_manager_dns_mappings",metrics:e.metrics})}has(e){const t=this.findHost(e);for(const e of this.mappings.values())if(e.domain===t)return!0;return!1}add(e,t){t.forEach(t=>{this.log("add DNS mapping %s to %s",t,e);const r=!0===Yd(t);this.mappings.set(t,{domain:e,verified:r,expires:r?Ay-Date.now():0,lastVerified:r?Ay-Date.now():void 0})})}remove(e){const t=this.findHost(e);let r=!1;for(const[e,n]of this.mappings.entries())n.domain===t&&(this.log("removing %s to %s DNS mapping %e",e,n.domain,Error("where")),this.mappings.delete(e),r=r||n.verified);return r}getAll(e){const t=[];for(let r=0;r<e.length;r++){const n=e[r].multiaddr.stringTuples(),s=n[0][1];if(null!=s)for(const[i,o]of this.mappings.entries()){if(s!==i)continue;this.maybeAddSNITuple(n,o.domain)&&(e.splice(r,1),r--,t.push({multiaddr:Zl("/"+n.map(e=>[Ql(e[0]).name,e[1]].join("/")).join("/")),verified:o.verified,type:"dns-mapping",expires:o.expires,lastVerified:o.lastVerified}))}}return t}maybeAddSNITuple(e,t){for(let r=0;r<e.length;r++)if(448===e[r][0]&&449!==e[r+1]?.[0])return e.splice(r+1,0,[449,t]),!0;return!1}confirm(e,t){const r=this.findHost(e);let n=!1;for(const[e,s]of this.mappings.entries())s.domain===r&&(this.log("marking %s to %s DNS mapping as verified",e,s.domain),n=s.verified,s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now());return n}unconfirm(e,t){const r=this.findHost(e);let n=!1;for(const[e,s]of this.mappings.entries())s.domain===r&&(this.log("removing verification of %s to %s DNS mapping",e,s.domain),n=n||s.verified,s.verified=!1,s.expires=Date.now()+t);return n}findHost(e){for(const t of e.stringTuples()){if(449===t[0])return t[1];if(53===t[0]||54===t[0]||55===t[0]||56===t[0])return t[1]}}}class Cy{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=Sy({name:"libp2p_address_manager_ip_mappings",metrics:e.metrics})}has(e){const t=e.stringTuples();for(const e of this.mappings.values())for(const r of e)if(r.externalIp===t[0][1])return!0;return!1}add(e,t,r,n=t,s="tcp"){const i=`${e}-${t}-${s}`,o=this.mappings.get(i)??[],a={internalIp:e,internalPort:t,externalIp:r,externalPort:n,externalFamily:gl(r)?4:6,protocol:s,verified:!1,expires:0};o.push(a),this.mappings.set(i,o)}remove(e){const t=e.stringTuples(),r=t[0][1]??"",n=6===t[1][0]?"tcp":"udp",s=parseInt(t[1][1]??"0");let i=!1;for(const[e,t]of this.mappings.entries()){for(let e=0;e<t.length;e++){const o=t[e];o.externalIp===r&&o.externalPort===s&&o.protocol===n&&(this.log("removing %s:%s to %s:%s %s IP mapping",o.externalIp,o.externalPort,r,s,n),i=i||o.verified,t.splice(e,1),e--)}0===t.length&&this.mappings.delete(e)}return i}getAll(e){const t=[];for(const{multiaddr:r}of e){const e=r.stringTuples();let n;if(4!==e[0][0]&&41!==e[0][0]||6!==e[1][0]?4!==e[0][0]&&41!==e[0][0]||273!==e[1][0]||(n=`${e[0][1]}-${e[1][1]}-udp`):n=`${e[0][1]}-${e[1][1]}-tcp`,null==n)continue;const s=this.mappings.get(n);if(null!=s)for(const r of s)e[0][0]=4===r.externalFamily?4:41,e[0][1]=r.externalIp,e[1][1]=""+r.externalPort,t.push({multiaddr:Zl("/"+e.map(e=>[Ql(e[0]).name,e[1]].join("/")).join("/")),verified:r.verified,type:"ip-mapping",expires:r.expires,lastVerified:r.lastVerified})}return t}confirm(e,t){const r=e.stringTuples()[0][1];let n=!1;for(const e of this.mappings.values())for(const s of e)s.externalIp===r&&(this.log("marking %s to %s IP mapping as verified",s.internalIp,s.externalIp),n=s.verified,s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now());return n}unconfirm(e,t){const r=e.stringTuples(),n=r[0][1]??"",s=6===r[1][0]?"tcp":"udp",i=parseInt(r[1][1]??"0");let o=!1;for(const e of this.mappings.values())for(let r=0;r<e.length;r++){const a=e[r];a.externalIp===n&&a.externalPort===i&&a.protocol===s&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",a.externalIp,a.externalPort,n,i,s),o=o||a.verified,a.verified=!1,a.expires=Date.now()+t)}return o}}const xy=10;class ky{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=Sy({name:"libp2p_address_manager_observed_addresses",metrics:e.metrics}),this.maxObservedAddresses=t.maxObservedAddresses??xy}has(e){return this.addresses.has(e.toString())}removePrefixed(e){for(const t of this.addresses.keys())t.toString().startsWith(e)&&this.addresses.delete(t)}add(e){this.addresses.size!==this.maxObservedAddresses&&(ep(e)||function(e){try{for(const{code:t,value:r}of e.getComponents())if(t!==bl&&null!=r){if(4===t)return r.startsWith("169.254.");if(t===yl)return r.toLowerCase().startsWith("fe80")}}catch{}return!1}(e)||(this.log("adding observed address %a",e),this.addresses.set(e.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([e,t])=>({multiaddr:Zl(e),verified:t.verified,type:"observed",expires:t.expires,lastVerified:t.lastVerified}))}remove(e){const t=this.addresses.get(e.toString())?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(e.toString()),t}confirm(e,t){const r=e.toString(),n=this.addresses.get(r)??{verified:!1,expires:Date.now()+t,lastVerified:Date.now()},s=n.verified;return n.verified=!0,n.expires=Date.now()+t,n.lastVerified=Date.now(),this.log("marking observed address %a as verified",r),this.addresses.set(r,n),s}}const Ty=[4,yl,53,54,55,56];function Py(e){try{for(const{code:t}of e.getComponents())if(t!==bl)return Ty.includes(t)}catch{}return!1}const _y=10;class Ry{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=Sy({name:"libp2p_address_manager_transport_addresses",metrics:e.metrics}),this.maxObservedAddresses=t.maxObservedAddresses??_y}get(e,t){if(ep(e))return{multiaddr:e,verified:!0,type:"transport",expires:Date.now()+t,lastVerified:Date.now()};const r=this.toKey(e);let n=this.addresses.get(r);return null==n&&(n={verified:!Py(e),expires:0},this.addresses.set(r,n)),{multiaddr:e,verified:n.verified,type:"transport",expires:n.expires,lastVerified:n.lastVerified}}has(e){const t=this.toKey(e);return this.addresses.has(t)}remove(e){const t=this.toKey(e),r=this.addresses.get(t)?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(t),r}confirm(e,t){const r=this.toKey(e),n=this.addresses.get(r)??{verified:!1,expires:0,lastVerified:0},s=n.verified;return n.verified=!0,n.expires=Date.now()+t,n.lastVerified=Date.now(),this.addresses.set(r,n),s}unconfirm(e,t){const r=this.toKey(e),n=this.addresses.get(r)??{verified:!1,expires:0},s=n.verified;return n.verified=!1,n.expires=Date.now()+t,this.addresses.set(r,n),s}toKey(e){if(Py(e)){const t=e.toOptions();return`${t.host}-${t.port}-${t.transport}`}return e.toString()}}const Ly={addressVerificationTTL:6e5,addressVerificationRetry:3e5},Dy=e=>e;function My(e,t){const r=e.getPeerId();if(null!=r){nl(r).equals(t)&&(e=e.decapsulate(Zl("/p2p/"+t.toString())))}return e}class Ny{log;components;listen;announce;appendAnnounce;announceFilter;observed;dnsMappings;ipMappings;transportAddresses;observedAddressFilter;addressVerificationTTL;addressVerificationRetry;constructor(e,t={}){const{listen:r=[],announce:n=[],appendAnnounce:s=[]}=t;this.components=e,this.log=e.logger.forComponent("libp2p:address-manager"),this.listen=r.map(e=>e.toString()),this.announce=new Set(n.map(e=>e.toString())),this.appendAnnounce=new Set(s.map(e=>e.toString())),this.observed=new ky(e,t),this.dnsMappings=new Iy(e,t),this.ipMappings=new Cy(e,t),this.transportAddresses=new Ry(e,t),this.announceFilter=t.announceFilter??Dy,this.observedAddressFilter=um(1024),this.addressVerificationTTL=t.addressVerificationTTL??Ly.addressVerificationTTL,this.addressVerificationRetry=t.addressVerificationRetry??Ly.addressVerificationRetry,this._updatePeerStoreAddresses=qd(this._updatePeerStoreAddresses.bind(this),1e3),e.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),e.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}[Symbol.toStringTag]="@libp2p/address-manager";_updatePeerStoreAddresses(){const e=this.getAddresses().map(e=>e.getPeerId()===this.components.peerId.toString()?e.decapsulate("/p2p/"+this.components.peerId.toString()):e);this.components.peerStore.patch(this.components.peerId,{multiaddrs:e}).catch(e=>{this.log.error("error updating addresses",e)})}getListenAddrs(){return Array.from(this.listen).map(e=>Zl(e))}getAnnounceAddrs(){return Array.from(this.announce).map(e=>Zl(e))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(e=>Zl(e))}getObservedAddrs(){return this.observed.getAll().map(e=>e.multiaddr)}addObservedAddr(e){const t=e.stringTuples(),r=`${t[0][1]}:${t[1][1]}`;this.observedAddressFilter.has(r)||(this.observedAddressFilter.add(r),e=My(e,this.components.peerId),this.ipMappings.has(e)||this.dnsMappings.has(e)||this.observed.add(e))}confirmObservedAddr(e,t){e=My(e,this.components.peerId);let r=!0;if("transport"===t?.type||this.transportAddresses.has(e)){!this.transportAddresses.confirm(e,t?.ttl??this.addressVerificationTTL)&&r&&(r=!1)}if("dns-mapping"===t?.type||this.dnsMappings.has(e)){!this.dnsMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&r&&(r=!1)}if("ip-mapping"===t?.type||this.ipMappings.has(e)){!this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&r&&(r=!1)}if("observed"===t?.type||this.observed.has(e))if(this.maybeUpgradeToIPMapping(e))this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL),r=!1;else{!this.observed.confirm(e,t?.ttl??this.addressVerificationTTL)&&r&&(r=!1)}r||this._updatePeerStoreAddresses()}removeObservedAddr(e,t){e=My(e,this.components.peerId),this.observed.has(e)&&this.observed.remove(e),this.transportAddresses.has(e)&&this.transportAddresses.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.dnsMappings.has(e)&&this.dnsMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.ipMappings.has(e)&&this.ipMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry)}getAddresses(){const e=new Set,t=this.getAddressesWithMetadata().filter(t=>{if(!t.verified)return!1;const r=t.multiaddr.toString();return!e.has(r)&&(e.add(r),!0)}).map(e=>e.multiaddr);return this.announceFilter(t.map(e=>{const t=Zl(e),r=t.getComponents().pop();return r?.value===this.components.peerId.toString()?t:t.encapsulate("/p2p/"+this.components.peerId.toString())}))}getAddressesWithMetadata(){const e=this.getAnnounceAddrs();if(e.length>0)return this.components.transportManager.getListeners().forEach(t=>{t.updateAnnounceAddrs(e)}),e.map(e=>({multiaddr:e,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let t=[];t=t.concat(this.components.transportManager.getAddrs().map(e=>this.transportAddresses.get(e,this.addressVerificationTTL)));const r=this.getAppendAnnounceAddrs();return r.length>0&&(this.components.transportManager.getListeners().forEach(e=>{e.updateAnnounceAddrs(r)}),t=t.concat(r.map(e=>({multiaddr:e,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})))),t=t.concat(this.observed.getAll()),t=t.concat(this.ipMappings.getAll(t)),t=t.concat(this.dnsMappings.getAll(t)),t}addDNSMapping(e,t){this.dnsMappings.add(e,t)}removeDNSMapping(e){this.dnsMappings.remove(Zl("/dns/"+e))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(e,t,r,n=t,s="tcp"){this.ipMappings.add(e,t,r,n,s),this.observed.removePrefixed(`/ip${gl(r)?4:6}/${r}/${s}/${n}`)}removePublicAddressMapping(e,t,r,n=t,s="tcp"){this.ipMappings.remove(Zl(`/ip${gl(r)?4:6}/${r}/${s}/${n}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(e){if(this.ipMappings.has(e))return!1;const t=e.toOptions();if(6===t.family||"127.0.0.1"===t.host||!0===Yd(t.host))return!1;const r=this.components.transportManager.getListeners(),n=[e=>Lp.exactMatch(e)||Mp.exactMatch(e),e=>Cp.exactMatch(e),e=>Pp.exactMatch(e)];for(const s of n){if(!s(e))continue;const n=r.filter(e=>e.getAddrs().filter(e=>4===e.toOptions().family&&s(e)).length>0);if(1!==n.length)continue;const i=n[0].getAddrs().filter(e=>"127.0.0.1"!==e.toOptions().host).pop();if(null==i)continue;const o=i.toOptions();return this.observed.remove(e),this.ipMappings.add(o.host,o.port,t.host,t.port,t.transport),!0}return!1}}var Oy;(e=>{e.NOT_STARTED_YET="The libp2p node is not started yet",e.NOT_FOUND="Not found"})(Oy||(Oy={}));class Uy extends Error{constructor(e="Missing service"){super(e),this.name="MissingServiceError"}}class Fy extends Error{constructor(e="Unmet service dependencies"){super(e),this.name="UnmetServiceDependenciesError"}}class By extends Error{constructor(e="No content routers available"){super(e),this.name="NoContentRoutersError"}}class qy extends Error{constructor(e="No peer routers available"){super(e),this.name="NoPeerRoutersError"}}class $y extends Error{constructor(e="Should not try to find self"){super(e),this.name="QueriedForSelfError"}}class zy extends Error{constructor(e="Unhandled protocol error"){super(e),this.name="UnhandledProtocolError"}}class Ky extends Error{constructor(e="Duplicate protocol handler error"){super(e),this.name="DuplicateProtocolHandlerError"}}class Vy extends Error{constructor(e="Dial denied error"){super(e),this.name="DialDeniedError"}}class Hy extends Error{constructor(e="No transport was configured to listen on this address"){super(e),this.name="UnsupportedListenAddressError"}}class jy extends Error{constructor(e="Configured listen addresses could not be listened on"){super(e),this.name="UnsupportedListenAddressesError"}}class Gy extends Error{constructor(e="No valid addresses"){super(e),this.name="NoValidAddressesError"}}class Wy extends Error{constructor(e="Connection intercepted"){super(e),this.name="ConnectionInterceptedError"}}class Xy extends Error{constructor(e="Connection denied"){super(e),this.name="ConnectionDeniedError"}}class Zy extends Error{constructor(e="Stream is not multiplexed"){super(e),this.name="MuxerUnavailableError"}}class Qy extends Error{constructor(e="Encryption failed"){super(e),this.name="EncryptionFailedError"}}class Yy extends Error{constructor(e="Transport unavailable"){super(e),this.name="TransportUnavailableError"}}class Jy{components={};_started=!1;constructor(e={}){this.components={};for(const[t,r]of Object.entries(e))this.components[t]=r;null==this.components.logger&&(this.components.logger=Hg())}isStarted(){return this._started}async _invokeStartableMethod(e){await Promise.all(Object.values(this.components).filter(e=>Ji(e)).map(async t=>{await(t[e]?.())}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const eb=["metrics","connectionProtector","dns"],tb=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function rb(e){return Array.isArray(e?.[eo])?e[eo]:[]}function nb(e){return Array.isArray(e?.[to])?e[to]:[]}function sb(e){return e?.[Symbol.toStringTag]??e?.toString()??"unknown"}function ib(e={}){return{async denyDialPeer(){return!1},async denyDialMultiaddr(e){if(Lp.matches(e))return!1;const t=e.stringTuples();return(4===t[0][0]||41===t[0][0])&&!!Yd(""+t[0][1])},async denyInboundConnection(){return!1},async denyOutboundConnection(){return!1},async denyInboundEncryptedConnection(){return!1},async denyOutboundEncryptedConnection(){return!1},async denyInboundUpgradedConnection(){return!1},async denyOutboundUpgradedConnection(){return!1},async filterMultiaddrForPeer(){return!0},...e}}function ob(e){if(Ei(e))return{peerId:e,multiaddrs:[]};let t,r=Array.isArray(e)?e:[e];if(r.length>0){const e=r[0].getPeerId();t=null==e?void 0:nl(e),r.forEach(e=>{if(!Xl(e))throw new Bi("Invalid multiaddr");const r=e.getPeerId();if(null==r){if(null!=t)throw new Pi("Multiaddrs must all have the same peer id or have no peer id")}else{const e=nl(r);if(!0!==t?.equals(e))throw new Pi("Multiaddrs must all have the same peer id or have no peer id")}})}return r=r.filter(e=>!hp.exactMatch(e)),{peerId:t,multiaddrs:r}}const ab=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];function cb(e){try{let t;if(t="string"==typeof e?Zl(e):e,!t.protoNames().includes("ipcidr")){const e=t.protoNames().includes("ip6")?"/ipcidr/128":"/ipcidr/32";t=t.encapsulate(e)}return function(e){let t,r;if(e.getComponents().forEach(e=>{"ip4"!==e.name&&"ip6"!==e.name||(r=e.value),"ipcidr"===e.name&&(t=e.value)}),null==t||null==r)throw Error("Invalid multiaddr");return new Vl(r,t)}(t)}catch(t){throw Error("Can't convert to IpNet, Invalid multiaddr format: "+e)}}class lb{connectionManager;peerStore;allow;events;log;constructor(e,t={}){this.allow=(t.allow??[]).map(e=>cb(e)),this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(e=>{this.log.error("error while pruning connections %e",e)})}async _maybePruneConnections(){const e=this.connectionManager.getConnections(),t=e.length,r=this.connectionManager.getMaxConnections();if(this.log("checking max connections limit %d/%d",t,r),t<=r)return;const n=new Zg;for(const t of e){const e=t.remotePeer;if(!n.has(e)){n.set(e,0);try{const t=await this.peerStore.get(e);n.set(e,[...t.tags.values()].reduce((e,t)=>e+t.value,0))}catch(e){"NotFoundError"!==e.name&&this.log.error("error loading peer tags",e)}}}const s=this.sortConnections(e,n),i=Math.max(t-r,0),o=[];for(const e of s){this.log("too many connections open - closing a connection to %p",e.remotePeer);if(this.allow.some(t=>t.contains(e.remoteAddr.nodeAddress().address))||o.push(e),o.length===i)break}await Promise.all(o.map(async e=>{await async function(e,t){const r=e?.streams?.map(e=>e.protocol)??[],n=t?.closableProtocols??ab;if(!(r.filter(e=>null!=e&&!n.includes(e)).length>0))try{await(e?.close(t))}catch(t){e?.abort(t)}}(e,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:o})}sortConnections(e,t){return e.sort((e,t)=>{const r=e.timeline.open,n=t.timeline.open;return r<n?1:r>n?-1:0}).sort((e,t)=>"outbound"===e.direction&&"inbound"===t.direction?1:"inbound"===e.direction&&"outbound"===t.direction?-1:0).sort((e,t)=>e.streams.length>t.streams.length?1:e.streams.length<t.streams.length?-1:0).sort((e,r)=>{const n=t.get(e.remotePeer)??0,s=t.get(r.remotePeer)??0;return n>s?1:n<s?-1:0})}}const ub="last-dial-failure",hb="last-dial-success";class db{deferred;signal;constructor(e){this.signal=e,this.deferred=ps(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new xi)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}}class pb{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=`${parseInt(1e9*Math.random()+"",10).toString()}${Date.now()}`,this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((e,t)=>e&&!0===t.signal?.aborted,!0)&&(this.controller.abort(new xi),this.cleanup())}async join(e={}){const t=new db(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await ws(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)})}}class fb extends Yi{concurrency;maxSize;queue;pending;sort;constructor(e={}){super(),this.concurrency=e.concurrency??1/0,this.maxSize=e.maxSize??1/0,this.pending=0,null!=e.metricName&&e.metrics?.registerMetricGroup(e.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})}),this.sort=e.sort,this.queue=[],this.emitEmpty=qd(this.emitEmpty.bind(this),1),this.emitIdle=qd(this.emitIdle.bind(this),1)}emitEmpty(){0===this.size&&this.safeDispatchEvent("empty")}emitIdle(){0===this.running&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(0===this.size)return this.emitEmpty(),0===this.running&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const t of this.queue)if("queued"===t.status){e=t;break}return null!=e&&(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(e){this.queue.push(e),null!=this.sort&&this.queue.sort(this.sort)}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new Xp;const r=new pb(e,t);return this.enqueue(r),this.safeDispatchEvent("add"),this.tryToStartAnother(),r.join(t).then(e=>(this.safeDispatchEvent("completed",{detail:e}),this.safeDispatchEvent("success",{detail:{job:r,result:e}}),e)).catch(e=>{if("queued"===r.status)for(let e=0;e<this.queue.length;e++)if(this.queue[e]===r){this.queue.splice(e,1);break}throw this.safeDispatchEvent("failure",{detail:{job:r,error:e}}),e})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new xi)}),this.clear()}async onEmpty(e){0!==this.size&&await pm(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await pm(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){0===this.pending&&0===this.size||await pm(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();const t=ys({objectMode:!0}),r=e=>{null!=e?this.abort():this.clear(),t.end(e)},n=e=>{null!=e.detail&&t.push(e.detail)},s=e=>{r(e.detail.error)},i=()=>{r()},o=()=>{r(new xi("Queue aborted"))};this.addEventListener("completed",n),this.addEventListener("failure",s),this.addEventListener("idle",i),e?.signal?.addEventListener("abort",o);try{yield*t}finally{this.removeEventListener("completed",n),this.removeEventListener("failure",s),this.removeEventListener("idle",i),e?.signal?.removeEventListener("abort",o),r()}}}class gb extends fb{constructor(e={}){super({...e,sort(e,t){return e.options.priority>t.options.priority?-1:e.options.priority<t.options.priority?1:0}})}}function mb(e){const t=new globalThis.AbortController;function r(){t.abort();for(const t of e)null!=t?.removeEventListener&&t.removeEventListener("abort",r)}for(const t of e){if(!0===t?.aborted){r();break}null!=t?.addEventListener&&t.addEventListener("abort",r)}const n=t.signal;return n.clear=function(){for(const t of e)null!=t?.removeEventListener&&t.removeEventListener("abort",r)},n}function yb(e){if(!Jd(e))return!1;const{address:t}=e.nodeAddress();return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(r=t)||/^::1$/.test(r);var r}function bb(e,t){const r=Cp.exactMatch(e.multiaddr),n=Cp.exactMatch(t.multiaddr);if(r&&!n)return-1;if(!r&&n)return 1;const s=Mp.exactMatch(e.multiaddr),i=Mp.exactMatch(t.multiaddr);if(s&&!i)return-1;if(!s&&i)return 1;const o=Lp.exactMatch(e.multiaddr),a=Lp.exactMatch(t.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const c=$p.exactMatch(e.multiaddr),l=$p.exactMatch(t.multiaddr);if(c&&!l)return-1;if(!c&&l)return 1;const u=Op.exactMatch(e.multiaddr),h=Op.exactMatch(t.multiaddr);if(u&&!h)return-1;if(!u&&h)return 1;const d=Fp.exactMatch(e.multiaddr),p=Fp.exactMatch(t.multiaddr);return d&&!p?-1:!d&&p?1:0}function wb(e,t){const r=yb(e.multiaddr),n=yb(t.multiaddr);return r&&!n?1:!r&&n?-1:0}function vb(e,t){const r=ep(e.multiaddr),n=ep(t.multiaddr);return r&&!n?1:!r&&n?-1:0}function Eb(e,t){return e.isCertified&&!t.isCertified?-1:!e.isCertified&&t.isCertified?1:0}function Sb(e,t){const r=qp.exactMatch(e.multiaddr),n=qp.exactMatch(t.multiaddr);return r&&!n?1:!r&&n?-1:0}const Ab=50,Ib=500,Cb=25,xb=1e4;class kb{queue;components;addressSorter;maxPeerAddrsToDial;maxDialQueueLength;dialTimeout;shutDownController;connections;log;constructor(e,t={}){this.addressSorter=t.addressSorter,this.maxPeerAddrsToDial=t.maxPeerAddrsToDial??Cb,this.maxDialQueueLength=t.maxDialQueueLength??Ib,this.dialTimeout=t.dialTimeout??xb,this.connections=t.connections??new Zg,this.log=e.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=e,this.shutDownController=new AbortController,this.shutDownController.signal;for(const[e,r]of Object.entries(t.resolvers??{}))Wl.set(e,r);this.queue=new gb({concurrency:t.maxParallelDials??Ab,metricName:"libp2p_dial_queue",metrics:e.metrics}),this.queue.addEventListener("error",e=>{e.detail?.name!==xi.name&&this.log.error("error in dial queue - %e",e.detail)})}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(e,t={}){const{peerId:r,multiaddrs:n}=ob(e),s=Array.from(this.connections.values()).flat().find(e=>!0!==t.force&&(!!e.remotePeer.equals(r)||n.find(t=>t.equals(e.remoteAddr))));if("open"===s?.status)return this.log("already connected to %a",s.remoteAddr),t.onProgress?.(new Bf("dial-queue:already-connected")),s;const i=this.queue.queue.find(e=>{if(!0===r?.equals(e.options.peerId))return!0;const t=e.options.multiaddrs;if(null==t)return!1;for(const e of n)if(t.has(e.toString()))return!0;return!1});if(null!=i){this.log("joining existing dial target for %p",r);for(const e of n)i.options.multiaddrs.add(e.toString());return t.onProgress?.(new Bf("dial-queue:already-in-dial-queue")),i.join(t)}if(this.queue.size>=this.maxDialQueueLength)throw new Gi("Dial queue is full");return this.log("creating dial target for %p",r,n.map(e=>e.toString())),t.onProgress?.(new Bf("dial-queue:add-to-dial-queue")),this.queue.add(async e=>{e.onProgress?.(new Bf("dial-queue:start-dial"));const t=mb([this.shutDownController.signal,e.signal]);try{return await this.dialPeer(e,t)}finally{t.clear()}},{peerId:r,priority:t.priority??Vb,multiaddrs:new Set(n.map(e=>e.toString())),signal:t.signal??AbortSignal.timeout(this.dialTimeout),onProgress:t.onProgress})}async dialPeer(e,t){const r=e.peerId,n=e.multiaddrs,s=new Set;let i=0===e.multiaddrs.size,o=0,a=0;const c=[];for(this.log("starting dial to %p",r);i||n.size>0;){a++,i=!1;const l=[],u=new Set(e.multiaddrs);n.clear(),this.log("calculating addrs to dial %p from %s",r,[...u]);const h=await this.calculateMultiaddrs(r,u,{...e,signal:t});for(const e of h)s.has(e.multiaddr.toString())?this.log.trace("skipping previously failed multiaddr %a while dialing %p",e.multiaddr,r):l.push(e);this.log("%s dial to %p with %s",1===a?"starting":"continuing",r,l.map(e=>e.multiaddr.toString())),e?.onProgress?.(new Bf("dial-queue:calculated-addresses",l));for(const n of l){if(o===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",o,e.peerId),new Gi("Peer had more than maxPeerAddrsToDial");o++;try{const s=await this.components.transportManager.dial(n.multiaddr,{...e,signal:t});this.log("dial to %a succeeded",n.multiaddr);try{await this.components.peerStore.merge(s.remotePeer,{multiaddrs:[s.remoteAddr],metadata:{[hb]:rt(Date.now().toString())}})}catch(e){this.log.error("could not update last dial failure key for %p",r,e)}return s}catch(e){if(this.log.error("dial failed to %a",n.multiaddr,e),s.add(n.multiaddr.toString()),null!=r)try{await this.components.peerStore.merge(r,{metadata:{[ub]:rt(Date.now().toString())}})}catch(e){this.log.error("could not update last dial failure key for %p",r,e)}if(t.aborted)throw new Hi(e.message);c.push(e)}}}if(1===c.length)throw c[0];throw new AggregateError(c,"All multiaddr dials failed")}async calculateMultiaddrs(e,t=new Set,r={}){const n=[...t].map(e=>({multiaddr:Zl(e),isCertified:!1}));if(null!=e){if(this.components.peerId.equals(e))throw new Gi("Tried to dial self");if(!0===await(this.components.connectionGater.denyDialPeer?.(e)))throw new Vy("The dial request is blocked by gater.allowDialPeer");if(0===n.length){this.log("loading multiaddrs for %p",e);try{const t=await this.components.peerStore.get(e);n.push(...t.addresses),this.log("loaded multiaddrs for %p",e,n.map(({multiaddr:e})=>e.toString()))}catch(e){if("NotFoundError"!==e.name)throw e}}if(0===n.length){this.log("looking up multiaddrs for %p in the peer routing",e);try{const t=await this.components.peerRouting.findPeer(e,r);this.log("found multiaddrs for %p in the peer routing",e,n.map(({multiaddr:e})=>e.toString())),n.push(...t.multiaddrs.map(e=>({multiaddr:e,isCertified:!1})))}catch(t){"NoPeerRoutersError"===t.name?this.log("no peer routers configured",e):this.log.error("looking up multiaddrs for %p in the peer routing failed - %e",e,t)}}}let s=(await Promise.all(n.map(async e=>{const t=await async function(e,t){let r=!1;for(const t of Wl.keys())if(r=e.protoNames().includes(t),r)break;if(!r)return[e];const n=await e.resolve(t);return t.log("resolved %s to",e,n.map(e=>e.toString())),n}(e.multiaddr,{dns:this.components.dns,...r,log:this.log});return 1===t.length&&t[0].equals(e.multiaddr)?e:t.map(e=>({multiaddr:e,isCertified:!1}))}))).flat();if(null!=e){const t="/p2p/"+e.toString();s=s.map(e=>{const r=e.multiaddr.getComponents().pop();return"p2p"!==r?.name?{multiaddr:e.multiaddr.encapsulate(t),isCertified:e.isCertified}:e})}const i=s.filter(t=>{if(null==this.components.transportManager.dialTransportForMultiaddr(t.multiaddr))return!1;const r=t.multiaddr.getPeerId();return null==e||null==r||e.equals(r)}),o=new Map;for(const e of i){const t=e.multiaddr.toString(),r=o.get(t);null==r?o.set(t,e):r.isCertified=r.isCertified||e.isCertified||!1}const a=[...o.values()];if(0===a.length)throw new Gy("The dial request has no valid addresses");const c=[];for(const e of a)null!=this.components.connectionGater.denyDialMultiaddr&&await this.components.connectionGater.denyDialMultiaddr(e.multiaddr)||c.push(e);const l=null==this.addressSorter?c.sort(bb).sort(Eb).sort(Sb).sort(vb).sort(wb):c.sort(this.addressSorter);if(0===l.length)throw new Vy("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",e??"unknown peer",s.map(({multiaddr:e})=>e.toString())),this.log.trace("addresses for %p after filtering",e??"unknown peer",l.map(({multiaddr:e})=>e.toString())),l}async isDialable(e,t={}){Array.isArray(e)||(e=[e]);try{const r=await this.calculateMultiaddrs(void 0,new Set(e.map(e=>e.toString())),t);return!1!==t.runOnLimitedConnection||null!=r.find(e=>!qp.matches(e.multiaddr))}catch(e){this.log.trace("error calculating if multiaddr(s) were dialable",e)}return!1}}class Tb extends fb{has(e){return null!=this.find(e)}find(e){return this.queue.find(t=>e.equals(t.options.peerId))}}var Pb,_b,Rb,Lb,Db,Mb={};function Nb(){return Rb||(Rb=1,e=Mb,t=function(){if(_b)return Pb;function e(e,t){"boolean"==typeof t&&(t={forever:t}),this._originalTimeouts=JSON.parse(JSON.stringify(e)),this._timeouts=e,this._options=t||{},this._maxRetryTime=t&&t.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}return _b=1,Pb=e,e.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)},e.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null},e.prototype.retry=function(e){if(this._timeout&&clearTimeout(this._timeout),!e)return!1;var t=(new Date).getTime();if(e&&t-this._operationStart>=this._maxRetryTime)return this._errors.push(e),this._errors.unshift(Error("RetryOperation timeout occurred")),!1;this._errors.push(e);var r=this._timeouts.shift();if(void 0===r){if(!this._cachedTimeouts)return!1;this._errors.splice(0,this._errors.length-1),r=this._cachedTimeouts.slice(-1)}var n=this;return this._timer=setTimeout(()=>{n._attempts++,n._operationTimeoutCb&&(n._timeout=setTimeout(()=>{n._operationTimeoutCb(n._attempts)},n._operationTimeout),n._options.unref&&n._timeout.unref()),n._fn(n._attempts)},r),this._options.unref&&this._timer.unref(),!0},e.prototype.attempt=function(e,t){this._fn=e,t&&(t.timeout&&(this._operationTimeout=t.timeout),t.cb&&(this._operationTimeoutCb=t.cb));var r=this;this._operationTimeoutCb&&(this._timeout=setTimeout(()=>{r._operationTimeoutCb()},r._operationTimeout)),this._operationStart=(new Date).getTime(),this._fn(this._attempts)},e.prototype.try=function(e){this.attempt(e)},e.prototype.start=function(e){this.attempt(e)},e.prototype.start=e.prototype.try,e.prototype.errors=function(){return this._errors},e.prototype.attempts=function(){return this._attempts},e.prototype.mainError=function(){if(0===this._errors.length)return null;for(var e={},t=null,r=0,n=0;n<this._errors.length;n++){var s=this._errors[n],i=s.message,o=(e[i]||0)+1;e[i]=o,o>=r&&(t=s,r=o)}return t},Pb}(),e.operation=r=>{var n=e.timeouts(r);return new t(n,{forever:r&&(r.forever||r.retries===1/0),unref:r&&r.unref,maxRetryTime:r&&r.maxRetryTime})},e.timeouts=function(e){if(e instanceof Array)return[].concat(e);var t={retries:10,factor:2,minTimeout:1e3,maxTimeout:1/0,randomize:!1};for(var r in e)t[r]=e[r];if(t.minTimeout>t.maxTimeout)throw Error("minTimeout is greater than maxTimeout");for(var n=[],s=0;s<t.retries;s++)n.push(this.createTimeout(s,t));return e&&e.forever&&!n.length&&n.push(this.createTimeout(s,t)),n.sort((e,t)=>e-t),n},e.createTimeout=(e,t)=>{var r=t.randomize?Math.random()+1:1,n=Math.round(r*Math.max(t.minTimeout,1)*Math.pow(t.factor,e));return n=Math.min(n,t.maxTimeout)},e.wrap=function(t,r,n){if(r instanceof Array&&(n=r,r=null),!n)for(var s in n=[],t)"function"==typeof t[s]&&n.push(s);for(var i=0;i<n.length;i++){var o=n[i],a=t[o];t[o]=function(n){var s=e.operation(r),i=[].slice.call(arguments,1),o=i.pop();i.push(function(e){s.retry(e)||(e&&(arguments[0]=s.mainError()),o.apply(this,arguments))}),s.attempt(()=>{n.apply(t,i)})}.bind(t,a),t[o].options=r}}),Mb;var e,t}var Ob=Cn(Db?Lb:(Db=1,Lb=Nb()));const Ub={}.toString,Fb=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Load failed","Network request failed","fetch failed","terminated"]);function Bb(e){var t;return!(!e||(t=e,"[object Error]"!==Ub.call(t))||"TypeError"!==e.name||"string"!=typeof e.message)&&("Load failed"===e.message?void 0===e.stack:Fb.has(e.message))}class qb extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,({message:e}=e)):(this.originalError=Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}}const $b=(e,t,r)=>{const n=r.retries-(t-1);return e.attemptNumber=t,e.retriesLeft=n,e};class zb{log;queue;started;peerStore;retries;retryInterval;backoffFactor;connectionManager;events;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.queue=new Tb({concurrency:t.maxParallelReconnects??5,metricName:"libp2p_reconnect_queue",metrics:e.metrics}),this.started=!1,this.retries=t.retries??5,this.backoffFactor=t.backoffFactor,this.retryInterval=t.retryInterval,this.events=e.events,e.events.addEventListener("peer:disconnect",e=>{this.maybeReconnect(e.detail).catch(t=>{this.log.error("failed to maybe reconnect to %p - %e",e.detail,t)})})}async maybeReconnect(e){if(!this.started)return;const t=await this.peerStore.get(e);Kb(t)&&(this.queue.has(e)||this.queue.add(async t=>{await async function(e,t){return new Promise((r,n)=>{t={...t},t.onFailedAttempt??=()=>{},t.shouldRetry??=()=>!0,t.retries??=10;const s=Ob.operation(t),i=()=>{s.stop(),n(t.signal?.reason)};t.signal&&!t.signal.aborted&&t.signal.addEventListener("abort",i,{once:!0});const o=()=>{t.signal?.removeEventListener("abort",i),s.stop()};s.attempt(async i=>{try{const t=await e(i);o(),r(t)}catch(e){try{if(!(e instanceof Error))throw new TypeError(`Non-error was thrown: "${e}". You should only throw errors.`);if(e instanceof qb)throw e.originalError;if(e instanceof TypeError&&!Bb(e))throw e;if($b(e,i,t),await t.shouldRetry(e)||(s.stop(),n(e)),await t.onFailedAttempt(e),!s.retry(e))throw s.mainError()}catch(e){$b(e,i,t),o(),n(e)}}})})}(async r=>{if(this.started)try{await this.connectionManager.openConnection(e,{signal:t?.signal})}catch(t){throw this.log("reconnecting to %p attempt %d of %d failed - %e",e,r,this.retries,t),t}},{signal:t?.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:e}).catch(async r=>{this.log.error("failed to reconnect to %p - %e",e,r);const n={};[...t.tags.keys()].forEach(e=>{e.startsWith(Ai)&&(n[e]=void 0)}),await this.peerStore.merge(e,{tags:n}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:e})}).catch(async t=>{this.log.error("failed to remove keep-alive tag from %p - %e",e,t)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[e=>Kb(e)]});await Promise.all(e.map(async e=>{await this.connectionManager.openConnection(e.id).catch(e=>{this.log.error(e)})}))}).catch(e=>{this.log.error(e)})}stop(){this.started=!1,this.queue.abort()}}function Kb(e){for(const t of e.tags.keys())if(t.startsWith(Ai))return!0;return!1}const Vb=50,Hb=100,jb=5,Gb=10;class Wb{started;connections;allow;deny;maxIncomingPendingConnections;incomingPendingConnections;outboundPendingConnections;maxConnections;dialQueue;reconnectQueue;connectionPruner;inboundConnectionRateLimiter;peerStore;metrics;events;log;peerId;constructor(e,t={}){if(this.maxConnections=t.maxConnections??Hb,this.maxConnections<1)throw new Pi("Connection Manager maxConnections must be greater than 0");this.connections=new Zg,this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.metrics=e.metrics,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(t.allow??[]).map(e=>cb(e)),this.deny=(t.deny??[]).map(e=>cb(e)),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=t.maxIncomingPendingConnections??Gb,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new Zp({points:t.inboundConnectionThreshold??jb,duration:1}),this.connectionPruner=new lb({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{allow:t.allow?.map(e=>Zl(e))}),this.dialQueue=new kb(e,{addressSorter:t.addressSorter,maxParallelDials:t.maxParallelDials??50,maxDialQueueLength:t.maxDialQueueLength??500,maxPeerAddrsToDial:t.maxPeerAddrsToDial??25,dialTimeout:t.dialTimeout??1e4,resolvers:t.resolvers??{dnsaddr:kg},connections:this.connections}),this.reconnectQueue=new zb({events:e.events,peerStore:e.peerStore,logger:e.logger,connectionManager:this},{retries:t.reconnectRetries,retryInterval:t.reconnectRetryInterval,backoffFactor:t.reconnectBackoffFactor,maxParallelReconnects:t.maxParallelReconnects})}[Symbol.toStringTag]="@libp2p/connection-manager";async start(){this.metrics?.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const e={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const t of this.connections.values())for(const r of t)e[r.direction]++;return e}}),this.metrics?.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const e={};for(const t of this.connections.values())for(const r of t)for(const t of r.streams){const r=`${t.direction} ${t.protocol??"unnegotiated"}`;e[r]=(e[r]??0)+1}return e}}),this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const e={};for(const t of this.connections.values())for(const r of t){const t={};for(const e of r.streams){const r=`${e.direction} ${e.protocol??"unnegotiated"}`;t[r]=(t[r]??0)+1}for(const[r,n]of Object.entries(t))e[r]=e[r]??[],e[r].push(n)}const t={};for(let[r,n]of Object.entries(e)){n=n.sort((e,t)=>e-t);const e=Math.floor(.9*n.length);t[r]=n[e]}return t}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await async function(...e){const t=[];for(const r of e)Ji(r)&&t.push(r);await Promise.all(t.map(async e=>{null!=e.beforeStart&&await e.beforeStart()})),await Promise.all(t.map(async e=>{await e.start()})),await Promise.all(t.map(async e=>{null!=e.afterStart&&await e.afterStart()}))}(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await async function(...e){const t=[];for(const r of e)Ji(r)&&t.push(r);await Promise.all(t.map(async e=>{null!=e.beforeStop&&await e.beforeStop()})),await Promise.all(t.map(async e=>{await e.stop()})),await Promise.all(t.map(async e=>{null!=e.afterStop&&await e.afterStop()}))}(this.reconnectQueue,this.dialQueue,this.connectionPruner);const e=[];for(const t of this.connections.values())for(const r of t)e.push((async()=>{try{await r.close()}catch(e){this.log.error(e)}})());this.log("closing %d connections",e.length),await Promise.all(e),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}setMaxConnections(e){if(this.maxConnections<1)throw new Pi("Connection Manager maxConnections must be greater than 0");let t=!1;e<this.maxConnections&&(t=!0),this.maxConnections=e,t&&this.connectionPruner.maybePruneConnections()}onConnect(e){this._onConnect(e).catch(e=>{this.log.error(e)})}async _onConnect(e){const{detail:t}=e;if(!this.started)return void await t.close();if("open"!==t.status)return;const r=t.remotePeer,n=!this.connections.has(r),s=this.connections.get(r)??[];s.push(t),this.connections.set(r,s),null!=r.publicKey&&"RSA"===r.type&&await this.peerStore.patch(r,{publicKey:r.publicKey}),n&&this.events.safeDispatchEvent("peer:connect",{detail:t.remotePeer})}onDisconnect(e){const{detail:t}=e,r=t.remotePeer,n=(this.connections.get(r)??[]).filter(e=>e.id!==t.id);this.connections.set(r,n),0===n.length&&(this.log("onDisconnect remove all connections for peer %p",r),this.connections.delete(r),this.events.safeDispatchEvent("peer:disconnect",{detail:t.remotePeer}))}getConnections(e){if(null!=e)return this.connections.get(e)??[];let t=[];for(const e of this.connections.values())t=t.concat(e);return t}getConnectionsMap(){return this.connections}async openConnection(e,t={}){if(!this.started)throw new ji("Not started");this.outboundPendingConnections++;try{t.signal?.throwIfAborted();const{peerId:r}=ob(e);if(this.peerId.equals(r))throw new Fi("Can not dial self");if(null!=r&&!0!==t.force){this.log("dial %p",r);const e=this.getConnections(r).find(e=>null==e.limits);if(null!=e)return this.log("had an existing non-limited connection to %p",r),t.onProgress?.(new Bf("dial-queue:already-connected")),e}const n=await this.dialQueue.dial(e,{...t,priority:t.priority??Vb});if("open"!==n.status)throw new Li("Remote closed connection during opening");let s=this.connections.get(n.remotePeer);null==s&&(s=[],this.connections.set(n.remotePeer,s));let i=!1;for(const e of s)if(e.id===n.id&&(i=!0),!0!==t.force&&e.id!==n.id&&e.remoteAddr.equals(n.remoteAddr))return n.abort(new Bi("Duplicate multiaddr connection")),e;return i||s.push(n),n}finally{this.outboundPendingConnections--}}async closeConnections(e,t={}){const r=this.connections.get(e)??[];await Promise.all(r.map(async e=>{try{await e.close(t)}catch(t){e.abort(t)}}))}async acceptIncomingConnection(e){if(this.deny.some(t=>t.contains(e.remoteAddr.nodeAddress().address)))return this.log("connection from %a refused - connection remote address was in deny list",e.remoteAddr),!1;if(this.allow.some(t=>t.contains(e.remoteAddr.nodeAddress().address)))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",e.remoteAddr),!1;if(e.remoteAddr.isThinWaistAddress()){const t=e.remoteAddr.nodeAddress().address;try{await this.inboundConnectionRateLimiter.consume(t,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",e.remoteAddr,t),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",e.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const e={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(t=>({id:t.id,status:e[t.status],peerId:t.options.peerId,multiaddrs:[...t.options.multiaddrs].map(e=>Zl(e))}))}async isDialable(e,t={}){return this.dialQueue.isDialable(e,t)}}class Xb{movingAverage;variance;deviation;forecast;timeSpan;previousTime;constructor(e){this.timeSpan=e,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(e,t){return 1-Math.exp(-(e-t)/this.timeSpan)}push(e,t=Date.now()){if(null!=this.previousTime){const r=this.alpha(t,this.previousTime),n=e-this.movingAverage,s=r*n;this.movingAverage=r*e+(1-r)*this.movingAverage,this.variance=(1-r)*(this.variance+n*s),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+r*n}else this.movingAverage=e;this.previousTime=t}}class Zb{success;failure;next;metric;timeoutMultiplier;failureMultiplier;minTimeout;maxTimeout;constructor(e={}){const t=e.interval??5e3;this.success=new Xb(t),this.failure=new Xb(t),this.next=new Xb(t),this.failureMultiplier=e.failureMultiplier??2,this.timeoutMultiplier=e.timeoutMultiplier??1.2,this.minTimeout=e.minTimeout??5e3,this.maxTimeout=e.maxTimeout??6e4,null!=e.metricName&&(this.metric=e.metrics?.registerMetricGroup(e.metricName))}getTimeoutSignal(e={}){let t=Math.round(this.next.movingAverage*(e.timeoutFactor??this.timeoutMultiplier));t<this.minTimeout&&(t=this.minTimeout),t>this.maxTimeout&&(t=this.maxTimeout);const r=AbortSignal.timeout(t),n=mb([e.signal,r]);return n.start=Date.now(),n.timeout=t,n}cleanUp(e){const t=Date.now()-e.start;e.aborted?(this.failure.push(t),this.next.push(t*this.failureMultiplier),this.metric?.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:t})):(this.success.push(t),this.next.push(t),this.metric?.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:t}))}}class Qb{protocol;components;log;heartbeatInterval;pingIntervalMs;abortController;timeout;abortConnectionOnPingFailure;constructor(e,t={}){this.components=e,this.protocol=`/${t.protocolPrefix??"ipfs"}/ping/1.0.0`,this.log=e.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=t.pingInterval??1e4,this.abortConnectionOnPingFailure=t.abortConnectionOnPingFailure??true,this.timeout=new Zb({...t.pingTimeout??{},metrics:e.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}[Symbol.toStringTag]="@libp2p/connection-monitor";[eo]=["@libp2p/connection-monitor"];start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(e=>{Promise.resolve().then(async()=>{let t=Date.now();try{const r=this.timeout.getTimeoutSignal({signal:this.abortController?.signal}),n=qu(await e.newStream(this.protocol,{signal:r,runOnLimitedConnection:!0}));t=Date.now(),await Promise.all([n.write(bc(32),{signal:r}),n.read({bytes:32,signal:r})]),e.rtt=Date.now()-t,await n.unwrap().close({signal:r})}catch(r){if("UnsupportedProtocolError"!==r.name)throw r;e.rtt=(Date.now()-t)/2}}).catch(t=>{this.log.error("error during heartbeat",t),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),e.abort(t)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){this.abortController?.abort(),null!=this.heartbeatInterval&&clearInterval(this.heartbeatInterval)}}class Yb{routers;started;components;constructor(e,t){this.routers=t.routers??[],this.started=!1,this.components=e,this.findProviders=e.metrics?.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs([e],t){return{...t,cid:e.toString()}},getAttributesFromYieldedValue(e,t){return{...t,providers:[...Array.isArray(t.providers)?t.providers:[],e.id.toString()]}}})??this.findProviders,this.provide=e.metrics?.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs([e],t){return{...t,cid:e.toString()}}})??this.provide,this.cancelReprovide=e.metrics?.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs([e],t){return{...t,cid:e.toString()}}})??this.cancelReprovide,this.put=e.metrics?.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs([e]){return{key:ln(e,"base36")}}})??this.put,this.get=e.metrics?.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs([e]){return{key:ln(e,"base36")}}})??this.get}[Symbol.toStringTag]="@libp2p/content-routing";isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(e,t={}){if(0===this.routers.length)throw new By("No content routers available");const r=this,n=new Qg;for await(const s of Is(...r.routers.filter(e=>e.findProviders instanceof Function).map(r=>r.findProviders(e,t))))null!=s&&(s.multiaddrs.length>0&&await this.components.peerStore.merge(s.id,{multiaddrs:s.multiaddrs},t),n.has(s.id)||(n.add(s.id),yield s))}async provide(e,t={}){if(0===this.routers.length)throw new By("No content routers available");await Promise.all(this.routers.filter(e=>e.provide instanceof Function).map(async r=>{await r.provide(e,t)}))}async cancelReprovide(e,t={}){if(0===this.routers.length)throw new By("No content routers available");await Promise.all(this.routers.filter(e=>e.cancelReprovide instanceof Function).map(async r=>{await r.cancelReprovide(e,t)}))}async put(e,t,r){if(!this.isStarted())throw new ji;await Promise.all(this.routers.filter(e=>e.put instanceof Function).map(async n=>{await n.put(e,t,r)}))}async get(e,t){if(!this.isStarted())throw new ji;return Promise.any(this.routers.filter(e=>e.get instanceof Function).map(async r=>r.get(e,t)))}}class Jb{log;peerId;peerStore;routers;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-routing"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.routers=t.routers??[],this.findPeer=e.metrics?.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs([e],t){return{...t,peer:e.toString()}}})??this.findPeer,this.getClosestPeers=e.metrics?.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs([e],t){return{...t,key:ln(e,"base36")}},getAttributesFromYieldedValue(e,t){return{...t,peers:[...Array.isArray(t.peers)?t.peers:[],e.id.toString()]}}})??this.getClosestPeers}[Symbol.toStringTag]="@libp2p/peer-routing";async findPeer(e,t){if(0===this.routers.length)throw new qy("No peer routers available");if(e.toString()===this.peerId.toString())throw new $y("Should not try to find self");const r=this,n=Is(...this.routers.filter(e=>e.findPeer instanceof Function).map(n=>async function*(){try{yield await n.findPeer(e,t)}catch(e){r.log.error(e)}}()));for await(const e of n)if(null!=e)return e.multiaddrs.length>0&&await this.peerStore.merge(e.id,{multiaddrs:e.multiaddrs},t),e;throw new Ui}async*getClosestPeers(e,t={}){if(0===this.routers.length)throw new qy("No peer routers available");const r=this,n=um(1024);for await(const s of async function*(e,t={}){let r=t.concurrency??1/0;r<1&&(r=1/0);const n=t.ordered??!1,s=new EventTarget,i=[];let o,a=ps(),c=ps(),l=!1,u=!1;function h(){return n?i[0]?.done:!!i.find(e=>e.done)}function*d(){for(;i.length>0&&i[0].done;){const e=i[0];if(i.shift(),!e.ok)throw u=!0,a.resolve(),e.err;yield e.value,a.resolve()}}function*p(){for(;h();)for(let e=0;e<i.length;e++)if(i[e].done){const t=i[e];if(i.splice(e,1),e--,!t.ok)throw u=!0,a.resolve(),t.err;yield t.value,a.resolve()}}for(s.addEventListener("task-complete",()=>{c.resolve()}),Promise.resolve().then(async()=>{try{for await(const t of e){if(i.length===r&&(a=ps(),await a.promise),u)break;const e={done:!1};i.push(e),t().then(t=>{e.done=!0,e.ok=!0,e.value=t,s.dispatchEvent(new zd("task-complete"))},t=>{e.done=!0,e.err=t,s.dispatchEvent(new zd("task-complete"))})}l=!0,s.dispatchEvent(new zd("task-complete"))}catch(e){o=e,s.dispatchEvent(new zd("task-complete"))}});;){if(h()||(c=ps(),await c.promise),null!=o)throw o;if(n?yield*d():yield*p(),null!=o)throw o;if(l&&0===i.length)break}}(async function*(){const n=Is(...r.routers.filter(e=>e.getClosestPeers instanceof Function).map(r=>r.getClosestPeers(e,t)));for await(let e of n)yield async()=>{if(0===e.multiaddrs.length)try{e=await r.findPeer(e.id,{...t,useCache:!1})}catch(e){return void r.log.error("could not find peer multiaddrs",e)}return e}}()))null!=s&&(s.multiaddrs.length>0&&await this.peerStore.merge(s.id,{multiaddrs:s.multiaddrs},t),n.has(s.id.toMultihash().bytes)||(n.add(s.id.toMultihash().bytes),yield s))}}class ew extends Yi{peerRouting;log;walking;walkers;shutdownController;walkController;needNext;constructor(e){super(),this.log=e.logger.forComponent("libp2p:random-walk"),this.peerRouting=e.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}[Symbol.toStringTag]="@libp2p/random-walk";start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(e){this.walking||this.startWalk(),this.walkers++;const t=mb([this.shutdownController.signal,e?.signal]);try{for(;;){this.needNext?.resolve(),this.needNext=ps();const e=await pm(this,"walk:peer",t,{errorEvent:"walk:error"});yield e.detail}}finally{t.clear(),this.walkers--,0===this.walkers&&(this.walkController?.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const e=mb([this.walkController.signal,this.shutdownController.signal]),t=Date.now();let r=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const t=bc(32);let n=Date.now();for await(const s of this.peerRouting.getClosestPeers(t,{signal:e}))e.aborted&&this.log("aborting walk"),e.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",s.id,Date.now()-n,this.walkers),r++,this.safeDispatchEvent("walk:peer",{detail:s}),1===this.walkers&&null!=this.needNext&&(this.log("wait for need next"),await ws(this.needNext.promise,e)),n=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",t,this.walkers,r)}catch(e){this.log.error("random walk errored",e),this.safeDispatchEvent("walk:error",{detail:e})}this.log("no walkers left, ended walk")}).catch(e=>{this.log.error("random walk errored",e)}).finally(()=>{this.log("finished walk, found %d peers after %dms",r,Date.now()-t),this.walking=!1})}}class tw{log;topologies;handlers;components;constructor(e){this.components=e,this.log=e.logger.forComponent("libp2p:registrar"),this.topologies=new Map,e.metrics?.registerMetricGroup("libp2p_registrar_topologies",{calculate:()=>{const e={};for(const[t,r]of this.topologies)e[t]=r.size;return e}}),this.handlers=Sy({name:"libp2p_registrar_protocol_handlers",metrics:e.metrics}),this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}[Symbol.toStringTag]="@libp2p/registrar";getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(null==t)throw new zy("No handler registered for protocol "+e);return t}getTopologies(e){const t=this.topologies.get(e);return null==t?[]:[...t.values()]}async handle(e,t,r){if(this.handlers.has(e)&&!0!==r?.force)throw new Ky("Handler already registered for protocol "+e);const n=tg.bind({ignoreUndefined:!0})({maxInboundStreams:32,maxOutboundStreams:64},r);this.handlers.set(e,{handler:t,options:n}),await this.components.peerStore.merge(this.components.peerId,{protocols:[e]},r)}async unhandle(e,t){(Array.isArray(e)?e:[e]).forEach(e=>{this.handlers.delete(e)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()},t)}async register(e,t){if(null==t)throw new Pi("invalid topology");const r=`${(1e9*Math.random()).toString(36)}${Date.now()}`;let n=this.topologies.get(e);return null==n&&(n=new Map,this.topologies.set(e,n)),n.set(r,t),r}unregister(e){for(const[t,r]of this.topologies.entries())r.has(e)&&(r.delete(e),0===r.size&&this.topologies.delete(t))}_onDisconnect(e){const t=e.detail,r={signal:AbortSignal.timeout(5e3)};this.components.peerStore.get(t,r).then(e=>{for(const r of e.protocols){const e=this.topologies.get(r);if(null!=e)for(const r of e.values())!1!==r.filter?.has(t)&&(r.filter?.remove(t),r.onDisconnect?.(t))}}).catch(e=>{"NotFoundError"!==e.name&&this.log.error("could not inform topologies of disconnecting peer %p",t,e)})}_onPeerUpdate(e){const{peer:t,previous:r}=e.detail,n=(r?.protocols??[]).filter(e=>!t.protocols.includes(e));for(const e of n){const r=this.topologies.get(e);if(null!=r)for(const e of r.values())!1!==e.filter?.has(t.id)&&(e.filter?.remove(t.id),e.onDisconnect?.(t.id))}}_onPeerIdentify(e){const t=e.detail.protocols,r=e.detail.connection,n=e.detail.peerId;for(const e of t){const t=this.topologies.get(e);if(null!=t)for(const e of t.values())null!=r.limits&&!0!==e.notifyOnLimitedConnection||!0!==e.filter?.has(n)&&(e.filter?.add(n),e.onConnect?.(n,r))}}}class rw{log;components;transports;listeners;faultTolerance;started;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:transports"),this.components=e,this.started=!1,this.transports=Sy({name:"libp2p_transport_manager_transports",metrics:this.components.metrics}),this.listeners=Sy({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=t.faultTolerance??Ci.FATAL_ALL}[Symbol.toStringTag]="@libp2p/transport-manager";add(e){const t=e[Symbol.toStringTag];if(null==t)throw new Pi("Transport must have a valid tag");if(this.transports.has(t))throw new Pi("There is already a transport with the tag "+t);this.log("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const e=this.components.addressManager.getListenAddrs();await this.listen(e)}async stop(){const e=[];for(const[t,r]of this.listeners)for(this.log("closing listeners for %s",t);r.length>0;){const t=r.pop();null!=t&&e.push(t.close())}await Promise.all(e),this.log("all listeners closed");for(const e of this.listeners.keys())this.listeners.set(e,[]);this.started=!1}async dial(e,t){const r=this.dialTransportForMultiaddr(e);if(null==r)throw new Yy("No transport available for address "+(e+""));return t?.onProgress?.(new Bf("transport-manager:selected-transport",r[Symbol.toStringTag])),r.dial(e,{...t,upgrader:this.components.upgrader})}getAddrs(){let e=[];for(const t of this.listeners.values())for(const r of t)e=[...e,...r.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(e){for(const t of this.transports.values()){if(t.dialFilter([e]).length>0)return t}}listenTransportForMultiaddr(e){for(const t of this.transports.values()){if(t.listenFilter([e]).length>0)return t}}async listen(e){if(!this.isStarted())throw new ji("Not started");if(null==e||0===e.length)return void this.log("no addresses were provided for listening, this node is dial only");const t={errors:new Map,ipv4:{success:0,attempts:0},ipv6:{success:0,attempts:0}};e.forEach(e=>{t.errors.set(e.toString(),new Hy)});const r=[];for(const[n,s]of this.transports.entries()){const i=s.listenFilter(e);for(const e of i){this.log("creating listener for %s on %a",n,e);const i=s.createListener({upgrader:this.components.upgrader});let o=this.listeners.get(n)??[];null==o&&(o=[],this.listeners.set(n,o)),o.push(i),i.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:i})}),i.addEventListener("close",()=>{const e=o.findIndex(e=>e===i);o.splice(e,1),this.components.events.safeDispatchEvent("transport:close",{detail:i})}),Ep.matches(e)?t.ipv4.attempts++:Sp.matches(e)&&t.ipv6.attempts++,r.push(i.listen(e).then(()=>{t.errors.delete(e.toString()),Ep.matches(e)&&t.ipv4.success++,Sp.matches(e)&&t.ipv6.success++},r=>{throw this.log.error("transport %s could not listen on address %a - %e",n,e,r),t.errors.set(e.toString(),r),r}))}}const n=await Promise.allSettled(r);if(!(n.length>0&&n.every(e=>"fulfilled"===e.status)))if(this.ipv6Unsupported(t))this.log("all IPv4 addresses succeed but all IPv6 failed");else{if(this.faultTolerance!==Ci.NO_FATAL)throw new jy("Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set `transportManager.faultTolerance` to NO_FATAL:\n"+[...t.errors.entries()].map(([e,t])=>`\n  ${e}: ${(""+(t.stack??t)).split("\n").join("\n  ")}\n`).join(""));this.log("failed to listen on any address but fault tolerance allows this")}}ipv6Unsupported(e){if(0===e.ipv4.attempts||0===e.ipv6.attempts)return!1;const t=e.ipv4.attempts===e.ipv4.success,r=0===e.ipv6.success;return t&&r}async remove(e){const t=this.listeners.get(e)??[];this.log.trace("removing transport %s",e);const r=[];for(this.log.trace("closing listeners for %s",e);t.length>0;){const e=t.pop();null!=e&&r.push(e.close())}await Promise.all(r),this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}const nw="/multistream/1.0.0",sw=1024,iw=rt("\n");async function ow(e,t,r){await e.write(t,r)}async function aw(e,t){const r=await async function(e,t){const r=await e.read(t);if(0===r.byteLength||r.get(r.byteLength-1)!==iw[0])throw t.log.error("Invalid mss message - missing newline",r),new Ki("Missing newline");return r.sublist(0,-1)}(e,t);return ln(r.subarray())}async function cw(e,t,r){if(1===(t=Array.isArray(t)?[...t]:[t]).length&&!1===r.negotiateFully)return function(e,t,r){const n=e.sink.bind(e),s=e.source;let i=!1,o=!1;const a=ps();let c=!1,l=!1;const u=ps();let d=!1,p=!1;const f=ps(),g=Vu({sink:n,source:s},{...r,maxDataLength:sw});async function m(){if(o)return r.log.trace("optimistic: already negotiating %s stream",t),void await a.promise;o=!0;try{c||(r.log.trace("optimistic: doing send protocol for %s stream",t),await y()),d||(r.log.trace("optimistic: doing read protocol for %s stream",t),await b())}finally{o=!1,i=!0,a.resolve()}}async function y(){if(l)await u.promise;else{l=!0;try{r.log.trace('optimistic: write ["%s", "%s", data] in source',nw,t),await g.writeV([rt(nw+"\n"),rt(t+"\n")]),r.log.trace('optimistic: wrote ["%s", "%s", data] in source',nw,t)}finally{c=!0,l=!1,u.resolve()}}}async function b(){if(p)await f.promise;else{p=!0;try{r.log.trace("optimistic: reading multistream select header");let e=await aw(g,r);if(r.log.trace('optimistic: read multistream select header "%s"',e),e===nw&&(e=await aw(g,r)),r.log.trace('optimistic: read protocol "%s", expecting "%s"',e,t),e!==t)throw new zi("protocol selection failed")}finally{d=!0,p=!1,f.resolve()}}}if(e.sink=async e=>{const{sink:n}=g.unwrap();await n(async function*(){let n=!1;for await(const s of e){if(l&&await u.promise,c)yield s;else{l=!0,r.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink',nw,t,s.byteLength);const e=t+"\n";yield new rs(Uint8Array.from([19]),rt(nw+"\n"),h(e.length),rt(e),s).subarray(),r.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink',nw,t,s.byteLength),c=!0,l=!1,u.resolve(),m().catch(e=>{r.log.error("could not finish optimistic protocol negotiation of %s",t,e)})}n=!0}n||await m()}())},e.source=async function*(){await m(),r.log.trace('optimistic: reading data from "%s" stream',t),yield*g.unwrap().source}(),null!=e.closeRead){const t=e.closeRead.bind(e);e.closeRead=async e=>{i||await m().catch(e=>{r.log.error("could not negotiate protocol before close read",e)}),await t(e)}}if(null!=e.closeWrite){const t=e.closeWrite.bind(e);e.closeWrite=async e=>{i||await m().catch(e=>{r.log.error("could not negotiate protocol before close write",e)}),await t(e)}}if(null!=e.close){const t=e.close.bind(e);e.close=async e=>{const r=[];l&&r.push(u.promise),p&&r.push(f.promise),r.length>0?await ws(Promise.all(r),e?.signal):(i=!0,o=!1,a.resolve()),await t(e)}}return{stream:e,protocol:t}}(e,t[0],r);const n=Vu(e,{...r,maxDataLength:sw}),s=t.shift();if(null==s)throw Error("At least one protocol must be specified");r.log.trace('select: write ["%s", "%s"]',nw,s);const i=rt(nw+"\n"),o=rt(s+"\n");await async function(e,t,r){await e.writeV(t,r)}(n,[i,o],r),r.log.trace("select: reading multistream-select header");let a=await aw(n,r);if(r.log.trace('select: read "%s"',a),a===nw&&(r.log.trace("select: reading protocol response"),a=await aw(n,r),r.log.trace('select: read "%s"',a)),a===s)return{stream:n.unwrap(),protocol:s};for(const e of t){r.log.trace('select: write "%s"',e),await ow(n,rt(e+"\n"),r),r.log.trace("select: reading protocol response");const t=await aw(n,r);if(r.log.trace('select: read "%s" for "%s"',t,e),t===e)return{stream:n.unwrap(),protocol:e}}throw new zi("protocol selection failed")}const lw=4194304;class uw extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"}function hw(e,t){if(e.byteLength>t)throw new uw("Message length too long")}const dw=e=>{const r=c(e),n=t(r);return h(e,n),dw.bytes=r,n};function pw(e,t){const r=(t=t??{}).lengthEncoder??dw,n=t?.maxDataLength??lw;function*s(e){hw(e,n);const t=r(e.byteLength);t instanceof Uint8Array?yield t:yield*t,e instanceof Uint8Array?yield e:yield*e}return null!=e[Symbol.asyncIterator]?async function*(){for await(const t of e)yield*s(t)}():function*(){for(const t of e)yield*s(t)}()}var fw;async function gw(e,t,r){t=Array.isArray(t)?t:[t],r.log.trace("handle: available protocols %s",t);const n=Vu(e,{...r,maxDataLength:sw,maxLengthLength:2});for(;;){r.log.trace("handle: reading incoming string");const e=await aw(n,r);if(r.log.trace('handle: read "%s"',e),e!==nw){if(t.includes(e))return r.log.trace('handle: respond with "%s" for "%s"',e,e),await ow(n,rt(e+"\n"),r),r.log.trace('handle: responded with "%s" for "%s"',e,e),{stream:n.unwrap(),protocol:e};if("ls"===e){const s=new rs(...t.map(e=>pw.single(rt(e+"\n"))),rt("\n"));r.log.trace('handle: respond with "%s" for %s',t,e),await ow(n,s,r),r.log.trace('handle: responded with "%s" for %s',t,e);continue}r.log.trace('handle: respond with "na" for "%s"',e),await ow(n,rt("na\n"),r),r.log('handle: responded with "na" for "%s"',e)}else r.log.trace('handle: respond with "%s" for "%s"',nw,e),await ow(n,rt(nw+"\n"),r),r.log.trace('handle: responded with "%s" for "%s"',nw,e)}}dw.bytes=0,pw.single=(e,t)=>{const r=(t=t??{}).lengthEncoder??dw;return hw(e,t?.maxDataLength??lw),new rs(r(e.byteLength),e)},(e=>{e[e.LENGTH=0]="LENGTH",e[e.DATA=1]="DATA"})(fw||(fw={}));class mw{id;remoteAddr;remotePeer;direction;timeline;multiplexer;encryption;status;limits;log;tags;_newStream;_close;_abort;_getStreams;constructor(e){const{remoteAddr:t,remotePeer:r,newStream:n,close:s,abort:i,getStreams:o}=e;this.id=`${parseInt(1e9*Math.random()+"").toString(36)}${Date.now()}`,this.remoteAddr=t,this.remotePeer=r,this.direction=e.direction,this.status="open",this.timeline=e.timeline,this.multiplexer=e.multiplexer,this.encryption=e.encryption,this.limits=e.limits,this.log=e.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`),null==this.remoteAddr.getPeerId()&&(this.remoteAddr=this.remoteAddr.encapsulate("/p2p/"+this.remotePeer)),this._newStream=n,this._close=s,this._abort=i,this._getStreams=o,this.tags=[]}[Symbol.toStringTag]="Connection";[yi]=!0;get streams(){return this._getStreams()}async newStream(e,t){if("closing"===this.status)throw new Ri("the connection is being closed");if("closed"===this.status)throw new Li("the connection is closed");if(Array.isArray(e)||(e=[e]),null!=this.limits&&!0!==t?.runOnLimitedConnection)throw new Wi("Cannot open protocol stream on limited connection");const r=await this._newStream(e,t);return r.direction="outbound",r}async close(e={}){if("closed"!==this.status&&"closing"!==this.status){if(this.log("closing connection to %a",this.remoteAddr),this.status="closing",null==e.signal){const t=AbortSignal.timeout(500);e={...e,signal:t}}try{this.log.trace("closing underlying transport"),await this._close(e),this.log.trace("updating timeline with close time"),this.status="closed",this.timeline.close=Date.now()}catch(e){this.log.error("error encountered during graceful close of connection to %a",this.remoteAddr,e),this.abort(e)}}}abort(e){"closed"!==this.status&&(this.log.error("aborting connection to %a due to error",this.remoteAddr,e),this.status="closing",this._abort(e),this.status="closed",this.timeline.close=Date.now())}}function yw(e,t,r){let n=0;return r.streams.forEach(r=>{r.direction===t&&r.protocol===e&&n++}),n}class bw{components;connectionEncrypters;streamMuxers;inboundUpgradeTimeout;inboundStreamProtocolNegotiationTimeout;outboundStreamProtocolNegotiationTimeout;events;metrics;constructor(e,t){this.components=e,this.connectionEncrypters=Sy({name:"libp2p_upgrader_connection_encrypters",metrics:this.components.metrics}),t.connectionEncrypters.forEach(e=>{this.connectionEncrypters.set(e.protocol,e)}),this.streamMuxers=Sy({name:"libp2p_upgrader_stream_multiplexers",metrics:this.components.metrics}),t.streamMuxers.forEach(e=>{this.streamMuxers.set(e.protocol,e)}),this.inboundUpgradeTimeout=t.inboundUpgradeTimeout??1e4,this.inboundStreamProtocolNegotiationTimeout=t.inboundStreamProtocolNegotiationTimeout??1e4,this.outboundStreamProtocolNegotiationTimeout=t.outboundStreamProtocolNegotiationTimeout??1e4,this.events=e.events,this.metrics={dials:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),inboundErrors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),outboundErrors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")}}[Symbol.toStringTag]="@libp2p/upgrader";async shouldBlockConnection(e,...t){const r=this.components.connectionGater[e];if(null==r)return;if(!0===await r.apply(this.components.connectionGater,t))throw new Wy("The multiaddr connection is blocked by gater."+e)}createInboundAbortSignal(e){return mb([AbortSignal.timeout(this.inboundUpgradeTimeout),e])}async upgradeInbound(e,t){let r=!1;const n=this.createInboundAbortSignal(t.signal);try{if(this.metrics.dials?.increment({inbound:!0}),r=await ws(this.components.connectionManager.acceptIncomingConnection(e),n),!r)throw new Xy("Connection denied");await ws(this.shouldBlockConnection("denyInboundConnection",e),n),await this._performUpgrade(e,"inbound",{...t,signal:n})}catch(e){throw this.metrics.errors?.increment({inbound:!0}),this.metrics.inboundErrors?.increment({[e.name??"Error"]:!0}),e}finally{n.clear(),r&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(e,t){try{this.metrics.dials?.increment({outbound:!0});const r=e.remoteAddr.getPeerId();let n;null!=r&&(n=nl(r),await ws(this.shouldBlockConnection("denyOutboundConnection",n,e),t.signal));let s="outbound";return!1===t.initiator&&(s="inbound"),await this._performUpgrade(e,s,t)}catch(e){throw this.metrics.errors?.increment({outbound:!0}),this.metrics.outboundErrors?.increment({[e.name??"Error"]:!0}),e}}async _performUpgrade(e,t,r){let n,s,i,o,a;this.components.metrics?.trackMultiaddrConnection(e),e.log.trace("starting the %s connection upgrade",t);let c=e;if(!0!==r?.skipProtection){const n=this.components.connectionProtector;null!=n&&(e.log("protecting the %s connection",t),c=await n.protect(e,r))}try{if(n=c,!0!==r?.skipEncryption){r?.onProgress?.(new Bf(`upgrader:encrypt-${t}-connection`)),({conn:n,remotePeer:s,protocol:a,streamMuxer:o}=await("inbound"===t?this._encryptInbound(c,r):this._encryptOutbound(c,r)));const e={...c,...n};await this.shouldBlockConnection("inbound"===t?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",s,e)}else{const r=e.remoteAddr.getPeerId();if(null==r)throw new Bi(t+" connection that skipped encryption must have a peer id");const n=nl(r);a="native",s=n}if(s.equals(this.components.peerId)){const t=new Fi("Can not dial self");throw e.abort(t),t}if(i=n,null!=r?.muxerFactory)o=r.muxerFactory;else if(null==o&&this.streamMuxers.size>0){r?.onProgress?.(new Bf(`upgrader:multiplex-${t}-connection`));const e=await("inbound"===t?this._multiplexInbound({...c,...n},this.streamMuxers,r):this._multiplexOutbound({...c,...n},this.streamMuxers,r));o=e.muxerFactory,i=e.stream}}catch(r){throw e.log.error("failed to upgrade inbound connection %s %a - %e","inbound"===t?"from":"to",e.remoteAddr,r),r}return await this.shouldBlockConnection("inbound"===t?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",s,e),e.log("successfully upgraded %s connection",t),this._createConnection({cryptoProtocol:a,direction:t,maConn:e,upgradedConn:i,muxerFactory:o,remotePeer:s,limits:r?.limits})}_createConnection(e){const{cryptoProtocol:t,direction:r,maConn:n,upgradedConn:s,remotePeer:i,muxerFactory:o,limits:a}=e;let c,l,u;null!=o&&(c=o.createStreamMuxer({direction:r,onIncomingStream:e=>{if(null==u)return;const t=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);Promise.resolve().then(async()=>{const r=this.components.registrar.getProtocols(),{stream:n,protocol:s}=await gw(e,r,{signal:t,log:e.log,yieldBytes:!1});if(null==u)return;u.log("incoming stream opened on %s",s);const o=function(e,t){try{const{options:r}=t.getHandler(e);return r.maxInboundStreams}catch(e){if("UnhandledProtocolError"!==e.name)throw e}return 32}(s,this.components.registrar);if(yw(s,"inbound",u)===o){const t=new Xi(`Too many inbound protocol streams for protocol "${s}" - limit ${o}`);throw e.abort(t),t}e.source=n.source,e.sink=n.sink,e.protocol=s,null!=n.closeWrite&&(e.closeWrite=n.closeWrite),null!=n.closeRead&&(e.closeRead=n.closeRead),null!=n.close&&(e.close=n.close),await this.components.peerStore.merge(i,{protocols:[s]},{signal:t}),this.components.metrics?.trackProtocolStream(e,u),this._onStream({connection:u,stream:e,protocol:s})}).catch(async r=>{u.log.error("error handling incoming stream id %s - %e",e.id,r),null==e.timeline.close&&await e.close({signal:t}).catch(t=>e.abort(t))})}}),l=async(t,n={})=>{if(null==c)throw new Zy("Connection is not multiplexed");u.log.trace("starting new stream for protocols %s",t);const s=await c.newStream();u.log.trace("started new stream %s for protocols %s",s.id,t);try{if(null==n.signal){s.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",t);const e=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);n={...n,signal:e}}s.log.trace("selecting protocol from protocols %s",t);const{stream:e,protocol:r}=await cw(s,t,{...n,log:s.log,yieldBytes:!0});s.log.trace("selected protocol %s",r);const o=function(e,t,r={}){try{const{options:r}=t.getHandler(e);if(null!=r.maxOutboundStreams)return r.maxOutboundStreams}catch(e){if("UnhandledProtocolError"!==e.name)throw e}return r.maxOutboundStreams??64}(r,this.components.registrar,n),a=yw(r,"outbound",u);if(a>=o){const e=new Zi(`Too many outbound protocol streams for protocol "${r}" - ${a}/${o}`);throw s.abort(e),e}return await this.components.peerStore.merge(i,{protocols:[r]}),s.source=e.source,s.sink=e.sink,s.protocol=r,null!=e.closeWrite&&(s.closeWrite=e.closeWrite),null!=e.closeRead&&(s.closeRead=e.closeRead),null!=e.close&&(s.close=e.close),this.components.metrics?.trackProtocolStream(s,u),s}catch(n){throw u.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e","inbound"===r?"from":"to",e.maConn.remoteAddr,t,n),null==s.timeline.close&&s.abort(n),n}},Promise.all([c.sink(s.source),s.sink(c.source)]).catch(e=>{u.log.error("error piping data through muxer - %e",e)}));const h=n.timeline;n.timeline=new Proxy(h,{set:(...e)=>("close"===e[1]&&null!=e[2]&&null==h.close&&(async()=>{try{"open"===u.status&&await u.close()}catch(e){u.log.error("error closing connection after timeline close %e",e)}finally{this.events.safeDispatchEvent("connection:close",{detail:u})}})().catch(e=>{u.log.error("error thrown while dispatching connection:close event %e",e)}),Reflect.set(...e))}),n.timeline.upgraded=Date.now();var d;return d={remoteAddr:n.remoteAddr,remotePeer:i,status:"open",direction:r,timeline:n.timeline,multiplexer:c?.protocol,encryption:t,limits:a,logger:this.components.logger,newStream:l??(()=>{throw new Zy("Connection is not multiplexed")}),getStreams:()=>c?.streams??[],async close(e){await(c?.close(e)),await n.close(e)},abort(e){n.abort(e),c?.abort(e)}},u=new mw(d),this.events.safeDispatchEvent("connection:open",{detail:u}),u.__maConnTimeline=h,u}_onStream(e){const{connection:t,stream:r,protocol:n}=e,{handler:s,options:i}=this.components.registrar.getHandler(n);if(null!=t.limits&&!0!==i.runOnLimitedConnection)throw new Wi("Cannot open protocol stream on limited connection");s({connection:t,stream:r})}async _encryptInbound(e,t){const r=Array.from(this.connectionEncrypters.keys());try{const{stream:n,protocol:s}=await gw(e,r,{...t,log:e.log}),i=this.connectionEncrypters.get(s);if(null==i)throw new Qy("no crypto module found for "+s);return e.log("encrypting inbound connection to %a using %s",e.remoteAddr,s),{...await i.secureInbound(n,t),protocol:s}}catch(t){throw e.log.error("encrypting inbound connection from %a failed",e.remoteAddr,t),new Qy(t.message)}}async _encryptOutbound(e,t){const r=Array.from(this.connectionEncrypters.keys());try{e.log.trace("selecting encrypter from %s",r);const{stream:n,protocol:s}=await cw(e,r,{...t,log:e.log,yieldBytes:!0}),i=this.connectionEncrypters.get(s);if(null==i)throw new Qy("no crypto module found for "+s);return e.log("encrypting outbound connection to %a using %s",e.remoteAddr,s),{...await i.secureOutbound(n,t),protocol:s}}catch(t){throw e.log.error("encrypting outbound connection to %a failed",e.remoteAddr,t),new Qy(t.message)}}async _multiplexOutbound(e,t,r){const n=Array.from(t.keys());e.log("outbound selecting muxer %s",n);try{e.log.trace("selecting stream muxer from %s",n);const{stream:s,protocol:i}=await cw(e,n,{...r,log:e.log,yieldBytes:!0});e.log("selected %s as muxer protocol",i);return{stream:s,muxerFactory:t.get(i)}}catch(t){throw e.log.error("error multiplexing outbound connection",t),new Zy(t+"")}}async _multiplexInbound(e,t,r){const n=Array.from(t.keys());e.log("inbound handling muxers %s",n);try{const{stream:s,protocol:i}=await gw(e,n,{...r,log:e.log});return{stream:s,muxerFactory:t.get(i)}}catch(t){throw e.log.error("error multiplexing inbound connection",t),new Zy(t+"")}}getConnectionEncrypters(){return this.connectionEncrypters}getStreamMuxers(){return this.streamMuxers}}const ww="2.8.11",vw="js-libp2p";function Ew(e,t){return`${e??vw}/${t??ww} browser/${globalThis.navigator.userAgent}`}class Sw extends Yi{peerId;peerStore;contentRouting;peerRouting;metrics;services;logger;status;components;log;constructor(e){super(),this.status="stopped";const t=new Yi,r=t.dispatchEvent.bind(t);t.dispatchEvent=e=>{const t=r(e),n=this.dispatchEvent(new CustomEvent(e.type,{detail:e.detail}));return t||n},this.peerId=e.peerId,this.logger=e.logger??Hg(),this.log=this.logger.forComponent("libp2p"),this.services={};const n=e.nodeInfo?.name??vw,s=e.nodeInfo?.version??ww,i=this.components=function(e={}){const t=new Jy(e);return new Proxy(t,{get(e,r,n){if("string"==typeof r&&!tb.includes(r)){const e=t.components[r];if(null==e&&!eb.includes(r))throw new Uy(r+" not set");return e}return Reflect.get(e,r,n)},set(e,r,n){return"string"==typeof r?t.components[r]=n:Reflect.set(e,r,n),!0}})}({peerId:e.peerId,privateKey:e.privateKey,nodeInfo:{name:n,version:s,userAgent:e.nodeInfo?.userAgent??Ew(n,s)},logger:this.logger,events:t,datastore:e.datastore??new vy,connectionGater:ib(e.connectionGater),dns:e.dns});null!=e.metrics&&(this.metrics=this.configureComponent("metrics",e.metrics(this.components))),this.peerStore=this.configureComponent("peerStore",function(e,t={}){return new fy(e,t)}(i,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...e.peerStore})),i.events.addEventListener("peer:update",e=>{if(null==e.detail.previous){const t={id:e.detail.peer.id,multiaddrs:e.detail.peer.addresses.map(e=>e.multiaddr)};i.events.safeDispatchEvent("peer:discovery",{detail:t})}}),null!=e.connectionProtector&&this.configureComponent("connectionProtector",e.connectionProtector(i)),this.components.upgrader=new bw(this.components,{connectionEncrypters:(e.connectionEncrypters??[]).map((e,t)=>this.configureComponent("connection-encryption-"+t,e(this.components))),streamMuxers:(e.streamMuxers??[]).map((e,t)=>this.configureComponent("stream-muxers-"+t,e(this.components))),inboundUpgradeTimeout:e.connectionManager?.inboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:e.connectionManager?.inboundStreamProtocolNegotiationTimeout??e.connectionManager?.protocolNegotiationTimeout,outboundStreamProtocolNegotiationTimeout:e.connectionManager?.outboundStreamProtocolNegotiationTimeout??e.connectionManager?.protocolNegotiationTimeout}),this.configureComponent("transportManager",new rw(this.components,e.transportManager)),this.configureComponent("connectionManager",new Wb(this.components,e.connectionManager)),!1!==e.connectionMonitor?.enabled&&this.configureComponent("connectionMonitor",new Qb(this.components,e.connectionMonitor)),this.configureComponent("registrar",new tw(this.components)),this.configureComponent("addressManager",new Ny(this.components,e.addresses));const o=(e.peerRouters??[]).map((e,t)=>this.configureComponent("peer-router-"+t,e(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new Jb(this.components,{routers:o}));const a=(e.contentRouters??[]).map((e,t)=>this.configureComponent("content-router-"+t,e(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new Yb(this.components,{routers:a})),this.configureComponent("randomWalk",new ew(this.components)),(e.peerDiscovery??[]).forEach((e,t)=>{this.configureComponent("peer-discovery-"+t,e(this.components)).addEventListener("peer",e=>{this.#M(e)})}),e.transports?.forEach((e,t)=>{this.components.transportManager.add(this.configureComponent("transport-"+t,e(this.components)))}),null!=e.services)for(const t of Object.keys(e.services)){const r=(0,e.services[t])(this.components);null!=r?(this.services[t]=r,this.configureComponent(t,r),null!=r[bi]&&(this.log("registering service %s for content routing",t),a.push(r[bi])),null!=r[Si]&&(this.log("registering service %s for peer routing",t),o.push(r[Si])),null!=r[wi]&&(this.log("registering service %s for peer discovery",t),r[wi].addEventListener?.("peer",e=>{this.#M(e)}))):this.log.error("service factory %s returned null or undefined instance",t)}!function(e){const t={};for(const r of Object.values(e.components))for(const e of rb(r))t[e]=!0;for(const r of Object.values(e.components))for(const e of nb(r))if(!0!==t[e])throw new Fy(`Service "${sb(r)}" required capability "${e}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}(i)}configureComponent(e,t){return null==t&&this.log.error("component %s was null or undefined",e),this.components[e]=t,t}async start(){if("stopped"===this.status){this.status="starting",this.log("libp2p is starting");try{await(this.components.beforeStart?.()),await this.components.start(),await(this.components.afterStart?.()),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started")}catch(e){throw this.log.error("An error occurred starting libp2p",e),this.status="started",await this.stop(),e}}}async stop(){"started"===this.status&&(this.log("libp2p is stopping"),this.status="stopping",await(this.components.beforeStop?.()),await this.components.stop(),await(this.components.afterStop?.()),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(e){return this.components.connectionManager.getConnections(e)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const e=new Qg;for(const t of this.components.connectionManager.getConnections())e.add(t.remotePeer);return Array.from(e)}async dial(e,t={}){return this.components.connectionManager.openConnection(e,{priority:75,...t})}async dialProtocol(e,t,r={}){if(null==t)throw new Pi("no protocols were provided to open a stream");if(0===(t=Array.isArray(t)?t:[t]).length)throw new Pi("no protocols were provided to open a stream");return(await this.dial(e,r)).newStream(t,r)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(e,t={}){Xl(e)&&(e=nl(e.getPeerId()??"")),await this.components.connectionManager.closeConnections(e,t)}async getPublicKey(e,t={}){if(this.log("getPublicKey %p",e),null!=e.publicKey)return e.publicKey;try{const r=await this.peerStore.get(e,t);if(null!=r.id.publicKey)return r.id.publicKey}catch(e){if("NotFoundError"!==e.name)throw e}const r=Qn([rt("/pk/"),e.toMultihash().bytes]),n=Xc(await this.contentRouting.get(r,t));return await this.peerStore.patch(e,{publicKey:n},t),n}async handle(e,t,r){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async e=>{await this.components.registrar.handle(e,t,r)}))}async unhandle(e,t){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async e=>{await this.components.registrar.unhandle(e,t)}))}async register(e,t,r){return this.components.registrar.register(e,t,r)}unregister(e){this.components.registrar.unregister(e)}async isDialable(e,t={}){return this.components.connectionManager.isDialable(e,t)}#M(e){const{detail:t}=e;t.id.toString()!==this.peerId.toString()?this.components.peerStore.merge(t.id,{multiaddrs:t.multiaddrs}).catch(e=>{this.log.error(e)}):this.log.error("peer discovery mechanism discovered self")}}function Aw(){try{return!1}catch(e){return!1}}const Iw="enrtree://AIRVQ5DDA4FFWLRBCHJWUWOO6X6S4ZTZ5B667LQ6AJU6PEYDLRD5O@sandbox.waku.nodes.status.im",Cw="enrtree://AOGYWMBYOUIMOENHXCHILPKY3ZRFEULMFI4DOM442QSZ73TT2A7VI@test.waku.nodes.status.im",xw=jn.BOOTSTRAP,kw="Invalid record id";var Tw=Object.freeze({__proto__:null,default:{}});const Pw=BigInt(0),_w=BigInt(1),Rw=BigInt(2),Lw=BigInt(3),Dw=BigInt(8),Mw=Object.freeze({a:Pw,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:_w,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")}),Nw=(e,t)=>(e+t/Rw)/t,Ow={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(e){const{n:t}=Mw,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-_w*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=r,o=BigInt("0x100000000000000000000000000000000"),a=Nw(i*e,t),c=Nw(-n*e,t);let l=dv(e-a*r-c*s,t),u=dv(-a*n-c*i,t);const h=l>o,d=u>o;if(h&&(l=t-l),d&&(u=t-u),l>o||u>o)throw Error("splitScalarEndo: Endomorphism failed, k="+e);return{k1neg:h,k1:l,k2neg:d,k2:u}}},Uw=32,Fw=32;function Bw(e){const{a:t,b:r}=Mw,n=dv(e*e),s=dv(n*e);return dv(s+t*e+r)}const qw=Mw.a===Pw;class $w extends Error{constructor(e){super(e)}}function zw(e){if(!(e instanceof Kw))throw new TypeError("JacobianPoint expected")}class Kw{constructor(e,t,r){this.x=e,this.y=t,this.z=r}static fromAffine(e){if(!(e instanceof jw))throw new TypeError("JacobianPoint#fromAffine: expected Point");return e.equals(jw.ZERO)?Kw.ZERO:new Kw(e.x,e.y,_w)}static toAffineBatch(e){const t=function(e,t=Mw.P){const r=Array(e.length),n=e.reduce((e,n,s)=>n===Pw?e:(r[s]=e,dv(e*n,t)),_w),s=fv(n,t);return e.reduceRight((e,n,s)=>n===Pw?e:(r[s]=dv(e*r[s],t),dv(e*n,t)),s),r}(e.map(e=>e.z));return e.map((e,r)=>e.toAffine(t[r]))}static normalizeZ(e){return Kw.toAffineBatch(e).map(Kw.fromAffine)}equals(e){zw(e);const{x:t,y:r,z:n}=this,{x:s,y:i,z:o}=e,a=dv(n*n),c=dv(o*o),l=dv(t*c),u=dv(s*a),h=dv(dv(r*o)*c),d=dv(dv(i*n)*a);return l===u&&h===d}negate(){return new Kw(this.x,dv(-this.y),this.z)}double(){const{x:e,y:t,z:r}=this,n=dv(e*e),s=dv(t*t),i=dv(s*s),o=e+s,a=dv(Rw*(dv(o*o)-n-i)),c=dv(Lw*n),l=dv(c*c),u=dv(l-Rw*a),h=dv(c*(a-u)-Dw*i),d=dv(Rw*t*r);return new Kw(u,h,d)}add(e){zw(e);const{x:t,y:r,z:n}=this,{x:s,y:i,z:o}=e;if(s===Pw||i===Pw)return this;if(t===Pw||r===Pw)return e;const a=dv(n*n),c=dv(o*o),l=dv(t*c),u=dv(s*a),h=dv(dv(r*o)*c),d=dv(dv(i*n)*a),p=dv(u-l),f=dv(d-h);if(p===Pw)return f===Pw?this.double():Kw.ZERO;const g=dv(p*p),m=dv(p*g),y=dv(l*g),b=dv(f*f-m-Rw*y),w=dv(f*(y-b)-h*m),v=dv(n*o*p);return new Kw(b,w,v)}subtract(e){return this.add(e.negate())}multiplyUnsafe(e){const t=Kw.ZERO;if("bigint"==typeof e&&e===Pw)return t;let r=hv(e);if(r===_w)return this;if(!qw){let e=t,n=this;for(;r>Pw;)r&_w&&(e=e.add(n)),n=n.double(),r>>=_w;return e}let{k1neg:n,k1:s,k2neg:i,k2:o}=Ow.splitScalar(r),a=t,c=t,l=this;for(;s>Pw||o>Pw;)s&_w&&(a=a.add(l)),o&_w&&(c=c.add(l)),l=l.double(),s>>=_w,o>>=_w;return n&&(a=a.negate()),i&&(c=c.negate()),c=new Kw(dv(c.x*Ow.beta),c.y,c.z),a.add(c)}precomputeWindow(e){const t=qw?128/e+1:256/e+1,r=[];let n=this,s=n;for(let i=0;i<t;i++){s=n,r.push(s);for(let t=1;t<2**(e-1);t++)s=s.add(n),r.push(s);n=s.double()}return r}wNAF(e,t){!t&&this.equals(Kw.BASE)&&(t=jw.BASE);const r=t&&t._WINDOW_SIZE||1;if(256%r)throw Error("Point#wNAF: Invalid precomputation window, must be power of 2");let n=t&&Hw.get(t);n||(n=this.precomputeWindow(r),t&&1!==r&&(n=Kw.normalizeZ(n),Hw.set(t,n)));let s=Kw.ZERO,i=Kw.BASE;const o=1+(qw?128/r:256/r),a=2**(r-1),c=BigInt(2**r-1),l=2**r,u=BigInt(r);for(let t=0;t<o;t++){const r=t*a;let o=Number(e&c);e>>=u,o>a&&(o-=l,e+=_w);const h=r,d=r+Math.abs(o)-1,p=t%2!=0,f=o<0;0===o?i=i.add(Vw(p,n[h])):s=s.add(Vw(f,n[d]))}return{p:s,f:i}}multiply(e,t){let r,n,s=hv(e);if(qw){const{k1neg:e,k1:i,k2neg:o,k2:a}=Ow.splitScalar(s);let{p:c,f:l}=this.wNAF(i,t),{p:u,f:h}=this.wNAF(a,t);c=Vw(e,c),u=Vw(o,u),u=new Kw(dv(u.x*Ow.beta),u.y,u.z),r=c.add(u),n=l.add(h)}else{const{p:e,f:i}=this.wNAF(s,t);r=e,n=i}return Kw.normalizeZ([r,n])[0]}toAffine(e){const{x:t,y:r,z:n}=this,s=this.equals(Kw.ZERO);null==e&&(e=s?Dw:fv(n));const i=e,o=dv(i*i),a=dv(o*i),c=dv(t*o),l=dv(r*a),u=dv(n*i);if(s)return jw.ZERO;if(u!==_w)throw Error("invZ was invalid");return new jw(c,l)}}function Vw(e,t){const r=t.negate();return e?r:t}Kw.BASE=new Kw(Mw.Gx,Mw.Gy,_w),Kw.ZERO=new Kw(Pw,_w,Pw);const Hw=new WeakMap;class jw{constructor(e,t){this.x=e,this.y=t}_setWindowSize(e){this._WINDOW_SIZE=e,Hw.delete(this)}hasEvenY(){return this.y%Rw===Pw}static fromCompressedHex(e){const t=32===e.length,r=lv(t?e:e.subarray(1));if(!vv(r))throw Error("Point is not on curve");let n=function(e){const{P:t}=Mw,r=BigInt(6),n=BigInt(11),s=BigInt(22),i=BigInt(23),o=BigInt(44),a=BigInt(88),c=e*e*e%t,l=c*c*e%t,u=pv(l,Lw)*l%t,h=pv(u,Lw)*l%t,d=pv(h,Rw)*c%t,p=pv(d,n)*d%t,f=pv(p,s)*p%t,g=pv(f,o)*f%t,m=pv(g,a)*g%t,y=pv(m,o)*f%t,b=pv(y,Lw)*l%t,w=pv(b,i)*p%t,v=pv(w,r)*c%t,E=pv(v,Rw);if(E*E%t!==e)throw Error("Cannot find square root");return E}(Bw(r));const s=(n&_w)===_w;if(t)s&&(n=dv(-n));else{!(1&~e[0])!==s&&(n=dv(-n))}const i=new jw(r,n);return i.assertValidity(),i}static fromUncompressedHex(e){const t=lv(e.subarray(1,33)),r=lv(e.subarray(33,65)),n=new jw(t,r);return n.assertValidity(),n}static fromHex(e){const t=uv(e),r=t.length,n=t[0];if(r===Uw)return this.fromCompressedHex(t);if(33===r&&(2===n||3===n))return this.fromCompressedHex(t);if(65===r&&4===n)return this.fromUncompressedHex(t);throw Error("Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not "+r)}static fromPrivateKey(e){return jw.BASE.multiply(Sv(e))}static fromSignature(e,t,r){const{r:n,s}=Av(t);if(![0,1,2,3].includes(r))throw Error("Cannot recover: invalid recovery bit");const i=gv(uv(e)),{n:o}=Mw,a=2===r||3===r?n+o:n,c=fv(a,o),l=dv(-i*c,o),u=dv(s*c,o),h=1&r?"03":"02",d=jw.fromHex(h+iv(a)),p=jw.BASE.multiplyAndAddUnsafe(d,l,u);if(!p)throw Error("Cannot recover signature: point at infinify");return p.assertValidity(),p}toRawBytes(e=!1){return nv(this.toHex(e))}toHex(e=!1){const t=iv(this.x);if(e){return`${this.hasEvenY()?"02":"03"}${t}`}return`04${t}${iv(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const e="Point is not on elliptic curve",{x:t,y:r}=this;if(!vv(t)||!vv(r))throw Error(e);const n=dv(r*r);if(dv(n-Bw(t))!==Pw)throw Error(e)}equals(e){return this.x===e.x&&this.y===e.y}negate(){return new jw(this.x,dv(-this.y))}double(){return Kw.fromAffine(this).double().toAffine()}add(e){return Kw.fromAffine(this).add(Kw.fromAffine(e)).toAffine()}subtract(e){return this.add(e.negate())}multiply(e){return Kw.fromAffine(this).multiply(e,this).toAffine()}multiplyAndAddUnsafe(e,t,r){const n=Kw.fromAffine(this),s=t===Pw||t===_w||this!==jw.BASE?n.multiplyUnsafe(t):n.multiply(t),i=Kw.fromAffine(e).multiplyUnsafe(r),o=s.add(i);return o.equals(Kw.ZERO)?void 0:o.toAffine()}}function Gw(e){return Number.parseInt(e[0],16)>=8?"00"+e:e}function Ww(e){if(e.length<2||2!==e[0])throw Error("Invalid signature integer tag: "+ev(e));const t=e[1],r=e.subarray(2,t+2);if(!t||r.length!==t)throw Error("Invalid signature integer: wrong length");if(0===r[0]&&r[1]<=127)throw Error("Invalid signature integer: trailing length");return{data:lv(r),left:e.subarray(t+2)}}jw.BASE=new jw(Mw.Gx,Mw.Gy),jw.ZERO=new jw(Pw,Pw);class Xw{constructor(e,t){this.r=e,this.s=t,this.assertValidity()}static fromCompact(e){const t=Zw(e),r="Signature.fromCompact";if("string"!=typeof e&&!t)throw new TypeError(r+": Expected string or Uint8Array");const n=t?ev(e):e;if(128!==n.length)throw Error(r+": Expected 64-byte hex");return new Xw(cv(n.slice(0,64)),cv(n.slice(64,128)))}static fromDER(e){const t=Zw(e);if("string"!=typeof e&&!t)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r,s:n}=function(e){if(e.length<2||48!=e[0])throw Error("Invalid signature tag: "+ev(e));if(e[1]!==e.length-2)throw Error("Invalid signature: incorrect length");const{data:t,left:r}=Ww(e.subarray(2)),{data:n,left:s}=Ww(r);if(s.length)throw Error("Invalid signature: left bytes after parsing: "+ev(s));return{r:t,s:n}}(t?e:nv(e));return new Xw(r,n)}static fromHex(e){return this.fromDER(e)}assertValidity(){const{r:e,s:t}=this;if(!wv(e))throw Error("Invalid Signature: r must be 0 < r < n");if(!wv(t))throw Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const e=Mw.n>>_w;return this.s>e}normalizeS(){return this.hasHighS()?new Xw(this.r,dv(-this.s,Mw.n)):this}toDERRawBytes(){return nv(this.toDERHex())}toDERHex(){const e=Gw(av(this.s)),t=Gw(av(this.r)),r=e.length/2,n=t.length/2,s=av(r),i=av(n);return`30${av(n+r+4)}02${i}${t}02${s}${e}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return nv(this.toCompactHex())}toCompactHex(){return iv(this.r)+iv(this.s)}}function Zw(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function Qw(e){if(!Zw(e))throw Error("Uint8Array expected")}function Yw(...e){if(e.every(Qw),1===e.length)return e[0];const t=e.reduce((e,t)=>e+t.length,0),r=new Uint8Array(t);for(let t=0,n=0;t<e.length;t++){const s=e[t];r.set(s,n),n+=s.length}return r}const Jw=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function ev(e){Qw(e);let t="";for(let r=0;r<e.length;r++)t+=Jw[e[r]];return t}const tv={_0:48,_9:57,A:65,F:70,a:97,f:102};function rv(e){return e>=tv._0&&e<=tv._9?e-tv._0:e>=tv.A&&e<=tv.F?e-(tv.A-10):e>=tv.a&&e<=tv.f?e-(tv.a-10):void 0}function nv(e){if("string"!=typeof e)throw Error("hex string expected, got "+typeof e);const t=e.length,r=t/2;if(t%2)throw Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(r);for(let t=0,s=0;t<r;t++,s+=2){const r=rv(e.charCodeAt(s)),i=rv(e.charCodeAt(s+1));if(void 0===r||void 0===i){const t=e[s]+e[s+1];throw Error('hex string expected, got non-hex character "'+t+'" at index '+s)}n[t]=16*r+i}return n}const sv=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function iv(e){if("bigint"!=typeof e)throw Error("Expected bigint");if(!(Pw<=e&&e<sv))throw Error("Expected number 0 <= n < 2^256");return e.toString(16).padStart(64,"0")}function ov(e){const t=nv(iv(e));if(32!==t.length)throw Error("Error: expected 32 bytes");return t}function av(e){const t=e.toString(16);return 1&t.length?"0"+t:t}function cv(e){if("string"!=typeof e)throw new TypeError("hexToNumber: expected string, got "+typeof e);return BigInt("0x"+e)}function lv(e){return cv(ev(e))}function uv(e){return Zw(e)?Uint8Array.from(e):nv(e)}function hv(e){if("number"==typeof e&&Number.isSafeInteger(e)&&e>0)return BigInt(e);if("bigint"==typeof e&&wv(e))return e;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function dv(e,t=Mw.P){const r=e%t;return r>=Pw?r:t+r}function pv(e,t){const{P:r}=Mw;let n=e;for(;t-- >Pw;)n*=n,n%=r;return n}function fv(e,t=Mw.P){if(e===Pw||t<=Pw)throw Error(`invert: expected positive integers, got n=${e} mod=${t}`);let r=dv(e,t),n=t,s=Pw,i=_w;for(;r!==Pw;){const e=n%r,t=s-i*(n/r);n=r,r=e,s=i,i=t}if(n!==_w)throw Error("invert: does not exist");return dv(s,t)}function gv(e,t=!1){const r=function(e){const t=8*e.length-256,r=lv(e);return t>0?r>>BigInt(t):r}(e);if(t)return r;const{n}=Mw;return r>=n?r-n:r}let mv,yv;class bv{constructor(e,t){if(this.hashLen=e,this.qByteLen=t,"number"!=typeof e||e<2)throw Error("hashLen must be a number");if("number"!=typeof t||t<2)throw Error("qByteLen must be a number");this.v=new Uint8Array(e).fill(1),this.k=new Uint8Array(e).fill(0),this.counter=0}hmac(...e){return Lv.hmacSha256(this.k,...e)}hmacSync(...e){return yv(this.k,...e)}checkSync(){if("function"!=typeof yv)throw new $w("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(e=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),e),this.v=await this.hmac(this.v),0!==e.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),e),this.v=await this.hmac(this.v))}reseedSync(e=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),e),this.v=this.hmacSync(this.v),0!==e.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),e),this.v=this.hmacSync(this.v))}async generate(){this.incr();let e=0;const t=[];for(;e<this.qByteLen;){this.v=await this.hmac(this.v);const r=this.v.slice();t.push(r),e+=this.v.length}return Yw(...t)}generateSync(){this.checkSync(),this.incr();let e=0;const t=[];for(;e<this.qByteLen;){this.v=this.hmacSync(this.v);const r=this.v.slice();t.push(r),e+=this.v.length}return Yw(...t)}}function wv(e){return Pw<e&&e<Mw.n}function vv(e){return Pw<e&&e<Mw.P}function Ev(e,t,r,n=!0){const{n:s}=Mw,i=gv(e,!0);if(!wv(i))return;const o=fv(i,s),a=jw.BASE.multiply(i),c=dv(a.x,s);if(c===Pw)return;const l=dv(o*dv(t+r*c,s),s);if(l===Pw)return;let u=new Xw(c,l),h=(a.x===u.r?0:2)|Number(a.y&_w);return n&&u.hasHighS()&&(u=u.normalizeS(),h^=1),{sig:u,recovery:h}}function Sv(e){let t;if("bigint"==typeof e)t=e;else if("number"==typeof e&&Number.isSafeInteger(e)&&e>0)t=BigInt(e);else if("string"==typeof e){if(64!==e.length)throw Error("Expected 32 bytes of private key");t=cv(e)}else{if(!Zw(e))throw new TypeError("Expected valid private key");if(e.length!==Fw)throw Error("Expected 32 bytes of private key");t=lv(e)}if(!wv(t))throw Error("Expected private key: 0 < key < n");return t}function Av(e){if(e instanceof Xw)return e.assertValidity(),e;try{return Xw.fromDER(e)}catch(t){return Xw.fromCompact(e)}}function Iv(e){return lv(e.length>Uw?e.slice(0,Uw):e)}function Cv(e){const t=Iv(e),r=dv(t,Mw.n);return xv(r<Pw?t:r)}function xv(e){return ov(e)}async function kv(e,t,r={}){const{seed:n,m:s,d:i}=function(e,t,r){if(null==e)throw Error(`sign: expected valid message hash, not "${e}"`);const n=uv(e),s=Sv(t),i=[xv(s),Cv(n)];if(null!=r){!0===r&&(r=Lv.randomBytes(Uw));const e=uv(r);if(e.length!==Uw)throw Error("sign: Expected 32 bytes of extra data");i.push(e)}return{seed:Yw(...i),m:Iv(n),d:s}}(e,t,r.extraEntropy),o=new bv(32,Fw);let a;for(await o.reseed(n);!(a=Ev(await o.generate(),s,i,r.canonical));)await o.reseed();return function(e,t){const{sig:r,recovery:n}=e,{der:s,recovered:i}=Object.assign({canonical:!0,der:!0},t),o=s?r.toDERRawBytes():r.toCompactRawBytes();return i?[o,n]:o}(a,r)}const Tv={strict:!0};function Pv(e,t,r,n=Tv){let s;try{s=Av(e),t=uv(t)}catch(e){return!1}const{r:i,s:o}=s;if(n.strict&&s.hasHighS())return!1;const a=gv(t);let c;try{c=function(e){return e instanceof jw?(e.assertValidity(),e):jw.fromHex(e)}(r)}catch(e){return!1}const{n:l}=Mw,u=fv(o,l),h=dv(a*u,l),d=dv(i*u,l),p=jw.BASE.multiplyAndAddUnsafe(c,h,d);if(!p)return!1;return dv(p.x,l)===i}jw.BASE._setWindowSize(8);const _v={node:Tw,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},Rv={},Lv={bytesToHex:ev,hexToBytes:nv,concatBytes:Yw,mod:dv,invert:fv,isValidPrivateKey(e){try{return Sv(e),!0}catch(e){return!1}},_bigintTo32Bytes:ov,_normalizePrivateKey:Sv,hashToPrivateKey(e){if((e=uv(e)).length<40||e.length>1024)throw Error("Expected valid bytes of private key as per FIPS 186");return ov(dv(lv(e),Mw.n-_w)+_w)},randomBytes(e=32){if(_v.web)return _v.web.getRandomValues(new Uint8Array(e));if(_v.node){const{randomBytes:t}=_v.node;return Uint8Array.from(t(e))}throw Error("The environment doesn't have randomBytes function")},randomPrivateKey(){return Lv.hashToPrivateKey(Lv.randomBytes(40))},precompute(e=8,t=jw.BASE){const r=t===jw.BASE?t:new jw(t.x,t.y);return r._setWindowSize(e),r.multiply(Lw),r},async sha256(...e){if(_v.web){const t=await _v.web.subtle.digest("SHA-256",Yw(...e));return new Uint8Array(t)}if(_v.node){const{createHash:t}=_v.node,r=t("sha256");return e.forEach(e=>r.update(e)),Uint8Array.from(r.digest())}throw Error("The environment doesn't have sha256 function")},async hmacSha256(e,...t){if(_v.web){const r=await _v.web.subtle.importKey("raw",e,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),n=Yw(...t),s=await _v.web.subtle.sign("HMAC",r,n);return new Uint8Array(s)}if(_v.node){const{createHmac:r}=_v.node,n=r("sha256",e);return t.forEach(e=>n.update(e)),Uint8Array.from(n.digest())}throw Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,async taggedHash(e,...t){let r=Rv[e];if(void 0===r){const t=await Lv.sha256(Uint8Array.from(e,e=>e.charCodeAt(0)));r=Yw(t,t),Rv[e]=r}return Lv.sha256(r,...t)},taggedHashSync(e,...t){if("function"!=typeof mv)throw new $w("sha256Sync is undefined, you need to set it");let r=Rv[e];if(void 0===r){const t=mv(Uint8Array.from(e,e=>e.charCodeAt(0)));r=Yw(t,t),Rv[e]=r}return mv(r,...t)},_JacobianPoint:Kw};Object.defineProperties(Lv,{sha256Sync:{configurable:!1,get:()=>mv,set(e){mv||(mv=e)}},hmacSha256Sync:{configurable:!1,get:()=>yv,set(e){yv||(yv=e)}}});var Dv,Mv={exports:{}};var Nv,Ov=(Dv||(Dv=1,Nv=Mv,function(){var e="input is invalid type",t="object"==typeof window,r=t?window:{};r.JS_SHA3_NO_WINDOW&&(t=!1);var n=!t&&"object"==typeof self;!r.JS_SHA3_NO_NODE_JS&&"object"==typeof process&&process.versions&&process.versions.node?r=In:n&&(r=self);for(var s=!r.JS_SHA3_NO_COMMON_JS&&Nv.exports,i=!r.JS_SHA3_NO_ARRAY_BUFFER&&"undefined"!=typeof ArrayBuffer,o="0123456789abcdef".split(""),a=[4,1024,262144,67108864],c=[0,8,16,24],l=[1,0,32898,0,32906,2147483648,2147516416,2147483648,32907,0,2147483649,0,2147516545,2147483648,32777,2147483648,138,0,136,0,2147516425,0,2147483658,0,2147516555,0,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,2147483648,32778,0,2147483658,2147483648,2147516545,2147483648,32896,2147483648,2147483649,0,2147516424,2147483648],u=[224,256,384,512],h=[128,256],d=["hex","buffer","arrayBuffer","array","digest"],p={128:168,256:136},f=r.JS_SHA3_NO_NODE_JS||!Array.isArray?e=>"[object Array]"==={}.toString.call(e):Array.isArray,g=!i||!r.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW&&ArrayBuffer.isView?ArrayBuffer.isView:e=>"object"==typeof e&&e.buffer&&e.buffer.constructor===ArrayBuffer,m=t=>{var r=typeof t;if("string"===r)return[t,!0];if("object"!==r||null===t)throw Error(e);if(i&&t.constructor===ArrayBuffer)return[new Uint8Array(t),!1];if(!f(t)&&!g(t))throw Error(e);return[t,!1]},y=e=>0===m(e)[0].length,b=e=>{for(var t=[],r=0;r<e.length;++r)t[r]=e[r];return t},w=(e,t,r)=>n=>new M(e,t,e).update(n)[r](),v=(e,t,r)=>(n,s)=>new M(e,t,s).update(n)[r](),E=(e,t,r)=>(t,n,s,i)=>x["cshake"+e].update(t,n,s,i)[r](),S=(e,t,r)=>(t,n,s,i)=>x["kmac"+e].update(t,n,s,i)[r](),A=(e,t,r,n)=>{for(var s=0;s<d.length;++s){var i=d[s];e[i]=t(r,n,i)}return e},I=(e,t)=>{var r=w(e,t,"hex");return r.create=()=>new M(e,t,e),r.update=e=>r.create().update(e),A(r,w,e,t)},C=[{name:"keccak",padding:[1,256,65536,16777216],bits:u,createMethod:I},{name:"sha3",padding:[6,1536,393216,100663296],bits:u,createMethod:I},{name:"shake",padding:[31,7936,2031616,520093696],bits:h,createMethod(e,t){var r=v(e,t,"hex");return r.create=r=>new M(e,t,r),r.update=(e,t)=>r.create(t).update(e),A(r,v,e,t)}},{name:"cshake",padding:a,bits:h,createMethod(e,t){var r=p[e],n=E(e,0,"hex");return n.create=(n,s,i)=>y(s)&&y(i)?x["shake"+e].create(n):new M(e,t,n).bytepad([s,i],r),n.update=(e,t,r,s)=>n.create(t,r,s).update(e),A(n,E,e,t)}},{name:"kmac",padding:a,bits:h,createMethod(e,t){var r=p[e],n=S(e,0,"hex");return n.create=(n,s,i)=>new N(e,t,s).bytepad(["KMAC",i],r).bytepad([n],r),n.update=(e,t,r,s)=>n.create(e,r,s).update(t),A(n,S,e,t)}}],x={},k=[],T=0;T<C.length;++T)for(var P=C[T],_=P.bits,R=0;R<_.length;++R){var L=P.name+"_"+_[R];if(k.push(L),x[L]=P.createMethod(_[R],P.padding),"sha3"!==P.name){var D=P.name+_[R];k.push(D),x[D]=x[L]}}function M(e,t,r){this.blocks=[],this.s=[],this.padding=t,this.outputBits=r,this.reset=!0,this.finalized=!1,this.block=0,this.start=0,this.blockCount=1600-(e<<1)>>5,this.byteCount=this.blockCount<<2,this.outputBlocks=r>>5,this.extraBytes=(31&r)>>3;for(var n=0;n<50;++n)this.s[n]=0}function N(e,t,r){M.call(this,e,t,r)}M.prototype.update=function(e){if(this.finalized)throw Error("finalize already called");var t=m(e);e=t[0];for(var r,n,s=t[1],i=this.blocks,o=this.byteCount,a=e.length,l=this.blockCount,u=0,h=this.s;u<a;){if(this.reset)for(this.reset=!1,i[0]=this.block,r=1;r<l+1;++r)i[r]=0;if(s)for(r=this.start;u<a&&r<o;++u)(n=e.charCodeAt(u))<128?i[r>>2]|=n<<c[3&r++]:n<2048?(i[r>>2]|=(192|n>>6)<<c[3&r++],i[r>>2]|=(128|63&n)<<c[3&r++]):n<55296||n>=57344?(i[r>>2]|=(224|n>>12)<<c[3&r++],i[r>>2]|=(128|n>>6&63)<<c[3&r++],i[r>>2]|=(128|63&n)<<c[3&r++]):(n=65536+((1023&n)<<10|1023&e.charCodeAt(++u)),i[r>>2]|=(240|n>>18)<<c[3&r++],i[r>>2]|=(128|n>>12&63)<<c[3&r++],i[r>>2]|=(128|n>>6&63)<<c[3&r++],i[r>>2]|=(128|63&n)<<c[3&r++]);else for(r=this.start;u<a&&r<o;++u)i[r>>2]|=e[u]<<c[3&r++];if(this.lastByteIndex=r,r>=o){for(this.start=r-o,this.block=i[l],r=0;r<l;++r)h[r]^=i[r];O(h),this.reset=!0}else this.start=r}return this},M.prototype.encode=function(e,t){var r=255&e,n=1,s=[r];for(r=255&(e>>=8);r>0;)s.unshift(r),r=255&(e>>=8),++n;return t?s.push(n):s.unshift(n),this.update(s),s.length},M.prototype.encodeString=function(e){var t=m(e);e=t[0];var r=t[1],n=0,s=e.length;if(r)for(var i=0;i<e.length;++i){var o=e.charCodeAt(i);o<128?n+=1:o<2048?n+=2:o<55296||o>=57344?n+=3:(o=65536+((1023&o)<<10|1023&e.charCodeAt(++i)),n+=4)}else n=s;return n+=this.encode(8*n),this.update(e),n},M.prototype.bytepad=function(e,t){for(var r=this.encode(t),n=0;n<e.length;++n)r+=this.encodeString(e[n]);var s=(t-r%t)%t,i=[];return i.length=s,this.update(i),this},M.prototype.finalize=function(){if(!this.finalized){this.finalized=!0;var e=this.blocks,t=this.lastByteIndex,r=this.blockCount,n=this.s;if(e[t>>2]|=this.padding[3&t],this.lastByteIndex===this.byteCount)for(e[0]=e[r],t=1;t<r+1;++t)e[t]=0;for(e[r-1]|=2147483648,t=0;t<r;++t)n[t]^=e[t];O(n)}},M.prototype.toString=M.prototype.hex=function(){this.finalize();for(var e,t=this.blockCount,r=this.s,n=this.outputBlocks,s=this.extraBytes,i=0,a=0,c="";a<n;){for(i=0;i<t&&a<n;++i,++a)e=r[i],c+=o[e>>4&15]+o[15&e]+o[e>>12&15]+o[e>>8&15]+o[e>>20&15]+o[e>>16&15]+o[e>>28&15]+o[e>>24&15];a%t===0&&(r=b(r),O(r),i=0)}return s&&(e=r[i],c+=o[e>>4&15]+o[15&e],s>1&&(c+=o[e>>12&15]+o[e>>8&15]),s>2&&(c+=o[e>>20&15]+o[e>>16&15])),c},M.prototype.arrayBuffer=function(){this.finalize();var e,t=this.blockCount,r=this.s,n=this.outputBlocks,s=this.extraBytes,i=0,o=0,a=this.outputBits>>3;e=s?new ArrayBuffer(n+1<<2):new ArrayBuffer(a);for(var c=new Uint32Array(e);o<n;){for(i=0;i<t&&o<n;++i,++o)c[o]=r[i];o%t===0&&(r=b(r),O(r))}return s&&(c[o]=r[i],e=e.slice(0,a)),e},M.prototype.buffer=M.prototype.arrayBuffer,M.prototype.digest=M.prototype.array=function(){this.finalize();for(var e,t,r=this.blockCount,n=this.s,s=this.outputBlocks,i=this.extraBytes,o=0,a=0,c=[];a<s;){for(o=0;o<r&&a<s;++o,++a)e=a<<2,t=n[o],c[e]=255&t,c[e+1]=t>>8&255,c[e+2]=t>>16&255,c[e+3]=t>>24&255;a%r===0&&(n=b(n),O(n))}return i&&(e=a<<2,t=n[o],c[e]=255&t,i>1&&(c[e+1]=t>>8&255),i>2&&(c[e+2]=t>>16&255)),c},N.prototype=new M,N.prototype.finalize=function(){return this.encode(this.outputBits,!0),M.prototype.finalize.call(this)};var O=e=>{var t,r,n,s,i,o,a,c,u,h,d,p,f,g,m,y,b,w,v,E,S,A,I,C,x,k,T,P,_,R,L,D,M,N,O,U,F,B,q,$,z,K,V,H,j,G,W,X,Z,Q,Y,J,ee,te,re,ne,se,ie,oe,ae,ce,le,ue;for(n=0;n<48;n+=2)s=e[0]^e[10]^e[20]^e[30]^e[40],i=e[1]^e[11]^e[21]^e[31]^e[41],o=e[2]^e[12]^e[22]^e[32]^e[42],a=e[3]^e[13]^e[23]^e[33]^e[43],c=e[4]^e[14]^e[24]^e[34]^e[44],u=e[5]^e[15]^e[25]^e[35]^e[45],h=e[6]^e[16]^e[26]^e[36]^e[46],d=e[7]^e[17]^e[27]^e[37]^e[47],t=(p=e[8]^e[18]^e[28]^e[38]^e[48])^(o<<1|a>>>31),r=(f=e[9]^e[19]^e[29]^e[39]^e[49])^(a<<1|o>>>31),e[0]^=t,e[1]^=r,e[10]^=t,e[11]^=r,e[20]^=t,e[21]^=r,e[30]^=t,e[31]^=r,e[40]^=t,e[41]^=r,t=s^(c<<1|u>>>31),r=i^(u<<1|c>>>31),e[2]^=t,e[3]^=r,e[12]^=t,e[13]^=r,e[22]^=t,e[23]^=r,e[32]^=t,e[33]^=r,e[42]^=t,e[43]^=r,t=o^(h<<1|d>>>31),r=a^(d<<1|h>>>31),e[4]^=t,e[5]^=r,e[14]^=t,e[15]^=r,e[24]^=t,e[25]^=r,e[34]^=t,e[35]^=r,e[44]^=t,e[45]^=r,t=c^(p<<1|f>>>31),r=u^(f<<1|p>>>31),e[6]^=t,e[7]^=r,e[16]^=t,e[17]^=r,e[26]^=t,e[27]^=r,e[36]^=t,e[37]^=r,e[46]^=t,e[47]^=r,t=h^(s<<1|i>>>31),r=d^(i<<1|s>>>31),e[8]^=t,e[9]^=r,e[18]^=t,e[19]^=r,e[28]^=t,e[29]^=r,e[38]^=t,e[39]^=r,e[48]^=t,e[49]^=r,g=e[0],m=e[1],G=e[11]<<4|e[10]>>>28,W=e[10]<<4|e[11]>>>28,P=e[20]<<3|e[21]>>>29,_=e[21]<<3|e[20]>>>29,ae=e[31]<<9|e[30]>>>23,ce=e[30]<<9|e[31]>>>23,K=e[40]<<18|e[41]>>>14,V=e[41]<<18|e[40]>>>14,N=e[2]<<1|e[3]>>>31,O=e[3]<<1|e[2]>>>31,y=e[13]<<12|e[12]>>>20,b=e[12]<<12|e[13]>>>20,X=e[22]<<10|e[23]>>>22,Z=e[23]<<10|e[22]>>>22,R=e[33]<<13|e[32]>>>19,L=e[32]<<13|e[33]>>>19,le=e[42]<<2|e[43]>>>30,ue=e[43]<<2|e[42]>>>30,te=e[5]<<30|e[4]>>>2,re=e[4]<<30|e[5]>>>2,U=e[14]<<6|e[15]>>>26,F=e[15]<<6|e[14]>>>26,w=e[25]<<11|e[24]>>>21,v=e[24]<<11|e[25]>>>21,Q=e[34]<<15|e[35]>>>17,Y=e[35]<<15|e[34]>>>17,D=e[45]<<29|e[44]>>>3,M=e[44]<<29|e[45]>>>3,C=e[6]<<28|e[7]>>>4,x=e[7]<<28|e[6]>>>4,ne=e[17]<<23|e[16]>>>9,se=e[16]<<23|e[17]>>>9,B=e[26]<<25|e[27]>>>7,q=e[27]<<25|e[26]>>>7,E=e[36]<<21|e[37]>>>11,S=e[37]<<21|e[36]>>>11,J=e[47]<<24|e[46]>>>8,ee=e[46]<<24|e[47]>>>8,H=e[8]<<27|e[9]>>>5,j=e[9]<<27|e[8]>>>5,k=e[18]<<20|e[19]>>>12,T=e[19]<<20|e[18]>>>12,ie=e[29]<<7|e[28]>>>25,oe=e[28]<<7|e[29]>>>25,$=e[38]<<8|e[39]>>>24,z=e[39]<<8|e[38]>>>24,A=e[48]<<14|e[49]>>>18,I=e[49]<<14|e[48]>>>18,e[0]=g^~y&w,e[1]=m^~b&v,e[10]=C^~k&P,e[11]=x^~T&_,e[20]=N^~U&B,e[21]=O^~F&q,e[30]=H^~G&X,e[31]=j^~W&Z,e[40]=te^~ne&ie,e[41]=re^~se&oe,e[2]=y^~w&E,e[3]=b^~v&S,e[12]=k^~P&R,e[13]=T^~_&L,e[22]=U^~B&$,e[23]=F^~q&z,e[32]=G^~X&Q,e[33]=W^~Z&Y,e[42]=ne^~ie&ae,e[43]=se^~oe&ce,e[4]=w^~E&A,e[5]=v^~S&I,e[14]=P^~R&D,e[15]=_^~L&M,e[24]=B^~$&K,e[25]=q^~z&V,e[34]=X^~Q&J,e[35]=Z^~Y&ee,e[44]=ie^~ae&le,e[45]=oe^~ce&ue,e[6]=E^~A&g,e[7]=S^~I&m,e[16]=R^~D&C,e[17]=L^~M&x,e[26]=$^~K&N,e[27]=z^~V&O,e[36]=Q^~J&H,e[37]=Y^~ee&j,e[46]=ae^~le&te,e[47]=ce^~ue&re,e[8]=A^~g&y,e[9]=I^~m&b,e[18]=D^~C&k,e[19]=M^~x&T,e[28]=K^~N&U,e[29]=V^~O&F,e[38]=J^~H&G,e[39]=ee^~j&W,e[48]=le^~te&ne,e[49]=ue^~re&se,e[0]^=l[n],e[1]^=l[n+1]};if(s)Nv.exports=x;else for(T=0;T<k.length;++T)r[k[T]]=x[k[T]]}()),Mv.exports),Uv=Cn(Ov);function Fv(e){return new Uint8Array(Uv.keccak256.arrayBuffer(e))}function Bv(e,t,r){try{return Pv(Xw.fromCompact(e.slice(0,64)),t,r)}catch{return!1}}function qv(e,t){switch(t){case"udp":return qv(e,"udp4")||qv(e,"udp6");case"tcp":return qv(e,"tcp4")||qv(e,"tcp6")}const r=t.endsWith("6"),n=e.get(r?"ip6":"ip");if(!n)return;const s=t.slice(0,3);let i;switch(s){case"udp":i=r?e.get("udp6"):e.get("udp");break;case"tcp":i=r?e.get("tcp6"):e.get("tcp");break;default:return}return i?function(e,t,r,n){let s=Zl("/"+e+"/"+jl(e,r));return s=s.encapsulate(Zl("/"+t+"/"+jl(t,n))),s}(r?"ip6":"ip4",s,n,i):void 0}const $v=parseInt("11111",2),zv=parseInt("10000000",2),Kv=parseInt("01111111",2),Vv={0:Gv,1:Gv,2(e,t){const r=jv(e,t),n=t.offset,s=t.offset+r,i=[];for(let t=n;t<s;t++)t===n&&0===e[t]||i.push(e[t]);return t.offset+=r,Uint8Array.from(i)},3(e,t){const r=jv(e,t),n=e[t.offset];t.offset++;const s=e.subarray(t.offset,t.offset+r-1);if(t.offset+=r,0!==n)throw Error("Unused bits in bit string is unimplemented");return s},4(e,t){const r=jv(e,t),n=e.subarray(t.offset,t.offset+r);return t.offset+=r,n},5(e,t){return t.offset++,null},6(e,t){const r=jv(e,t),n=t.offset+r,s=e[t.offset];t.offset++;let i=0,o=0;s<40?(i=0,o=s):s<80?(i=1,o=s-40):(i=2,o=s-80);let a=`${i}.${o}`,c=[];for(;t.offset<n;){const r=e[t.offset];if(t.offset++,c.push(127&r),r<128){c.reverse();let e=0;for(let t=0;t<c.length;t++)e+=c[t]<<7*t;a+="."+e,c=[]}}return a},16:Gv,22:Gv,48:Gv};function Hv(e,t={offset:0}){const r=e[t.offset]&$v;if(t.offset++,null!=Vv[r])return Vv[r](e,t);throw Error("No decoder for tag "+r)}function jv(e,t){let r=0;if((e[t.offset]&zv)===zv){const n=e[t.offset]&Kv;let s="0x";t.offset++;for(let r=0;r<n;r++,t.offset++)s+=e[t.offset].toString(16).padStart(2,"0");r=parseInt(s,16)}else r=e[t.offset],t.offset++;return r}function Gv(e,t){jv(e,t);const r=[];for(;!(t.offset>=e.byteLength);){const n=Hv(e,t);if(null===n)break;r.push(n)}return r}function Wv(e){if(e.byteLength<128)return Uint8Array.from([e.byteLength]);const t=function(e){let t=e.toString(16);t.length%2==1&&(t="0"+t);const r=new rs;for(let e=0;e<t.length;e+=2)r.append(Uint8Array.from([parseInt(`${t[e]}${t[e+1]}`,16)]));return r}(e.byteLength);return new rs(Uint8Array.from([t.byteLength|zv]),t)}function Xv(e){const t=new rs;return!(128&~e.subarray()[0])&&t.append(Uint8Array.from([0])),t.append(e),new rs(Uint8Array.from([2]),Wv(t),t)}function Zv(e){const t=Uint8Array.from([0]),r=new rs(t,e);return new rs(Uint8Array.from([3]),Wv(r),r)}function Qv(e,t=48){const r=new rs;for(const t of e)r.append(t);return new rs(Uint8Array.from([t]),Wv(r),r)}const Yv=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),Jv=Uint8Array.from([6,5,43,129,4,0,34]),eE=Uint8Array.from([6,5,43,129,4,0,35]),tE={ext:!0,kty:"EC",crv:"P-256"},rE={ext:!0,kty:"EC",crv:"P-384"},nE={ext:!0,kty:"EC",crv:"P-521"};function sE(e){if("P-256"===e)return Yv;if("P-384"===e)return Jv;if("P-521"===e)return eE;throw new Pi("Invalid curve "+e)}class iE{type="ECDSA";jwk;_raw;constructor(e){this.jwk=e}get raw(){var e;return null==this._raw&&(this._raw=(e=this.jwk,Qv([Xv(Uint8Array.from([1])),Qv([sE(e.crv)],160),Qv([Zv(new rs(Uint8Array.from([4]),rt(e.x??"","base64url"),rt(e.y??"","base64url")))],161)]).subarray())),this._raw}toMultihash(){return Be.digest(IE(this))}toCID(){return je.createV1(114,this.toMultihash())}toString(){return he.encode(this.toMultihash().bytes).substring(1)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&Yn(this.raw,e.raw)}async verify(e,t,r){return async function(e,t,r,n){const s=await crypto.subtle.importKey("jwk",e,{name:"ECDSA",namedCurve:e.crv??"P-256"},!1,["verify"]);n?.signal?.throwIfAborted();const i=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},s,t,r.subarray());return n?.signal?.throwIfAborted(),i}(this.jwk,t,e,r)}}class oE extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}}class aE extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}}var cE={get(e=globalThis){const t=e.crypto;if(null==t?.subtle)throw new aE("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return t}};let lE;const uE=(async()=>{try{return await cE.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();async function hE(e,t,r){return null==lE&&(lE=await uE),lE?async function(e,t,r){if(e.buffer instanceof ArrayBuffer){const n=await cE.get().subtle.importKey("raw",e.buffer,{name:"Ed25519"},!1,["verify"]);return await cE.get().subtle.verify({name:"Ed25519"},n,t,r instanceof Uint8Array?r:r.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}(e,t,r):function(e,t,r){return Ja.verify(t,r instanceof Uint8Array?r:r.subarray(),e)}(e,t,r)}function dE(e){return null!=e&&("function"==typeof e.then&&"function"==typeof e.catch&&"function"==typeof e.finally)}class pE{type="Ed25519";raw;constructor(e){this.raw=fE(e,32)}toMultihash(){return Be.digest(IE(this))}toCID(){return je.createV1(114,this.toMultihash())}toString(){return he.encode(this.toMultihash().bytes).substring(1)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&Yn(this.raw,e.raw)}verify(e,t,r){r?.signal?.throwIfAborted();const n=hE(this.raw,t,e);return dE(n)?n.then(e=>(r?.signal?.throwIfAborted(),e)):n}}function fE(e,t){if((e=Uint8Array.from(e??[])).length!==t)throw new Pi(`Key must be a Uint8Array of length ${t}, got ${e.length}`);return e}var gE,mE,yE,bE;(e=>{e.RSA="RSA",e.Ed25519="Ed25519",e.secp256k1="secp256k1",e.ECDSA="ECDSA"})(gE||(gE={})),(e=>{e[e.RSA=0]="RSA",e[e.Ed25519=1]="Ed25519",e[e.secp256k1=2]="secp256k1",e[e.ECDSA=3]="ECDSA"})(mE||(mE={})),(e=>{e.codec=()=>Yt(mE)})(gE||(gE={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.Type&&(t.uint32(8),gE.codec().encode(e.Type,t)),null!=e.Data&&(t.uint32(18),t.bytes(e.Data)),!1!==r.lengthDelimited&&t.ldelim()},(e,t)=>{const r={},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();switch(t>>>3){case 1:r.Type=gE.codec().decode(e);break;case 2:r.Data=e.bytes();break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(yE||(yE={})),(e=>{let t;e.codec=()=>(null==t&&(t=Jt((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.Type&&(t.uint32(8),gE.codec().encode(e.Type,t)),null!=e.Data&&(t.uint32(18),t.bytes(e.Data)),!1!==r.lengthDelimited&&t.ldelim()},(e,t)=>{const r={},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();switch(t>>>3){case 1:r.Type=gE.codec().decode(e);break;case 2:r.Data=e.bytes();break;default:e.skipType(7&t)}}return r})),t),e.encode=t=>mt(t,e.codec()),e.decode=(t,r)=>T(t,e.codec(),r)})(bE||(bE={}));class wE{type="RSA";jwk;_raw;_multihash;constructor(e,t){this.jwk=e,this._multihash=t}get raw(){return null==this._raw&&(this._raw=function(e){if(null==e.n||null==e.e)throw new Pi("JWK was missing components");return Qv([vE,Zv(Qv([Xv(rt(e.n,"base64url")),Xv(rt(e.e,"base64url"))]))]).subarray()}(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return je.createV1(114,this._multihash)}toString(){return he.encode(this.toMultihash().bytes).substring(1)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&Yn(this.raw,e.raw)}verify(e,t,r){return async function(e,t,r,n){const s=await cE.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);n?.signal?.throwIfAborted();const i=await cE.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},s,t,r instanceof Uint8Array?r:r.subarray());return n?.signal?.throwIfAborted(),i}(this.jwk,t,e,r)}}const vE=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function EE(e,t,r){const n=function(e){const t=Hv(e[1],{offset:0});return{kty:"RSA",n:ln(t[0],"base64url"),e:ln(t[1],"base64url")}}(e);if(null==r){r=Ne(18,cn(yE.encode({Type:gE.RSA,Data:t})))}return new wE(n,r)}class SE{type="secp256k1";raw;_key;constructor(e){this._key=function(e){try{return Hc.ProjectivePoint.fromHex(e),e}catch(e){throw new _i(e+"")}}(e),this.raw=function(e){const t=Hc.ProjectivePoint.fromHex(e).toRawBytes(!0);return t}(this._key)}toMultihash(){return Be.digest(IE(this))}toCID(){return je.createV1(114,this.toMultihash())}toString(){return he.encode(this.toMultihash().bytes).substring(1)}equals(e){return null!=e&&e.raw instanceof Uint8Array&&Yn(this.raw,e.raw)}verify(e,t,r){return function(e,t,r,n){const s=ze.digest(r instanceof Uint8Array?r:r.subarray());if(dE(s))return s.then(({digest:r})=>(n?.signal?.throwIfAborted(),Hc.verify(t,r,e))).catch(e=>{if("AbortError"===e.name)throw e;throw new oE(e+"")});try{return n?.signal?.throwIfAborted(),Hc.verify(t,s.digest,e)}catch(e){throw new oE(e+"")}}(this._key,t,e,r)}}function AE(e){if(32===e.byteLength)return t=fE(t=e,32),new pE(t);if(33===e.byteLength)return function(e){return new SE(e)}(e);var t;const r=Hv(e),n=r[1]?.[0];if("1.2.840.10045.3.1.7"===n||"1.3.132.0.34"===n||"1.3.132.0.35"===n)return function(e){const t=e[1][1][0];let r,n;if(65===t.byteLength)return r=ln(t.subarray(1,33),"base64url"),n=ln(t.subarray(33),"base64url"),new iE({...tE,key_ops:["verify"],x:r,y:n});if(97===t.byteLength)return r=ln(t.subarray(1,49),"base64url"),n=ln(t.subarray(49),"base64url"),new iE({...rE,key_ops:["verify"],x:r,y:n});if(133===t.byteLength)return r=ln(t.subarray(1,67),"base64url"),n=ln(t.subarray(67),"base64url"),new iE({...nE,key_ops:["verify"],x:r,y:n});throw new Pi(`coordinates were wrong length, got ${t.byteLength}, expected 65, 97 or 133`)}(r);if("1.2.840.113549.1.1.1"===r[0]?.[0])return EE(r,e);throw new Pi("Could not extract public key from raw bytes")}function IE(e){return yE.encode({Type:gE[e.type],Data:e.raw})}const CE=Symbol.for("nodejs.util.inspect.custom");class xE{type;multihash;publicKey;string;constructor(e){this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}[vi]=!0;toString(){return null==this.string&&(this.string=he.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return je.createV1(114,this.multihash)}toJSON(){return this.toString()}equals(e){if(null==e)return!1;if(e instanceof Uint8Array)return Yn(this.multihash.bytes,e);if("string"==typeof e)return this.toString()===e;if(null!=e?.toMultihash()?.bytes)return Yn(this.multihash.bytes,e.toMultihash().bytes);throw Error("not valid Id")}[CE](){return`PeerId(${this.toString()})`}}class kE extends xE{type="RSA";publicKey;constructor(e){super({...e,type:"RSA"}),this.publicKey=e.publicKey}}class TE extends xE{type="Ed25519";publicKey;constructor(e){super({...e,type:"Ed25519"}),this.publicKey=e.publicKey}}class PE extends xE{type="secp256k1";publicKey;constructor(e){super({...e,type:"secp256k1"}),this.publicKey=e.publicKey}}function _E(e){const t=AE(e);if("secp256k1"!==t.type)throw Error("Keypair type not implemented");return function(e){if("Ed25519"===e.type)return new TE({multihash:e.toCID().multihash,publicKey:e});if("secp256k1"===e.type)return new PE({multihash:e.toCID().multihash,publicKey:e});if("RSA"===e.type)return new kE({multihash:e.toCID().multihash,publicKey:e});throw new Qi}(t)}function RE(e){const t=e.reduce((e,t)=>e+2+t.bytes.length,0),r=new Uint8Array(t),n=new DataView(r.buffer);let s=0;return e.forEach(e=>{if(e.getPeerId())throw Error("`multiaddr` field MUST not contain peer id");n.setUint16(s,e.bytes.length),s+=2,r.set(e.bytes,s),s+=e.bytes.length}),r}function LE(e){let t=0;return e.lightPush&&(t+=1),t<<=1,e.filter&&(t+=1),t<<=1,e.store&&(t+=1),t<<=1,e.relay&&(t+=1),t}class DE extends Map{seq;signature;constructor(e={},t=BigInt(1),r){super(Object.entries(e)),this.seq=t,this.signature=r}set(e,t){return this.signature=void 0,this.seq++,super.set(e,t)}get id(){const e=this.get("id");if(!e)throw Error("id not found.");return dn(e)}get publicKey(){if("v4"===this.id)return this.get("secp256k1");throw Error(kw)}get rs(){const e=this.get("rs");if(e)return Sn(e)}get rsv(){const e=this.get("rsv");if(e)return Sn(e)}get ip(){return ME(this,"ip","ip4")}set ip(e){OE(this,"ip","ip4",e)}get tcp(){return NE(this,"tcp","tcp")}set tcp(e){UE(this,"tcp","tcp",e)}get udp(){return NE(this,"udp","udp")}set udp(e){UE(this,"udp","udp",e)}get ip6(){return ME(this,"ip6","ip6")}set ip6(e){OE(this,"ip6","ip6",e)}get tcp6(){return NE(this,"tcp6","tcp")}set tcp6(e){UE(this,"tcp6","tcp",e)}get udp6(){return NE(this,"udp6","udp")}set udp6(e){UE(this,"udp6","udp",e)}get multiaddrs(){const e=this.get("multiaddrs");if(e)return function(e){const t=[];let r=0;for(;r<e.length;){const n=new DataView(e.buffer,r,2).getUint16(0);r+=2;const s=e.slice(r,r+n);r+=n,t.push(Zl(s))}return t}(e)}set multiaddrs(e){FE(this,"multiaddrs",e,RE)}get waku2(){const e=this.get("waku2");if(e)return function(e){const t={relay:!1,store:!1,filter:!1,lightPush:!1};return e%2&&(t.relay=!0),(e>>=1)%2&&(t.store=!0),(e>>=1)%2&&(t.filter=!0),(e>>=1)%2&&(t.lightPush=!0),t}(e[0])}set waku2(e){FE(this,"waku2",e,e=>new Uint8Array([LE(e)]))}}function ME(e,t,r){const n=e.get(t);if(n)return jl(r,n)}function NE(e,t,r){const n=e.get(t);if(n)return Number(jl(r,n))}function OE(e,t,r,n){FE(e,t,n,Gl.bind({},r))}function UE(e,t,r,n){OE(e,t,r,n?.toString(10))}function FE(e,t,r,n){void 0!==r?e.set(t,n(r)):e.delete(t)}const BE=new On("enr");var qE,$E;(e=>{e.TCP="tcp",e.UDP="udp"})(qE||(qE={})),(e=>{e.TCP4="tcp4",e.UDP4="udp4",e.TCP6="tcp6",e.UDP6="udp6"})($E||($E={}));class zE extends DE{static RECORD_PREFIX="enr:";peerId;static create(e={},t=BigInt(1),r){const n=new zE(e,t,r);try{const e=n.publicKey;e&&(n.peerId=_E(e))}catch(e){BE.error("Could not calculate peer id for ENR",e)}return n}get nodeId(){if("v4"===this.id)return this.publicKey?function(e){const t=jw.fromHex(e).toRawBytes(!1);return hn(Fv(t.slice(1)))}(this.publicKey):void 0;throw Error(kw)}getLocationMultiaddr=qv.bind({},this);get shardInfo(){return this.rs&&this.rsv&&BE.warn("ENR contains both `rs` and `rsv` fields."),this.rs||this.rsv}setLocationMultiaddr(e){const t=e.protoNames();if(2!==t.length&&"udp"!==t[1]&&"tcp"!==t[1])throw Error("Invalid multiaddr");const r=e.tuples();if(!r[0][1]||!r[1][1])throw Error("Invalid multiaddr");4===r[0][0]?(this.set("ip",r[0][1]),this.set(t[1],r[1][1])):(this.set("ip6",r[0][1]),this.set(t[1]+"6",r[1][1]))}getAllLocationMultiaddrs(){const e=[];for(const t of Object.values($E)){const r=this.getLocationMultiaddr(t);r&&e.push(r)}const t=this.multiaddrs??[];return e.concat(t).map(e=>this.peerId?e.encapsulate("/p2p/"+this.peerId.toString()):e)}get peerInfo(){const e=this.peerId;if(e)return{id:e,multiaddrs:this.getAllLocationMultiaddrs()}}getFullMultiaddr(e){if(this.peerId){const t=this.getLocationMultiaddr(e);if(t)return t.encapsulate("/p2p/"+this.peerId.toString())}}getFullMultiaddrs(){if(this.peerId&&this.multiaddrs){const e=this.peerId;return this.multiaddrs.map(t=>t.encapsulate("/p2p/"+e.toString()))}return[]}verify(e,t){if(!this.get("id")||"v4"!==this.id)throw Error(kw);if(!this.publicKey)throw Error("Failed to verify ENR: No public key");return Bv(t,Fv(e),this.publicKey)}async sign(e,t){if("v4"!==this.id)throw Error(kw);return this.signature=await async function(e,t){return kv(Fv(t),e,{der:!1})}(t,e),this.signature}}let KE=!1,VE=!1;const HE={debug:1,default:2,info:2,warning:3,error:4,off:5};let jE=HE.default,GE=null;const WE=function(){try{const e=[];if(["NFD","NFC","NFKD","NFKC"].forEach(t=>{try{if("test"!=="test".normalize(t))throw Error("bad normalize")}catch(r){e.push(t)}}),e.length)throw Error("missing "+e.join(", "));0}catch(e){return e.message}return null}();var XE,ZE;(e=>{e.DEBUG="DEBUG",e.INFO="INFO",e.WARNING="WARNING",e.ERROR="ERROR",e.OFF="OFF"})(XE||(XE={})),(e=>{e.UNKNOWN_ERROR="UNKNOWN_ERROR",e.NOT_IMPLEMENTED="NOT_IMPLEMENTED",e.UNSUPPORTED_OPERATION="UNSUPPORTED_OPERATION",e.NETWORK_ERROR="NETWORK_ERROR",e.SERVER_ERROR="SERVER_ERROR",e.TIMEOUT="TIMEOUT",e.BUFFER_OVERRUN="BUFFER_OVERRUN",e.NUMERIC_FAULT="NUMERIC_FAULT",e.MISSING_NEW="MISSING_NEW",e.INVALID_ARGUMENT="INVALID_ARGUMENT",e.MISSING_ARGUMENT="MISSING_ARGUMENT",e.UNEXPECTED_ARGUMENT="UNEXPECTED_ARGUMENT",e.CALL_EXCEPTION="CALL_EXCEPTION",e.INSUFFICIENT_FUNDS="INSUFFICIENT_FUNDS",e.NONCE_EXPIRED="NONCE_EXPIRED",e.REPLACEMENT_UNDERPRICED="REPLACEMENT_UNDERPRICED",e.UNPREDICTABLE_GAS_LIMIT="UNPREDICTABLE_GAS_LIMIT",e.TRANSACTION_REPLACED="TRANSACTION_REPLACED",e.ACTION_REJECTED="ACTION_REJECTED"})(ZE||(ZE={}));const QE="0123456789abcdef";class YE{constructor(e){Object.defineProperty(this,"version",{enumerable:!0,value:e,writable:!1})}_log(e,t){const r=e.toLowerCase();null==HE[r]&&this.throwArgumentError("invalid log level name","logLevel",e)}debug(...e){this._log(YE.levels.DEBUG,e)}info(...e){this._log(YE.levels.INFO,e)}warn(...e){this._log(YE.levels.WARNING,e)}makeError(e,t,r){if(VE)return this.makeError("censored error",t,{});t||(t=YE.errors.UNKNOWN_ERROR),r||(r={});const n=[];Object.keys(r).forEach(e=>{const t=r[e];try{if(t instanceof Uint8Array){let r="";for(let e=0;e<t.length;e++)r+=QE[t[e]>>4],r+=QE[15&t[e]];n.push(e+"=Uint8Array(0x"+r+")")}else n.push(e+"="+JSON.stringify(t))}catch(t){n.push(e+"="+JSON.stringify(r[e].toString()))}}),n.push("code="+t),n.push("version="+this.version);const s=e;let i="";switch(t){case ZE.NUMERIC_FAULT:{i="NUMERIC_FAULT";const t=e;switch(t){case"overflow":case"underflow":case"division-by-zero":i+="-"+t;break;case"negative-power":case"negative-width":i+="-unsupported";break;case"unbound-bitwise-result":i+="-unbound-result"}break}case ZE.CALL_EXCEPTION:case ZE.INSUFFICIENT_FUNDS:case ZE.MISSING_NEW:case ZE.NONCE_EXPIRED:case ZE.REPLACEMENT_UNDERPRICED:case ZE.TRANSACTION_REPLACED:case ZE.UNPREDICTABLE_GAS_LIMIT:i=t}i&&(e+=" [ See: https://links.ethers.org/v5-errors-"+i+" ]"),n.length&&(e+=" ("+n.join(", ")+")");const o=Error(e);return o.reason=s,o.code=t,Object.keys(r).forEach(e=>{o[e]=r[e]}),o}throwError(e,t,r){throw this.makeError(e,t,r)}throwArgumentError(e,t,r){return this.throwError(e,YE.errors.INVALID_ARGUMENT,{argument:t,value:r})}assert(e,t,r,n){e||this.throwError(t,r,n)}assertArgument(e,t,r,n){e||this.throwArgumentError(t,r,n)}checkNormalize(e){WE&&this.throwError("platform missing String.prototype.normalize",YE.errors.UNSUPPORTED_OPERATION,{operation:"String.prototype.normalize",form:WE})}checkSafeUint53(e,t){"number"==typeof e&&(null==t&&(t="value not safe"),(e<0||e>=9007199254740991)&&this.throwError(t,YE.errors.NUMERIC_FAULT,{operation:"checkSafeInteger",fault:"out-of-safe-range",value:e}),e%1&&this.throwError(t,YE.errors.NUMERIC_FAULT,{operation:"checkSafeInteger",fault:"non-integer",value:e}))}checkArgumentCount(e,t,r){r=r?": "+r:"",e<t&&this.throwError("missing argument"+r,YE.errors.MISSING_ARGUMENT,{count:e,expectedCount:t}),e>t&&this.throwError("too many arguments"+r,YE.errors.UNEXPECTED_ARGUMENT,{count:e,expectedCount:t})}checkNew(e,t){e!==Object&&null!=e||this.throwError("missing new",YE.errors.MISSING_NEW,{name:t.name})}checkAbstract(e,t){e===t?this.throwError("cannot instantiate abstract class "+JSON.stringify(t.name)+" directly; use a sub-class",YE.errors.UNSUPPORTED_OPERATION,{name:e.name,operation:"new"}):e!==Object&&null!=e||this.throwError("missing new",YE.errors.MISSING_NEW,{name:t.name})}static globalLogger(){return GE||(GE=new YE("logger/5.8.0")),GE}static setCensorship(e,t){if(!e&&t&&this.globalLogger().throwError("cannot permanently disable censorship",YE.errors.UNSUPPORTED_OPERATION,{operation:"setCensorship"}),KE){if(!e)return;this.globalLogger().throwError("error censorship permanent",YE.errors.UNSUPPORTED_OPERATION,{operation:"setCensorship"})}VE=!!e,KE=!!t}static setLogLevel(e){const t=HE[e.toLowerCase()];null!=t?jE=t:YE.globalLogger().warn("invalid log level - "+e)}static from(e){return new YE(e)}}YE.errors=ZE,YE.levels=XE;const JE=new YE("bytes/5.8.0");function eS(e){return!!e.toHexString}function tS(e){return e.slice||(e.slice=function(){const t=[].slice.call(arguments);return tS(new Uint8Array([].slice.apply(e,t)))}),e}function rS(e){return"number"==typeof e&&e==e&&e%1==0}function nS(e){if(null==e)return!1;if(e.constructor===Uint8Array)return!0;if("string"==typeof e)return!1;if(!rS(e.length)||e.length<0)return!1;for(let t=0;t<e.length;t++){const r=e[t];if(!rS(r)||r<0||r>=256)return!1}return!0}function sS(e,t){if(t||(t={}),"number"==typeof e){JE.checkSafeUint53(e,"invalid arrayify value");const t=[];for(;e;)t.unshift(255&e),e=parseInt(e/256+"");return 0===t.length&&t.push(0),tS(new Uint8Array(t))}if(t.allowMissingPrefix&&"string"==typeof e&&"0x"!==e.substring(0,2)&&(e="0x"+e),eS(e)&&(e=e.toHexString()),iS(e)){let r=e.substring(2);r.length%2&&("left"===t.hexPad?r="0"+r:"right"===t.hexPad?r+="0":JE.throwArgumentError("hex data is odd-length","value",e));const n=[];for(let e=0;e<r.length;e+=2)n.push(parseInt(r.substring(e,e+2),16));return tS(new Uint8Array(n))}return nS(e)?tS(new Uint8Array(e)):JE.throwArgumentError("invalid arrayify value","value",e)}function iS(e){return!("string"!=typeof e||!e.match(/^0x[0-9A-Fa-f]*$/))}const oS="0123456789abcdef";function aS(e,t){if(t||(t={}),"number"==typeof e){JE.checkSafeUint53(e,"invalid hexlify value");let t="";for(;e;)t=oS[15&e]+t,e=Math.floor(e/16);return t.length?(t.length%2&&(t="0"+t),"0x"+t):"0x00"}if("bigint"==typeof e)return(e=e.toString(16)).length%2?"0x0"+e:"0x"+e;if(t.allowMissingPrefix&&"string"==typeof e&&"0x"!==e.substring(0,2)&&(e="0x"+e),eS(e))return e.toHexString();if(iS(e))return e.length%2&&("left"===t.hexPad?e="0x0"+e.substring(2):"right"===t.hexPad?e+="0":JE.throwArgumentError("hex data is odd-length","value",e)),e.toLowerCase();if(nS(e)){let t="0x";for(let r=0;r<e.length;r++){let n=e[r];t+=oS[(240&n)>>4]+oS[15&n]}return t}return JE.throwArgumentError("invalid hexlify value","value",e)}const cS=new YE("rlp/5.8.0");function lS(e){const t=[];for(;e;)t.unshift(255&e),e>>=8;return t}function uS(e,t,r){let n=0;for(let s=0;s<r;s++)n=256*n+e[t+s];return n}function hS(e){if(Array.isArray(e)){let t=[];if(e.forEach(e=>{t=t.concat(hS(e))}),t.length<=55)return t.unshift(192+t.length),t;const r=lS(t.length);return r.unshift(247+r.length),r.concat(t)}var t;iS(t=e)&&!(t.length%2)||nS(t)||cS.throwArgumentError("RLP object must be BytesLike","object",e);const r=[].slice.call(sS(e));if(1===r.length&&r[0]<=127)return r;if(r.length<=55)return r.unshift(128+r.length),r;const n=lS(r.length);return n.unshift(183+n.length),n.concat(r)}function dS(e,t,r,n){const s=[];for(;r<t+1+n;){const i=pS(e,r);s.push(i.result),(r+=i.consumed)>t+1+n&&cS.throwError("child data too short",YE.errors.BUFFER_OVERRUN,{})}return{consumed:1+n,result:s}}function pS(e,t){if(0===e.length&&cS.throwError("data too short",YE.errors.BUFFER_OVERRUN,{}),e[t]>=248){const r=e[t]-247;t+1+r>e.length&&cS.throwError("data short segment too short",YE.errors.BUFFER_OVERRUN,{});const n=uS(e,t+1,r);return t+1+r+n>e.length&&cS.throwError("data long segment too short",YE.errors.BUFFER_OVERRUN,{}),dS(e,t,t+1+r,r+n)}if(e[t]>=192){const r=e[t]-192;return t+1+r>e.length&&cS.throwError("data array too short",YE.errors.BUFFER_OVERRUN,{}),dS(e,t,t+1,r)}if(e[t]>=184){const r=e[t]-183;t+1+r>e.length&&cS.throwError("data array too short",YE.errors.BUFFER_OVERRUN,{});const n=uS(e,t+1,r);t+1+r+n>e.length&&cS.throwError("data array too short",YE.errors.BUFFER_OVERRUN,{});return{consumed:1+r+n,result:aS(e.slice(t+1+r,t+1+r+n))}}if(e[t]>=128){const r=e[t]-128;t+1+r>e.length&&cS.throwError("data too short",YE.errors.BUFFER_OVERRUN,{});return{consumed:1+r,result:aS(e.slice(t+1,t+1+r))}}return{consumed:1,result:aS(e[t])}}const fS=new On("enr:decoder");class gS{static fromString(e){if(!e.startsWith(zE.RECORD_PREFIX))throw Error(`"string encoded ENR must start with '${zE.RECORD_PREFIX}'`);return gS.fromRLP(rt(e.slice(4),"base64url"))}static fromRLP(e){return async function(e){const{signature:t,seq:r,kvs:n}=function(e){if(!Array.isArray(e))throw Error("Decoded ENR must be an array");if(e.length%2!=0)throw Error("Decoded ENR must have an even number of elements");const[t,r,...n]=e;if(!t||Array.isArray(t))throw Error("Decoded ENR invalid signature: must be a byte array");if(!r||Array.isArray(r))throw Error("Decoded ENR invalid sequence number: must be a byte array");return{signature:t,seq:r,kvs:n}}(e),s={};for(let e=0;e<n.length;e+=2)try{s[dn(n[e])]=n[e+1]}catch(t){fS.error("Failed to decode ENR key to UTF-8, skipping it",n[e],t)}const i=function(e){return e.length?BigInt("0x"+hn(e)):BigInt(0)}(r),o=zE.create(s,i,t);return function(e,t,r,n){const s=un((i=[e,...t],aS(hS(i))));var i;if(!r.verify(s,n))throw Error("Unable to verify ENR signature")}(r,n,o,t),o}(function(e){const t=sS(e),r=pS(t,0);return r.consumed!==t.length&&cS.throwArgumentError("invalid rlp data","data",e),r.result}(e).map(un))}}class mS extends Map{#N=0;#O=new Map;#U=new Map;#F;#B;#q;constructor(e={}){if(super(),!(e.maxSize&&e.maxSize>0))throw new TypeError("`maxSize` must be a number greater than 0");if("number"==typeof e.maxAge&&0===e.maxAge)throw new TypeError("`maxAge` must be a number greater than 0");this.#F=e.maxSize,this.#B=e.maxAge||1/0,this.#q=e.onEviction}get __oldCache(){return this.#U}#$(e){if("function"==typeof this.#q)for(const[t,r]of e)this.#q(t,r.value)}#z(e,t){return"number"==typeof t.expiry&&t.expiry<=Date.now()&&("function"==typeof this.#q&&this.#q(e,t.value),this.delete(e))}#K(e,t){if(!1===this.#z(e,t))return t.value}#V(e,t){return t.expiry?this.#K(e,t):t.value}#H(e,t){const r=t.get(e);return this.#V(e,r)}#j(e,t){this.#O.set(e,t),this.#N++,this.#N>=this.#F&&(this.#N=0,this.#$(this.#U),this.#U=this.#O,this.#O=new Map)}#G(e,t){this.#U.delete(e),this.#j(e,t)}*#W(){for(const e of this.#U){const[t,r]=e;if(!this.#O.has(t)){!1===this.#z(t,r)&&(yield e)}}for(const e of this.#O){const[t,r]=e;!1===this.#z(t,r)&&(yield e)}}get(e){if(this.#O.has(e)){const t=this.#O.get(e);return this.#V(e,t)}if(this.#U.has(e)){const t=this.#U.get(e);if(!1===this.#z(e,t))return this.#G(e,t),t.value}}set(e,t,{maxAge:r=this.#B}={}){const n="number"==typeof r&&r!==1/0?Date.now()+r:void 0;return this.#O.has(e)?this.#O.set(e,{value:t,expiry:n}):this.#j(e,{value:t,expiry:n}),this}has(e){return this.#O.has(e)?!this.#z(e,this.#O.get(e)):!!this.#U.has(e)&&!this.#z(e,this.#U.get(e))}peek(e){return this.#O.has(e)?this.#H(e,this.#O):this.#U.has(e)?this.#H(e,this.#U):void 0}expiresIn(e){const t=this.#O.get(e)??this.#U.get(e);if(t)return t.expiry?t.expiry-Date.now():1/0}delete(e){const t=this.#O.delete(e);return t&&this.#N--,this.#U.delete(e)||t}clear(){this.#O.clear(),this.#U.clear(),this.#N=0}resize(e){if(!(e&&e>0))throw new TypeError("`maxSize` must be a number greater than 0");const t=[...this.#W()],r=t.length-e;r<0?(this.#O=new Map(t),this.#U=new Map,this.#N=t.length):(r>0&&this.#$(t.slice(0,r)),this.#U=new Map(t.slice(r)),this.#O=new Map,this.#N=0),this.#F=e}*keys(){for(const[e]of this)yield e}*values(){for(const[,e]of this)yield e}*[Symbol.iterator](){for(const e of this.#O){const[t,r]=e;!1===this.#z(t,r)&&(yield[t,r.value])}for(const e of this.#U){const[t,r]=e;if(!this.#O.has(t)){!1===this.#z(t,r)&&(yield[t,r.value])}}}*entriesDescending(){let e=[...this.#O];for(let t=e.length-1;t>=0;--t){const r=e[t],[n,s]=r;!1===this.#z(n,s)&&(yield[n,s.value])}e=[...this.#U];for(let t=e.length-1;t>=0;--t){const r=e[t],[n,s]=r;if(!this.#O.has(n)){!1===this.#z(n,s)&&(yield[n,s.value])}}}*entriesAscending(){for(const[e,t]of this.#W())yield[e,t.value]}get size(){if(!this.#N)return this.#U.size;let e=0;for(const t of this.#U.keys())this.#O.has(t)||e++;return Math.min(this.#N+e,this.#F)}get maxSize(){return this.#F}entries(){return this.entriesAscending()}forEach(e,t=this){for(const[r,n]of this.entriesAscending())e.call(t,n,r,this)}get[Symbol.toStringTag](){return"QuickLRU"}toString(){return`QuickLRU(${this.size}/${this.maxSize})`}[Symbol.for("nodejs.util.inspect.custom")](){return this.toString()}}function yS(e,t,r){return`${e}?name=${t}&type=${r}`}async function bS(e,t){const r=await fetch(e,{headers:new Headers({accept:"application/dns-json"}),signal:t});return await r.json()}function wS(e,t){return`${t}_${e}`}const vS=Object.assign(Vg("dns-over-http-resolver"),{error:Vg("dns-over-http-resolver:error")});class ES{_cache;_TXTcache;_servers;_request;_abortControllers;constructor(e={}){this._cache=new mS({maxSize:e?.maxCache??100}),this._TXTcache=new mS({maxSize:e?.maxCache??100}),this._servers=["https://cloudflare-dns.com/dns-query","https://dns.google/resolve"],this._request=e.request??bS,this._abortControllers=[]}cancel(){this._abortControllers.forEach(e=>{e.abort()})}getServers(){return this._servers}_getShuffledServers(){const e=[...this._servers];for(let t=e.length-1;t>0;t--){const r=Math.floor(Math.random()*t),n=e[t];e[t]=e[r],e[r]=n}return e}setServers(e){this._servers=e}async resolve(e,t="A"){switch(t){case"A":return this.resolve4(e);case"AAAA":return this.resolve6(e);case"TXT":return this.resolveTxt(e);default:throw Error(t+" is not supported")}}async resolve4(e){const t="A",r=this._cache.get(wS(e,t));if(null!=r)return r;let n=!1;for(const r of this._getShuffledServers()){const s=new AbortController;this._abortControllers.push(s);try{const n=await this._request(yS(r,e,t),s.signal),i=n.Answer.map(e=>e.data),o=Math.min(...n.Answer.map(e=>e.TTL));return this._cache.set(wS(e,t),i,{maxAge:o}),i}catch(i){s.signal.aborted&&(n=!0),vS.error(`${r} could not resolve ${e} record ${t}`)}finally{this._abortControllers=this._abortControllers.filter(e=>e!==s)}}if(n)throw Object.assign(Error("queryA ECANCELLED"),{code:"ECANCELLED"});throw Error(`Could not resolve ${e} record ${t}`)}async resolve6(e){const t="AAAA",r=this._cache.get(wS(e,t));if(null!=r)return r;let n=!1;for(const r of this._getShuffledServers()){const s=new AbortController;this._abortControllers.push(s);try{const n=await this._request(yS(r,e,t),s.signal),i=n.Answer.map(e=>e.data),o=Math.min(...n.Answer.map(e=>e.TTL));return this._cache.set(wS(e,t),i,{maxAge:o}),i}catch(i){s.signal.aborted&&(n=!0),vS.error(`${r} could not resolve ${e} record ${t}`)}finally{this._abortControllers=this._abortControllers.filter(e=>e!==s)}}if(n)throw Object.assign(Error("queryAaaa ECANCELLED"),{code:"ECANCELLED"});throw Error(`Could not resolve ${e} record ${t}`)}async resolveTxt(e){const t="TXT",r=this._TXTcache.get(wS(e,t));if(null!=r)return r;let n=!1;for(const r of this._getShuffledServers()){const s=new AbortController;this._abortControllers.push(s);try{const n=await this._request(yS(r,e,t),s.signal),i=n.Answer.map(e=>[e.data.replace(/['"]+/g,"")]),o=Math.min(...n.Answer.map(e=>e.TTL));return this._TXTcache.set(wS(e,t),i,{maxAge:o}),i}catch(i){s.signal.aborted&&(n=!0),vS.error(`${r} could not resolve ${e} record ${t}`)}finally{this._abortControllers=this._abortControllers.filter(e=>e!==s)}}if(n)throw Object.assign(Error("queryTxt ECANCELLED"),{code:"ECANCELLED"});throw Error(`Could not resolve ${e} record ${t}`)}clearCache(){this._cache.clear(),this._TXTcache.clear()}}const SS=new On("dns-over-https");class AS{resolver;static async create(){return new AS}constructor(e=new ES){this.resolver=e}async resolveTXT(e){let t;try{t=await this.resolver.resolveTxt(e)}catch(e){throw SS.error("query failed: ",e),Error("DNS query failed")}if(!t)throw Error("Could not resolve "+e);const r=[];return t.forEach(e=>{"string"==typeof e?r.push(e):Array.isArray(e)?e.forEach(e=>{"string"==typeof e?r.push(e):r.push(dn(e))}):r.push(dn(e))}),r}}var IS,CS={exports:{}};var xS=(IS||(IS=1,(e=>{(()=>{var t="object"==typeof window?window:{};!t.HI_BASE32_NO_NODE_JS&&"object"==typeof process&&process.versions&&process.versions.node&&(t=In);var r=!t.HI_BASE32_NO_COMMON_JS&&e.exports,n="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split(""),s={A:0,B:1,C:2,D:3,E:4,F:5,G:6,H:7,I:8,J:9,K:10,L:11,M:12,N:13,O:14,P:15,Q:16,R:17,S:18,T:19,U:20,V:21,W:22,X:23,Y:24,Z:25,2:26,3:27,4:28,5:29,6:30,7:31},i=[0,0,0,0,0,0,0,0],o=(e,t)=>{t.length>10&&(t="..."+t.substr(-10));var r=Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading "+e+" bytes: "+t+" <-");throw r.position=e,r},a=e=>{if(""===e)return[];if(!/^[A-Z2-7=]+$/.test(e))throw Error("Invalid base32 characters");for(var t,r,n,i,o,a,c,l,u=[],h=0,d=(e=e.replace(/=/g,"")).length,p=0,f=d>>3<<3;p<f;)t=s[e.charAt(p++)],r=s[e.charAt(p++)],n=s[e.charAt(p++)],i=s[e.charAt(p++)],o=s[e.charAt(p++)],a=s[e.charAt(p++)],c=s[e.charAt(p++)],l=s[e.charAt(p++)],u[h++]=255&(t<<3|r>>>2),u[h++]=255&(r<<6|n<<1|i>>>4),u[h++]=255&(i<<4|o>>>1),u[h++]=255&(o<<7|a<<2|c>>>3),u[h++]=255&(c<<5|l);var g=d-f;return 2===g?(t=s[e.charAt(p++)],r=s[e.charAt(p++)],u[h++]=255&(t<<3|r>>>2)):4===g?(t=s[e.charAt(p++)],r=s[e.charAt(p++)],n=s[e.charAt(p++)],i=s[e.charAt(p++)],u[h++]=255&(t<<3|r>>>2),u[h++]=255&(r<<6|n<<1|i>>>4)):5===g?(t=s[e.charAt(p++)],r=s[e.charAt(p++)],n=s[e.charAt(p++)],i=s[e.charAt(p++)],o=s[e.charAt(p++)],u[h++]=255&(t<<3|r>>>2),u[h++]=255&(r<<6|n<<1|i>>>4),u[h++]=255&(i<<4|o>>>1)):7===g&&(t=s[e.charAt(p++)],r=s[e.charAt(p++)],n=s[e.charAt(p++)],i=s[e.charAt(p++)],o=s[e.charAt(p++)],a=s[e.charAt(p++)],c=s[e.charAt(p++)],u[h++]=255&(t<<3|r>>>2),u[h++]=255&(r<<6|n<<1|i>>>4),u[h++]=255&(i<<4|o>>>1),u[h++]=255&(o<<7|a<<2|c>>>3)),u},c=(e,t)=>{if(!t)return(e=>{for(var t,r,n="",s=e.length,i=0,a=0;i<s;)if((t=e[i++])<=127)n+=String.fromCharCode(t);else{t>191&&t<=223?(r=31&t,a=1):t<=239?(r=15&t,a=2):t<=247?(r=7&t,a=3):o(i,n);for(var c=0;c<a;++c)((t=e[i++])<128||t>191)&&o(i,n),r<<=6,r+=63&t;r>=55296&&r<=57343&&o(i,n),r>1114111&&o(i,n),r<=65535?n+=String.fromCharCode(r):(n+=String.fromCharCode(55296+((r-=65536)>>10)),n+=String.fromCharCode(56320+(1023&r)))}return n})(a(e));if(""===e)return"";if(!/^[A-Z2-7=]+$/.test(e))throw Error("Invalid base32 characters");var r,n,i,c,l,u,h,d,p="",f=e.indexOf("=");-1===f&&(f=e.length);for(var g=0,m=f>>3<<3;g<m;)r=s[e.charAt(g++)],n=s[e.charAt(g++)],i=s[e.charAt(g++)],c=s[e.charAt(g++)],l=s[e.charAt(g++)],u=s[e.charAt(g++)],h=s[e.charAt(g++)],d=s[e.charAt(g++)],p+=String.fromCharCode(255&(r<<3|n>>>2))+String.fromCharCode(255&(n<<6|i<<1|c>>>4))+String.fromCharCode(255&(c<<4|l>>>1))+String.fromCharCode(255&(l<<7|u<<2|h>>>3))+String.fromCharCode(255&(h<<5|d));var y=f-m;return 2===y?(r=s[e.charAt(g++)],n=s[e.charAt(g++)],p+=String.fromCharCode(255&(r<<3|n>>>2))):4===y?(r=s[e.charAt(g++)],n=s[e.charAt(g++)],i=s[e.charAt(g++)],c=s[e.charAt(g++)],p+=String.fromCharCode(255&(r<<3|n>>>2))+String.fromCharCode(255&(n<<6|i<<1|c>>>4))):5===y?(r=s[e.charAt(g++)],n=s[e.charAt(g++)],i=s[e.charAt(g++)],c=s[e.charAt(g++)],l=s[e.charAt(g++)],p+=String.fromCharCode(255&(r<<3|n>>>2))+String.fromCharCode(255&(n<<6|i<<1|c>>>4))+String.fromCharCode(255&(c<<4|l>>>1))):7===y&&(r=s[e.charAt(g++)],n=s[e.charAt(g++)],i=s[e.charAt(g++)],c=s[e.charAt(g++)],l=s[e.charAt(g++)],u=s[e.charAt(g++)],h=s[e.charAt(g++)],p+=String.fromCharCode(255&(r<<3|n>>>2))+String.fromCharCode(255&(n<<6|i<<1|c>>>4))+String.fromCharCode(255&(c<<4|l>>>1))+String.fromCharCode(255&(l<<7|u<<2|h>>>3))),p},l={encode(e,t){var r="string"!=typeof e;return r&&e.constructor===ArrayBuffer&&(e=new Uint8Array(e)),r?(e=>{for(var t,r,s,i,o,a="",c=e.length,l=0,u=5*parseInt(c/5);l<u;)t=e[l++],r=e[l++],s=e[l++],i=e[l++],o=e[l++],a+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[31&(r<<4|s>>>4)]+n[31&(s<<1|i>>>7)]+n[i>>>2&31]+n[31&(i<<3|o>>>5)]+n[31&o];var h=c-u;return 1===h?(t=e[l],a+=n[t>>>3]+n[t<<2&31]+"======"):2===h?(t=e[l++],r=e[l],a+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[r<<4&31]+"===="):3===h?(t=e[l++],r=e[l++],s=e[l],a+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[31&(r<<4|s>>>4)]+n[s<<1&31]+"==="):4===h&&(t=e[l++],r=e[l++],s=e[l++],i=e[l],a+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[31&(r<<4|s>>>4)]+n[31&(s<<1|i>>>7)]+n[i>>>2&31]+n[i<<3&31]+"="),a})(e):t?(e=>{for(var t,r,s,i,o,a="",c=e.length,l=0,u=5*parseInt(c/5);l<u;)t=e.charCodeAt(l++),r=e.charCodeAt(l++),s=e.charCodeAt(l++),i=e.charCodeAt(l++),o=e.charCodeAt(l++),a+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[31&(r<<4|s>>>4)]+n[31&(s<<1|i>>>7)]+n[i>>>2&31]+n[31&(i<<3|o>>>5)]+n[31&o];var h=c-u;return 1===h?(t=e.charCodeAt(l),a+=n[t>>>3]+n[t<<2&31]+"======"):2===h?(t=e.charCodeAt(l++),r=e.charCodeAt(l),a+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[r<<4&31]+"===="):3===h?(t=e.charCodeAt(l++),r=e.charCodeAt(l++),s=e.charCodeAt(l),a+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[31&(r<<4|s>>>4)]+n[s<<1&31]+"==="):4===h&&(t=e.charCodeAt(l++),r=e.charCodeAt(l++),s=e.charCodeAt(l++),i=e.charCodeAt(l),a+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[31&(r<<4|s>>>4)]+n[31&(s<<1|i>>>7)]+n[i>>>2&31]+n[i<<3&31]+"="),a})(e):(e=>{var t,r,s,o,a,c,l,u=!1,h="",d=0,p=0,f=e.length;if(""===e)return h;do{for(i[0]=i[5],i[1]=i[6],i[2]=i[7],l=p;d<f&&l<5;++d)(c=e.charCodeAt(d))<128?i[l++]=c:c<2048?(i[l++]=192|c>>6,i[l++]=128|63&c):c<55296||c>=57344?(i[l++]=224|c>>12,i[l++]=128|c>>6&63,i[l++]=128|63&c):(c=65536+((1023&c)<<10|1023&e.charCodeAt(++d)),i[l++]=240|c>>18,i[l++]=128|c>>12&63,i[l++]=128|c>>6&63,i[l++]=128|63&c);p=l-5,d===f&&++d,d>f&&l<6&&(u=!0),t=i[0],l>4?(r=i[1],s=i[2],o=i[3],a=i[4],h+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[31&(r<<4|s>>>4)]+n[31&(s<<1|o>>>7)]+n[o>>>2&31]+n[31&(o<<3|a>>>5)]+n[31&a]):1===l?h+=n[t>>>3]+n[t<<2&31]+"======":2===l?(r=i[1],h+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[r<<4&31]+"===="):3===l?(r=i[1],s=i[2],h+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[31&(r<<4|s>>>4)]+n[s<<1&31]+"==="):(r=i[1],s=i[2],o=i[3],h+=n[t>>>3]+n[31&(t<<2|r>>>6)]+n[r>>>1&31]+n[31&(r<<4|s>>>4)]+n[31&(s<<1|o>>>7)]+n[o>>>2&31]+n[o<<3&31]+"=")}while(!u);return h})(e)},decode:c};c.asBytes=a,r?e.exports=l:t.base32=l})()})(CS)),CS.exports),kS=Cn(xS);class TS{static RECORD_PREFIX=zE.RECORD_PREFIX;static TREE_PREFIX="enrtree:";static BRANCH_PREFIX="enrtree-branch:";static ROOT_PREFIX="enrtree-root:";static parseAndVerifyRoot(e,t){if(!e.startsWith(this.ROOT_PREFIX))throw Error(`ENRTree root entry must start with '${this.ROOT_PREFIX}'`);const r=TS.parseRootValues(e),n=kS.decode.asBytes(t),s=e.split(" sig")[0],i=pn(s);if(!Bv(rt(r.signature,"base64url").slice(0,64),Fv(i),new Uint8Array(n)))throw Error("Unable to verify ENRTree root signature");return r.eRoot}static parseRootValues(e){const t=e.match(/^enrtree-root:v1 e=([^ ]+) l=([^ ]+) seq=(\d+) sig=([^ ]+)$/);if(!Array.isArray(t))throw Error("Could not parse ENRTree root entry");t.shift();const[r,n,s,i]=t;if(!r)throw Error("Could not parse 'e' value from ENRTree root entry");if(!n)throw Error("Could not parse 'l' value from ENRTree root entry");if(!s)throw Error("Could not parse 'seq' value from ENRTree root entry");if(!i)throw Error("Could not parse 'sig' value from ENRTree root entry");return{eRoot:r,lRoot:n,seq:Number(s),signature:i}}static parseTree(e){if(!e.startsWith(this.TREE_PREFIX))throw Error(`ENRTree tree entry must start with '${this.TREE_PREFIX}'`);const t=e.match(/^enrtree:\/\/([^@]+)@(.+)$/);if(!Array.isArray(t))throw Error("Could not parse ENRTree tree entry");t.shift();const[r,n]=t;if(!r)throw Error("Could not parse public key from ENRTree tree entry");if(!n)throw Error("Could not parse domain from ENRTree tree entry");return{publicKey:r,domain:n}}static parseBranch(e){if(!e.startsWith(this.BRANCH_PREFIX))throw Error(`ENRTree branch entry must start with '${this.BRANCH_PREFIX}'`);return e.split(this.BRANCH_PREFIX)[1].split(",")}}const PS=new On("discovery:fetch_nodes");async function*_S(e,t=10,r=3){const n=new Set;let s=0,i=0;for(;s<t&&i<r;){s++;const t=await e();t&&t.nodeId?n.has(t.nodeId)||(n.add(t.nodeId),t.waku2&&(yield t),PS.info(`got new peer candidate from DNS address=${t.nodeId}@${t.ip}`)):i++}}const RS=new On("discovery:dns");class LS{dns;_DNSTreeCache;static async dnsOverHttp(e){return e||(e=await AS.create()),new LS(e)}constructor(e){this._DNSTreeCache={},this.dns=e}async*getNextPeer(e){for(const t of function(e){if(e.length<=1)return e;const t=()=>Math.floor(Math.random()*Math.floor(e.length));for(let r=0;r<e.length;r++){const n=t(),s=e[r];e[r]=e[n],e[n]=s}return e}(e)){const{publicKey:e,domain:r}=TS.parseTree(t),n={domain:r,publicKey:e,visits:{}};for await(const e of _S(()=>this._search(r,n)))yield e}}async _search(e,t){try{const r=await this._getTXTRecord(e,t);let n,s;t.visits[e]=!0;const i=function(e){return e.startsWith(TS.ROOT_PREFIX)?TS.ROOT_PREFIX:e.startsWith(TS.BRANCH_PREFIX)?TS.BRANCH_PREFIX:e.startsWith(TS.RECORD_PREFIX)?TS.RECORD_PREFIX:""}(r);try{switch(i){case TS.ROOT_PREFIX:return n=TS.parseAndVerifyRoot(r,t.publicKey),await this._search(n,t);case TS.BRANCH_PREFIX:return s=TS.parseBranch(r),n=function(e,t){const r={};for(const[n,s]of e.entries())t.visits[s]&&(r[n]=!0);if(Object.keys(r).length===e.length)throw Error("Unresolvable circular path detected");let n;do{n=Math.floor(Math.random()*e.length)}while(r[n]);return e[n]}(s,t),await this._search(n,t);case TS.RECORD_PREFIX:return gS.fromString(r);default:return null}}catch(t){return RS.error(`Failed to search DNS tree ${i} at subdomain ${e}: ${t}`),null}}catch(t){return RS.error(`Failed to retrieve TXT record at subdomain ${e}: ${t}`),null}}async _getTXTRecord(e,t){if(this._DNSTreeCache[e])return this._DNSTreeCache[e];const r=e!==t.domain?`${e}.${t.domain}`:t.domain,n=await this.dns.resolveTXT(r);if(!n.length)throw Error("Received empty result array while fetching TXT record");if(!n[0].length)throw Error("Received empty TXT record");const s=n.join("");return this._DNSTreeCache[e]=s,s}}const DS=new On("peer-discovery-dns");class MS extends Yi{nextPeer;_started;_components;_options;constructor(e,t){super(),this._started=!1,this._components=e,this._options=t;const{enrUrls:r}=t;DS.info("Use following EIP-1459 ENR Tree URLs: ",r)}async start(){DS.info("Starting peer discovery via dns"),this._started=!0,await this.findPeers()}async findPeers(){if(!this.nextPeer){let{enrUrls:e}=this._options;Array.isArray(e)||(e=[e]);const t=await LS.dnsOverHttp();this.nextPeer=t.getNextPeer.bind(t,e)}for await(const e of this.nextPeer()){if(!this._started)return;const{peerInfo:t,shardInfo:r}=e;if(!t)continue;const n={[xw]:{value:this._options.tagValue??50,ttl:this._options.tagTTL??1e8}};let s=!1;if(await this._components.peerStore.has(t.id)){(await this._components.peerStore.get(t.id)).tags.has(xw)||(s=!0,await this._components.peerStore.merge(t.id,{tags:n}))}else s=!0,await this._components.peerStore.save(t.id,{tags:n,...r&&{metadata:{shardInfo:An(r)}}});s&&this.dispatchEvent(new CustomEvent("peer",{detail:t}))}}stop(){this._started=!1}get[wi](){return!0}get[Symbol.toStringTag](){return"@waku/bootstrap"}}const NS=jn.PEER_EXCHANGE,OS="/vac/waku/peer-exchange/2.0.0-alpha1";class US{proto;constructor(e){this.proto=e}static createRequest(e){const{numPeers:t}=e;return new US({query:{numPeers:t},response:void 0})}encode(){return jt.encode(this.proto)}static decode(e){const t=jt.decode(e);return new US(t)}get query(){return this.proto.query}get response(){return this.proto.response}}const FS=new On("peer-exchange");class BS{components;streamManager;constructor(e){this.components=e,this.streamManager=new Ds(OS,e)}async query(e){const{numPeers:t,peerId:r}=e,n=US.createRequest({numPeers:BigInt(t)});if(!await this.components.peerStore.has(r))return{peerInfos:null,error:Hn.NO_PEER_AVAILABLE};const s=await this.streamManager.getStream(r);if(!s)return FS.error("Failed to get a stream for remote peer:"+r?.toString?.()),{peerInfos:null,error:Hn.NO_STREAM_AVAILABLE};const i=await Cs([n.encode()],is,s,ds,async e=>await Zn(e));try{const e=new rs;i.forEach(t=>{e.append(t)});const{response:t}=US.decode(e);if(!t)return FS.error("PeerExchangeRPC message did not contains a `response` field"),{peerInfos:null,error:Hn.EMPTY_PAYLOAD};return{peerInfos:await Promise.all(t.peerInfos.map(e=>e.enr).filter(rr).map(async e=>({ENR:await gS.fromRLP(e)}))),error:null}}catch(e){return FS.error("Failed to decode push reply",e),{peerInfos:null,error:Hn.DECODE_FAILED}}}}const qS=new On("peer-exchange-discovery");class $S extends Yi{components;peerExchange;options;isStarted=!1;queryingPeers=new Set;peerExpirationRecords=new Map;continuousDiscoveryInterval=null;constructor(e,t={}){super(),this.components=e,this.peerExchange=new BS(e),this.options={...t,TTL:t.TTL??3e4},this.handleDiscoveredPeer=this.handleDiscoveredPeer.bind(this)}start(){this.isStarted||(qS.info("Starting peer exchange node discovery, discovering peers"),this.isStarted=!0,this.components.events.addEventListener("peer:identify",this.handleDiscoveredPeer),this.continuousDiscoveryInterval=setInterval(()=>{this.handlePeriodicDiscovery()},this.options.TTL))}stop(){this.isStarted&&(qS.info("Stopping peer exchange node discovery"),this.isStarted=!1,this.queryingPeers.clear(),this.peerExpirationRecords.clear(),this.continuousDiscoveryInterval&&clearInterval(this.continuousDiscoveryInterval),this.components.events.removeEventListener("peer:identify",this.handleDiscoveredPeer))}get[wi](){return!0}get[Symbol.toStringTag](){return"@waku/peer-exchange"}async handleDiscoveredPeer(e){this.runQuery(e.detail.peerId,e.detail.protocols)}async handlePeriodicDiscovery(){const e=this.components.connectionManager.getConnections();await Promise.all(e.map(async e=>{try{const t=e.remotePeer.toString();if(!(!this.peerExpirationRecords.has(t)||this.peerExpirationRecords.get(t)<=Date.now()))return null;const r=await this.components.peerStore.get(e.remotePeer);return this.runQuery(e.remotePeer,r.protocols)}catch(e){return qS.warn("Error getting peer info",e),null}}))}async runQuery(e,t){if(t.includes(OS)&&!this.queryingPeers.has(e.toString())){try{this.queryingPeers.add(e.toString()),await this.query(e)}catch(e){qS.error("Error querying peer",e)}this.peerExpirationRecords.set(e.toString(),Date.now()+this.options.TTL),this.queryingPeers.delete(e.toString())}else qS.info(`Skipping peer ${e} as it is already querying or does not support peer exchange`)}async query(e){const t=e.toString();qS.info("Querying peer exchange for "+t);const{error:r,peerInfos:n}=await this.peerExchange.query({numPeers:60,peerId:e});if(r)qS.error(`Peer exchange query to ${t} failed`,r);else for(const{ENR:e}of n){if(!e){qS.warn(`No ENR in peerInfo object from ${t}, skipping`);continue}const{peerInfo:r,shardInfo:n}=e;if(!r){qS.warn(`No peerInfo in ENR from ${t}, skipping`);continue}const s=!await this.hasShardInfo(r.id)&&n?{metadata:{shardInfo:An(n)}}:void 0;await this.components.peerStore.merge(r.id,{tags:{[NS]:{value:50}},...s,...r.multiaddrs&&{multiaddrs:r.multiaddrs}}),qS.info("Discovered peer: "+r.id.toString()),this.dispatchEvent(new CustomEvent("peer",{detail:{id:r.id,multiaddrs:r.multiaddrs}}))}}async hasShardInfo(e){try{const t=await this.components.peerStore.get(e);return!!t&&t.metadata.has("shardInfo")}catch(t){qS.warn("Error getting shard info for "+e.toString(),t)}return!1}}function zS(e={}){return t=>new $S(t,e)}const KS=jn.PEER_CACHE,VS=e=>!!e&&"object"==typeof e&&"id"in e&&"string"==typeof e.id&&"multiaddrs"in e&&Array.isArray(e.multiaddrs);class HS{get(){return[]}set(e){}remove(){}}class jS{get(){try{const e=localStorage.getItem("waku:peers");return(e?JSON.parse(e):[]).filter(VS)}catch(e){return[]}}set(e){try{localStorage.setItem("waku:peers",JSON.stringify(e))}catch(e){}}remove(){try{localStorage.removeItem("waku:peers")}catch(e){}}}const GS=new On("peer-cache");class WS extends Yi{components;isStarted=!1;cache;constructor(e,t){super(),this.components=e,this.cache=t?.cache??(()=>{try{if("undefined"!=typeof localStorage)return new jS}catch(e){}return new HS})()}get[Symbol.toStringTag](){return"@waku/"+KS}async start(){this.isStarted||(GS.info("Starting Peer Cache Discovery"),this.components.events.addEventListener("peer:identify",this.handleDiscoveredPeer),await this.discoverPeers(),this.isStarted=!0)}stop(){this.isStarted&&(GS.info("Stopping Peer Cache Discovery"),this.components.events.removeEventListener("peer:identify",this.handleDiscoveredPeer),this.isStarted=!1)}handleDiscoveredPeer=e=>{const{peerId:t,listenAddrs:r}=e.detail,n=r.map(e=>e.toString()),s=t.toString(),i=this.readPeerInfoFromCache(),o=i.findIndex(e=>e.id===s);-1!==o?i[o].multiaddrs=n:i.push({id:s,multiaddrs:n}),this.writePeerInfoToCache(i)};async discoverPeers(){const e=this.readPeerInfoFromCache();for(const t of e){const e=nl(t.id),r=t.multiaddrs.map(e=>Zl(e));await this.components.peerStore.has(e)||(await this.components.peerStore.save(e,{multiaddrs:r,tags:{[KS]:{value:50}}}),this.dispatchEvent(new CustomEvent("peer",{detail:{id:e,multiaddrs:r}})))}}readPeerInfoFromCache(){try{return this.cache.get()}catch(e){return GS.error("Error parsing peers from cache:",e),[]}}writePeerInfoToCache(e){try{this.cache.set(e)}catch(e){GS.error("Error saving peers to cache:",e)}}}function XS(e,t){const r=[Iw,Cw],n=[];var s;return e?.dns&&n.push((s=r,e=>new MS(e,{enrUrls:s}))),(e?.peerCache||t)&&n.push(function(e={}){return t=>new WS(t,e)}({cache:t})),e?.peerExchange&&n.push(zS()),n}const ZS=new On("sdk:create");async function QS(e,t,r){!t?.hideWebSocketInfo&&Aw();return async function(e={}){e.privateKey??=await Wc();const t=new Sw({...await Pg(e),peerId:(r=e.privateKey,sl(r.publicKey))});var r;return!1!==e.start&&await t.start(),t}({transports:[Kf({filter:!1===t?.filterMultiaddrs||Aw()?qf:$f})],streamMuxers:[yf()],connectionEncrypters:[Jh()],...t,services:{identify:Kp({agentVersion:r??"js-waku"}),ping:wf({maxInboundStreams:t?.pingMaxInboundStreams??10}),metadata:su(e),...t?.services}})}async function YS(e){const t=(e.networkConfig??Wn).clusterId??1;ZS.info("Creating Waku node with cluster id: ",t);const r=e?.libp2p??{},n=r.peerDiscovery??[];e?.defaultBootstrap?n.push(...XS({dns:!0,peerExchange:!0,peerCache:!0,...e.discovery},e.peerCache)):n.push(...XS(e.discovery,e.peerCache));const s=[...e.bootstrapPeers||[],...e.store?.peers||[]];var i;return s.length&&n.push((i={list:s},e=>new Ld(e,i))),r.peerDiscovery=n,QS(t,r,e?.userAgent)}const{floor:JS,random:eA}=Math,tA="Trystero",rA=(e,t)=>Array(e).fill().map(t),nA="0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",sA=(e=>rA(e,()=>nA[JS(62*eA())]).join(""))(20),iA=Promise.all.bind(Promise),oA="undefined"!=typeof window,{entries:aA,fromEntries:cA,keys:lA}=Object,uA=()=>{},hA=e=>Error(`${tA}: ${e}`),dA=new TextEncoder,pA=new TextDecoder,fA=e=>dA.encode(e),gA=e=>pA.decode(e),mA=(...e)=>e.join("@"),yA=JSON.stringify,bA=JSON.parse,wA="AES-GCM",vA={},EA=async e=>vA[e]||=Array.from(await(async(e,t)=>new Uint8Array(await crypto.subtle.digest(e,fA(t))))("SHA-1",e)).map(e=>e.toString(36)).join(""),SA=async(e,t)=>{const r=crypto.getRandomValues(new Uint8Array(16));return r.join(",")+"$"+(n=await crypto.subtle.encrypt({name:wA,iv:r},await e,fA(t)),btoa(String.fromCharCode.apply(null,new Uint8Array(n))));var n},AA=async(e,t)=>{if(!t||"string"!=typeof t||!t.includes("$"))throw Error("Invalid encrypted data format");const[r,n]=t.split("$");if(!r||!n)throw Error("Missing IV or ciphertext in encrypted data");return gA(await crypto.subtle.decrypt({name:wA,iv:new Uint8Array(r.split(","))},await e,(e=>{const t=atob(e);return new Uint8Array(t.length).map((e,r)=>t.charCodeAt(r)).buffer})(n)))},IA="icegatheringstatechange",CA="offer";var xA=(e,{rtcConfig:t,rtcPolyfill:r,turnConfig:n})=>{const s=new(r||RTCPeerConnection)({iceServers:kA.concat(n||[]),...t}),i={};let o=!1,a=!1,c=null;const l=e=>{e.binaryType="arraybuffer",e.bufferedAmountLowThreshold=65535,e.onmessage=e=>i.data?.(e.data),e.onopen=()=>i.connect?.(),e.onclose=()=>i.close?.(),e.onerror=e=>i.error?.(e)},u=e=>Promise.race([new Promise(t=>{const r=()=>{"complete"===e.iceGatheringState&&(e.removeEventListener(IA,r),t())};e.addEventListener(IA,r),r()}),new Promise(e=>setTimeout(e,5e3))]).then(()=>({type:e.localDescription.type,sdp:e.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")}));return e?(c=s.createDataChannel("data"),l(c)):s.ondatachannel=({channel:e})=>{c=e,l(e)},s.onnegotiationneeded=async()=>{try{o=!0,await s.setLocalDescription();const e=await u(s);i.signal?.(e)}catch(e){i.error?.(e)}finally{o=!1}},s.onconnectionstatechange=()=>{["disconnected","failed","closed"].includes(s.connectionState)&&i.close?.()},s.ontrack=e=>{i.track?.(e.track,e.streams[0]),i.stream?.(e.streams[0])},s.onremovestream=e=>i.stream?.(e.stream),e&&(s.canTrickleIceCandidates||s.onnegotiationneeded()),{created:Date.now(),connection:s,get channel(){return c},get isDead(){return"closed"===s.connectionState},async signal(t){if("open"!==c?.readyState||t.sdp?.includes("a=rtpmap"))try{if(t.type===CA){if(o||"stable"!==s.signalingState&&!a){if(e)return;await iA([s.setLocalDescription({type:"rollback"}),s.setRemoteDescription(t)])}else await s.setRemoteDescription(t);await s.setLocalDescription();const r=await u(s);return i.signal?.(r),r}if("answer"===t.type){a=!0;try{await s.setRemoteDescription(t)}finally{a=!1}}}catch(e){i.error?.(e)}},sendData(e){if(!c||"open"!==c.readyState)throw Error("Data channel is not available or not open");c.send(e)},destroy(){c?.close(),s.close(),o=!1,a=!1},setHandlers(e){return Object.assign(i,e)},offerPromise:e?new Promise(e=>i.signal=t=>{t.type===CA&&e(t)}):Promise.resolve(),addStream(e){return e.getTracks().forEach(t=>s.addTrack(t,e))},removeStream(e){return s.getSenders().filter(t=>e.getTracks().includes(t.track)).forEach(e=>s.removeTrack(e))},addTrack(e,t){return s.addTrack(e,t)},removeTrack(e){const t=s.getSenders().find(t=>t.track===e);t&&s.removeTrack(t)},replaceTrack(e,t){const r=s.getSenders().find(t=>t.track===e);if(r)return r.replaceTrack(t)}}};const kA=[...rA(3,(e,t)=>`stun:stun${t||""}.l.google.com:19302`),"stun:stun.cloudflare.com:3478"].map(e=>({urls:e})),TA=["none","error","warn","info","debug"],PA=(e={})=>{const{level:t="warn",prefix:r="Trystero"}=e||{},n=TA.includes(t)?TA.indexOf(t):TA.indexOf("warn"),s=e=>TA.indexOf(e)<=n&&n>0,i=e=>`[${r}:${e}]`;return{error(...e){return s("error")&&console.error(i("error"),...e)},warn(...e){return s("warn")&&console.warn(i("warn"),...e)},info(){return s("info")&&void 0},debug(...e){return s("debug")&&console.debug(i("debug"),...e)}}},_A=Object.getPrototypeOf(Uint8Array),RA=16369,LA=255,DA="bufferedamountlow",MA=e=>"@_"+e;var NA=(e,t,r,n)=>{const s=n||PA({level:"none"}),i={},o={},a={},c={},l={},u={},h={},d={onPeerJoin:uA,onPeerLeave:uA,onPeerStream:uA,onPeerTrack:uA},p=(e,t)=>(e?Array.isArray(e)?e:[e]:lA(i)).flatMap(e=>{const r=i[e];return r?t(e,r):(s.warn(`${tA}: no peer with id ${e} found`),[])}),f=e=>{i[e]&&(i[e].destroy(),delete i[e],delete c[e],delete l[e],d.onPeerLeave(e),t(e))},g=e=>{if(o[e])return a[e];if(!e)throw hA("action type argument is required");const t=fA(e);if(t.byteLength>12)throw hA(`action type string "${e}" (${t.byteLength}b) exceeds byte limit (12). Hint: choose a shorter name.`);const r=new Uint8Array(12);r.set(t);let n=0;return o[e]={onComplete:uA,onProgress:uA,setOnComplete(t){return o[e]={...o[e],onComplete:t}},setOnProgress(t){return o[e]={...o[e],onProgress:t}},async send(e,t,s,o){if(s&&"object"!=typeof s)throw hA("action meta argument must be an object");const a=typeof e;if("undefined"===a)throw hA("action data cannot be undefined");const c="string"!==a,l=e instanceof Blob,u=l||e instanceof ArrayBuffer||e instanceof _A;if(s&&!u)throw hA("action meta argument can only be used with binary data");const h=u?new Uint8Array(l?await e.arrayBuffer():e):fA(c?yA(e):e),d=s?fA(yA(s)):null,f=Math.ceil(h.byteLength/RA)+(s?1:0)||1,g=rA(f,(e,t)=>{const i=t===f-1,o=s&&0===t,a=new Uint8Array(15+(o?d.byteLength:i?h.byteLength-RA*(f-(s?2:1)):RA));return a.set(r),a.set([n],12),a.set([i|o<<1|u<<2|c<<3],13),a.set([Math.round((t+1)/f*LA)],14),a.set(s?o?d:h.subarray((t-1)*RA,t*RA):h.subarray(t*RA,(t+1)*RA),15),a});return n=n+1&LA,iA(p(t,async(e,t)=>{const{channel:r}=t;let n=0;for(;n<f;){const a=g[n];if(r.bufferedAmount>r.bufferedAmountLowThreshold&&await new Promise(e=>{const t=()=>{r.removeEventListener(DA,t),e()};r.addEventListener(DA,t)}),!i[e])break;t.sendData(a),n++,o?.(a[14]/LA,e,s)}}))}},a[e]||=[o[e].send,o[e].setOnComplete,o[e].setOnProgress]},m=async()=>{await k(""),await new Promise(e=>setTimeout(e,99)),aA(i).forEach(([e,t])=>{t.destroy(),delete i[e]}),r()},[y,b]=g(MA("ping")),[w,v]=g(MA("pong")),[E,S]=g(MA("signal")),[A,I]=g(MA("stream")),[C,x]=g(MA("track")),[k,T]=g(MA("leave"));return e((e,t)=>{i[t]||(i[t]=e,e.setHandlers({data(e){return((e,t)=>{const r=new Uint8Array(t),n=gA(r.subarray(0,12)).replaceAll("\0",""),[s]=r.subarray(12,13),[a]=r.subarray(13,14),[l]=r.subarray(14,15),u=r.subarray(15),h=!!(1&a),d=!!(2&a),p=!!(4&a),f=!!(8&a);if(!o[n])return void console.warn(`${tA}: received message with unregistered type (${n})`);if(!i[e])return;c[e]||={},c[e][n]||={};const g=c[e][n][s]||={chunks:[]};if(d?g.meta=bA(gA(u)):g.chunks.push(u),o[n].onProgress(l/LA,e,g.meta),!h)return;const m=new Uint8Array(g.chunks.reduce((e,t)=>e+t.byteLength,0));if(g.chunks.reduce((e,t)=>(m.set(t,e),e+t.byteLength),0),c[e]?.[n]&&delete c[e][n][s],p)o[n].onComplete(m,e,g.meta);else{const t=gA(m);o[n].onComplete(f?bA(t):t,e)}})(t,e)},stream(e){d.onPeerStream(e,t,u[t]),delete u[t]},track(e,r){d.onPeerTrack(e,r,t,h[t]),delete h[t]},signal(e){return E(e,t)},close(){return f(t)},error(e){s.error(e),f(t)}}),d.onPeerJoin(t))}),b((e,t)=>w("",t)),v((e,t)=>{l[t]?.(),delete l[t]}),S((e,t)=>i[t]?.signal(e)),I((e,t)=>u[t]=e),x((e,t)=>h[t]=e),T((e,t)=>f(t)),oA&&addEventListener("beforeunload",m),{makeAction:g,leave:m,async ping(e){if(!e)throw hA("ping() must be called with target peer ID");const t=Date.now();return y("",e),await new Promise(t=>l[e]=t),Date.now()-t},getPeers(){return cA(aA(i).map(([e,t])=>[e,t.connection]))},addStream(e,t,r){return p(t,async(t,n)=>{r&&await A(r,t),n.addStream(e)})},removeStream(e,t){return p(t,(t,r)=>r.removeStream(e))},addTrack(e,t,r,n){return p(r,async(r,s)=>{n&&await C(n,r),s.addTrack(e,t)})},removeTrack(e,t){return p(t,(t,r)=>r.removeTrack(e))},replaceTrack(e,t,r,n){return p(r,async(r,s)=>{n&&await C(n,r),s.replaceTrack(e,t)})},onPeerJoin(e){return d.onPeerJoin=e},onPeerLeave(e){return d.onPeerLeave=e},onPeerStream(e){return d.onPeerStream=e},onPeerTrack(e){return d.onPeerTrack=e}}};const OA="/waku/2/default-waku/proto",UA=e=>`/${tA}/0/${e}/json`,FA=(e,t,r)=>e.lightPush.send($n({contentTopic:UA(t),ephemeral:!0}),{payload:fA(r)}),BA=(({init:e,subscribe:t,announce:r})=>{const n={};let s,i,o,a=0,c=!1;return(l,u,h)=>{const d=(e=>{if(!e)throw hA("requires a config map as the first argument");const t={...e};return t.logger=PA(e.logger),t.rtcConfig||={},t})(l),{appId:p,logger:f}=d;if(n[p]?.[u])return n[p][u];const g={},m={},y=mA(tA,p,u),b=EA(y),w=EA(mA(y,sA)),v=(async(e,t,r)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},fA(`${e}:${t}:${r}`)),{name:wA},!1,["encrypt","decrypt"]))(d.password||"",p,u),E=e=>async t=>({type:t.type,sdp:await e(v,t.sdp)}),S=E(AA),A=E(SA),I=()=>xA(!0,d),C=(e,t,r)=>{m[t]?m[t]!==e&&e.destroy():(m[t]=e,D(e,t),g[t]?.forEach((e,t)=>{t!==r&&e.destroy()}),delete g[t])},x=(e,t)=>{m[t]===e&&delete m[t]},k=e=>(i.push(...rA(e,I)),iA(i.splice(0,e).map(e=>e.offerPromise.then(A).then(t=>({peer:e,offer:t}))))),T=(e,t)=>h?.({error:`incorrect password (${d.password}) when decrypting ${t}`,appId:p,peerId:e,roomId:u}),P=e=>async(t,r,n)=>{const[s,i]=await iA([b,w]);if(t!==s&&t!==i)return;const{peerId:o,offer:a,answer:c,peer:l}="string"==typeof r?bA(r):r;if(o!==sA&&!m[o])if(!o||a||c){if(a){const t=g[o]?.[e];if(t&&sA>o)return;const r=xA(!1,d);let s;r.setHandlers({connect(){return C(r,o,e)},close(){return x(r,o)}});try{s=await S(a)}catch{return void T(o,"offer")}if(r.isDead)return;const[i,c]=await iA([EA(mA(y,o)),r.signal(s)]);n(i,yA({peerId:sA,answer:await A(c)}))}else if(c){let t;try{t=await S(c)}catch(e){return void T(o,"answer")}if(l)l.setHandlers({connect(){return C(l,o,e)},close(){return x(l,o)}}),l.signal(t);else{const r=g[o]?.[e];r&&!r.isDead&&r.signal(t)}}}else{if(g[o]?.[e])return;const[[{peer:t,offer:r}],s]=await iA([k(1),EA(mA(y,o))]);g[o]||=[],g[o][e]=t,setTimeout(()=>((e,t)=>{if(m[e])return;const r=g[e]?.[t];r&&(delete g[e][t],r.destroy())})(o,e),.9*_[e]),t.setHandlers({connect(){return C(t,o,e)},close(){return x(t,o)}}),n(s,yA({peerId:sA,offer:r}))}};if(!p&&!d.firebaseApp)throw hA("config map is missing appId field");if(!u)throw hA("roomId argument required");if(!c){const t=e(l);i=rA(20,I),s=Array.isArray(t)?t:[t],c=!0,o=setInterval(()=>i=i.filter(e=>{const t=Date.now()-e.created<57333;return t||e.destroy(),t}),59052.99)}const _=s.map(()=>5333),R=[],L=s.map(async(e,r)=>t(await e,await b,await w,P(r),k));iA([b,w]).then(([e,t])=>{const n=async(s,i)=>{const o=await r(s,e,t);"number"==typeof o&&(_[i]=o),R[i]=setTimeout(()=>n(s,i),_[i])};L.forEach(async(e,t)=>{await e,n(await s[t],t)})});let D=uA;return n[p]||={},a++,n[p][u]=NA(e=>D=e,e=>delete m[e],()=>{delete n[p][u],R.forEach(clearTimeout),L.forEach(async e=>(await e)()),a--,a<=0&&(o&&(clearInterval(o),o=null),i?.forEach(e=>e.destroy()),i=[],s=null,c=!1)},f)}})({init(e){return async function(e={}){const t=await YS(e),r=new Ru(e,t,{store:!0,lightpush:!0,filter:!0});return!1!==e?.autoStart&&await r.start(),r}({defaultBootstrap:!1,pubsubTopics:[OA],bootstrapPeers:["/dns4/waku.myrandomdemos.online/tcp/8000/wss/p2p/16Uiu2HAmKfC2QUvMVyBsVjuEzdo1hVhRddZxo69YkBuXYvuZ83sc","/dns4/node-01.do-ams3.wakuv2.prod.status.im/tcp/8000/wss/p2p/16Uiu2HAmL5okWopX7NqZWBUKVqW8iUxCEmd5GMHLVPwCgzYzQv3e","/dns4/node-01.gc-us-central1-a.wakuv2.prod.statusim.net/tcp/8000/wss/p2p/16Uiu2HAmVkKntsECaYfefR1V2yCR79CegLATuTPE6B9TxgxBiiiA","/dns4/node-01.ac-cn-hongkong-c.wakuv2.prod.status.im/tcp/8000/wss/p2p/16Uiu2HAm4v86W3bmT1BiH6oSPzcsSr24iDQpSN5Qa992BCjjwgrD","/dns4/node-01.do-ams3.wakuv2.test.status.im/tcp/8000/wss/p2p/16Uiu2HAmPLe7Mzm8TsYUubgCAW1aJoeFScxrLj8ppHFivPo97bUZ"],libp2p:{peerDiscovery:[zS([OA])],hideWebSocketInfo:!0,...e.libp2pConfig}}).then(async e=>(await e.start(),await e.waitForPeers([Vn.LightPush,Vn.Filter]),e))},async subscribe(e,t,r,n){const s=await iA([t,r].map(t=>e.filter.subscribe(Kn(UA(t),OA),(t=>r=>{r.payload&&n(t,gA(r.payload),(t,r)=>FA(e,t,r))})(t))));return()=>s.forEach(e=>e())},announce(e,t){return FA(e,t,yA({peerId:sA}))}});export{BA as joinRoom,sA as selfId};