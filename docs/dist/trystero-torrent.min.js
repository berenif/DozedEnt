const e="Trystero",r=(e,r)=>Array(e).fill().map(r),t="0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",n=e=>{const a=(()=>{try{return"undefined"!=typeof globalThis&&globalThis.crypto&&"function"==typeof globalThis.crypto.getRandomValues?globalThis.crypto:null}catch(e){return null}})();if(a){const r=new Uint8Array(e);return a.getRandomValues(r),Array.from(r,e=>t[e%62]).join("")}const o=n.counter||0;n.counter=(o+1)%1e6;const s=Date.now()+o;return r(e,(e,r)=>t[Math.abs((s+1664525*r+1013904223)%62)%62]).join("")},a=n(20),o=Promise.all.bind(Promise),s="undefined"!=typeof window,{entries:i,fromEntries:c,keys:l}=Object,d=()=>{},u=r=>Error(`${e}: ${r}`),f=new TextEncoder,y=new TextDecoder,w=e=>f.encode(e),p=e=>y.decode(e),m=(...e)=>e.join("@"),g=JSON.stringify,h=JSON.parse,b={},k="AES-GCM",v={},T=async e=>v[e]||=Array.from(await(async(e,r)=>new Uint8Array(await crypto.subtle.digest(e,w(r))))("SHA-1",e)).map(e=>e.toString(36)).join(""),P=async(e,r)=>{const t=crypto.getRandomValues(new Uint8Array(16));return t.join(",")+"$"+(n=await crypto.subtle.encrypt({name:k,iv:t},await e,w(r)),btoa(String.fromCharCode.apply(null,new Uint8Array(n))));var n},A=async(e,r)=>{if(!r||"string"!=typeof r||!r.includes("$"))throw Error("Invalid encrypted data format");const[t,n]=r.split("$");if(!t||!n)throw Error("Missing IV or ciphertext in encrypted data");return p(await crypto.subtle.decrypt({name:k,iv:new Uint8Array(t.split(","))},await e,(e=>{const r=atob(e);return new Uint8Array(r.length).map((e,t)=>r.charCodeAt(t)).buffer})(n)))},S="icegatheringstatechange",E="offer";var $=(e,{rtcConfig:r,rtcPolyfill:t,turnConfig:n})=>{const a=new(t||RTCPeerConnection)({iceServers:D.concat(n||[]),...r}),s={};let i=!1,c=!1,l=null;const d=e=>{e.binaryType="arraybuffer",e.bufferedAmountLowThreshold=65535,e.onmessage=e=>s.data?.(e.data),e.onopen=()=>s.connect?.(),e.onclose=()=>s.close?.(),e.onerror=e=>s.error?.(e)},u=e=>Promise.race([new Promise(r=>{const t=()=>{"complete"===e.iceGatheringState&&(e.removeEventListener(S,t),r())};e.addEventListener(S,t),t()}),new Promise(e=>setTimeout(e,5e3))]).then(()=>({type:e.localDescription.type,sdp:e.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")}));return e?(l=a.createDataChannel("data"),d(l)):a.ondatachannel=({channel:e})=>{l=e,d(e)},a.onnegotiationneeded=async()=>{try{i=!0,await a.setLocalDescription();const e=await u(a);s.signal?.(e)}catch(e){s.error?.(e)}finally{i=!1}},a.onconnectionstatechange=()=>{["disconnected","failed","closed"].includes(a.connectionState)&&s.close?.()},a.ontrack=e=>{s.track?.(e.track,e.streams[0]),s.stream?.(e.streams[0])},a.onremovestream=e=>s.stream?.(e.stream),e&&(a.canTrickleIceCandidates||a.onnegotiationneeded()),{created:Date.now(),connection:a,get channel(){return l},get isDead(){return"closed"===a.connectionState},async signal(r){if("open"!==l?.readyState||r.sdp?.includes("a=rtpmap"))try{if(r.type===E){if(i||"stable"!==a.signalingState&&!c){if(e)return;await o([a.setLocalDescription({type:"rollback"}),a.setRemoteDescription(r)])}else await a.setRemoteDescription(r);await a.setLocalDescription();const t=await u(a);return s.signal?.(t),t}if("answer"===r.type){c=!0;try{await a.setRemoteDescription(r)}finally{c=!1}}}catch(e){s.error?.(e)}},sendData(e){if(!l||"open"!==l.readyState)throw Error("Data channel is not available or not open");l.send(e)},destroy(){l?.close(),a.close(),i=!1,c=!1},setHandlers(e){return Object.assign(s,e)},offerPromise:e?new Promise(e=>s.signal=r=>{r.type===E&&e(r)}):Promise.resolve(),addStream(e){return e.getTracks().forEach(r=>a.addTrack(r,e))},removeStream(e){return a.getSenders().filter(r=>e.getTracks().includes(r.track)).forEach(e=>a.removeTrack(e))},addTrack(e,r){return a.addTrack(e,r)},removeTrack(e){const r=a.getSenders().find(r=>r.track===e);r&&a.removeTrack(r)},replaceTrack(e,r){const t=a.getSenders().find(r=>r.track===e);if(t)return t.replaceTrack(r)}}};const D=[...r(3,(e,r)=>`stun:stun${r||""}.l.google.com:19302`),"stun:stun.cloudflare.com:3478"].map(e=>({urls:e})),I=["none","error","warn","info","debug"],L=(e={})=>{const{level:r="warn",prefix:t="Trystero"}=e||{},n=I.includes(r)?I.indexOf(r):I.indexOf("warn"),a=e=>I.indexOf(e)<=n&&n>0,o=e=>`[${t}:${e}]`;return{error(...e){return a("error")&&console.error(o("error"),...e)},warn(...e){return a("warn")&&console.warn(o("warn"),...e)},info(){return a("info")&&void 0},debug(...e){return a("debug")&&console.debug(o("debug"),...e)}}},C=Object.getPrototypeOf(Uint8Array),U=16369,_=255,O="bufferedamountlow",R=e=>"@_"+e;var j=(t,n,a,f)=>{const y=f||L({level:"none"}),m={},b={},k={},v={},T={},P={},A={},S={onPeerJoin:d,onPeerLeave:d,onPeerStream:d,onPeerTrack:d},E=(r,t)=>(r?Array.isArray(r)?r:[r]:l(m)).flatMap(r=>{const n=m[r];return n?t(r,n):(y.warn(`${e}: no peer with id ${r} found`),[])}),$=e=>{m[e]&&(m[e].destroy(),delete m[e],delete v[e],delete T[e],S.onPeerLeave(e),n(e))},D=e=>{if(b[e])return k[e];if(!e)throw u("action type argument is required");const t=w(e);if(t.byteLength>12)throw u(`action type string "${e}" (${t.byteLength}b) exceeds byte limit (12). Hint: choose a shorter name.`);const n=new Uint8Array(12);n.set(t);let a=0;return b[e]={onComplete:d,onProgress:d,setOnComplete(r){return b[e]={...b[e],onComplete:r}},setOnProgress(r){return b[e]={...b[e],onProgress:r}},async send(e,t,s,i){if(s&&"object"!=typeof s)throw u("action meta argument must be an object");const c=typeof e;if("undefined"===c)throw u("action data cannot be undefined");const l="string"!==c,d=e instanceof Blob,f=d||e instanceof ArrayBuffer||e instanceof C;if(s&&!f)throw u("action meta argument can only be used with binary data");const y=f?new Uint8Array(d?await e.arrayBuffer():e):w(l?g(e):e),p=s?w(g(s)):null,h=Math.ceil(y.byteLength/U)+(s?1:0)||1,b=r(h,(e,r)=>{const t=r===h-1,o=s&&0===r,i=new Uint8Array(15+(o?p.byteLength:t?y.byteLength-U*(h-(s?2:1)):U));return i.set(n),i.set([a],12),i.set([t|o<<1|f<<2|l<<3],13),i.set([Math.round((r+1)/h*_)],14),i.set(s?o?p:y.subarray((r-1)*U,r*U):y.subarray(r*U,(r+1)*U),15),i});return a=a+1&_,o(E(t,async(e,r)=>{const{channel:t}=r;let n=0;for(;n<h;){const a=b[n];if(t.bufferedAmount>t.bufferedAmountLowThreshold&&await new Promise(e=>{const r=()=>{t.removeEventListener(O,r),e()};t.addEventListener(O,r)}),!m[e])break;r.sendData(a),n++,i?.(a[14]/_,e,s)}}))}},k[e]||=[b[e].send,b[e].setOnComplete,b[e].setOnProgress]},I=async()=>{await G(""),await new Promise(e=>setTimeout(e,99)),i(m).forEach(([e,r])=>{r.destroy(),delete m[e]}),a()},[j,x]=D(R("ping")),[M,H]=D(R("pong")),[J,V]=D(R("signal")),[q,B]=D(R("stream")),[W,z]=D(R("track")),[G,N]=D(R("leave"));return t((r,t)=>{m[t]||(m[t]=r,r.setHandlers({data(r){return((r,t)=>{const n=new Uint8Array(t),a=p(n.subarray(0,12)).replaceAll("\0",""),[o]=n.subarray(12,13),[s]=n.subarray(13,14),[i]=n.subarray(14,15),c=n.subarray(15),l=!!(1&s),d=!!(2&s),u=!!(4&s),f=!!(8&s);if(!b[a])return void console.warn(`${e}: received message with unregistered type (${a})`);if(!m[r])return;v[r]||={},v[r][a]||={};const y=v[r][a][o]||={chunks:[]};if(d?y.meta=h(p(c)):y.chunks.push(c),b[a].onProgress(i/_,r,y.meta),!l)return;const w=new Uint8Array(y.chunks.reduce((e,r)=>e+r.byteLength,0));if(y.chunks.reduce((e,r)=>(w.set(r,e),e+r.byteLength),0),v[r]?.[a]&&delete v[r][a][o],u)b[a].onComplete(w,r,y.meta);else{const e=p(w);b[a].onComplete(f?h(e):e,r)}})(t,r)},stream(e){S.onPeerStream(e,t,P[t]),delete P[t]},track(e,r){S.onPeerTrack(e,r,t,A[t]),delete A[t]},signal(e){return J(e,t)},close(){return $(t)},error(e){y.error(e),$(t)}}),S.onPeerJoin(t))}),x((e,r)=>M("",r)),H((e,r)=>{T[r]?.(),delete T[r]}),V((e,r)=>m[r]?.signal(e)),B((e,r)=>P[r]=e),z((e,r)=>A[r]=e),N((e,r)=>$(r)),s&&addEventListener("beforeunload",I),{makeAction:D,leave:I,async ping(e){if(!e)throw u("ping() must be called with target peer ID");const r=Date.now();return j("",e),await new Promise(r=>T[e]=r),Date.now()-r},getPeers(){return c(i(m).map(([e,r])=>[e,r.connection]))},addStream(e,r,t){return E(r,async(r,n)=>{t&&await q(t,r),n.addStream(e)})},removeStream(e,r){return E(r,(r,t)=>t.removeStream(e))},addTrack(e,r,t,n){return E(t,async(t,a)=>{n&&await W(n,t),a.addTrack(e,r)})},removeTrack(e,r){return E(r,(r,t)=>t.removeTrack(e))},replaceTrack(e,r,t,n){return E(t,async(t,a)=>{n&&await W(n,t),a.replaceTrack(e,r)})},onPeerJoin(e){return S.onPeerJoin=e},onPeerLeave(e){return S.onPeerLeave=e},onPeerStream(e){return S.onPeerStream=e},onPeerTrack(e){return S.onPeerTrack=e}}};const x={},M={},H={},J={},V={},q={},B={},W={},z=async e=>{if(M[e])return M[e];const r=(await T(e)).slice(0,20);return M[e]=r,H[r]=e,r},G=async(e,r,t)=>e.send(g({action:"announce",info_hash:await z(r),peer_id:a,...t})),N=(r,t,n)=>console.warn(`${e}: torrent tracker ${n?"failure":"warning"} from ${r} - ${t}`),K=(({init:t,subscribe:n,announce:s})=>{const i={};let c,l,f,y=0,p=!1;return(b,v,S)=>{const E=(e=>{if(!e)throw u("requires a config map as the first argument");const r={...e};return r.logger=L(e.logger),r.rtcConfig||={},r})(b),{appId:D,logger:I}=E;if(i[D]?.[v])return i[D][v];const C={},U={},_=m(e,D,v),O=T(_),R=T(m(_,a)),x=(async(e,r,t)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},w(`${e}:${r}:${t}`)),{name:k},!1,["encrypt","decrypt"]))(E.password||"",D,v),M=e=>async r=>({type:r.type,sdp:await e(x,r.sdp)}),H=M(A),J=M(P),V=()=>$(!0,E),q=(e,r,t)=>{U[r]?U[r]!==e&&e.destroy():(U[r]=e,Q(e,r),C[r]?.forEach((e,r)=>{r!==t&&e.destroy()}),delete C[r])},B=(e,r)=>{U[r]===e&&delete U[r]},W=e=>(l.push(...r(e,V)),o(l.splice(0,e).map(e=>e.offerPromise.then(J).then(r=>({peer:e,offer:r}))))),z=(e,r)=>S?.({error:`incorrect password (${E.password}) when decrypting ${r}`,appId:D,peerId:e,roomId:v}),G=e=>async(r,t,n)=>{const[s,i]=await o([O,R]);if(r!==s&&r!==i)return;const{peerId:c,offer:l,answer:d,peer:u}="string"==typeof t?h(t):t;if(c!==a&&!U[c])if(!c||l||d){if(l){const r=C[c]?.[e];if(r&&a>c)return;const t=$(!1,E);let s;t.setHandlers({connect(){return q(t,c,e)},close(){return B(t,c)}});try{s=await H(l)}catch{return void z(c,"offer")}if(t.isDead)return;const[i,d]=await o([T(m(_,c)),t.signal(s)]);n(i,g({peerId:a,answer:await J(d)}))}else if(d){let r;try{r=await H(d)}catch(e){return void z(c,"answer")}if(u)u.setHandlers({connect(){return q(u,c,e)},close(){return B(u,c)}}),u.signal(r);else{const t=C[c]?.[e];t&&!t.isDead&&t.signal(r)}}}else{if(C[c]?.[e])return;const[[{peer:r,offer:t}],s]=await o([W(1),T(m(_,c))]);C[c]||=[],C[c][e]=r,setTimeout(()=>((e,r)=>{if(U[e])return;const t=C[e]?.[r];t&&(delete C[e][r],t.destroy())})(c,e),.9*N[e]),r.setHandlers({connect(){return q(r,c,e)},close(){return B(r,c)}}),n(s,g({peerId:a,offer:t}))}};if(!D&&!E.firebaseApp)throw u("config map is missing appId field");if(!v)throw u("roomId argument required");if(!p){const e=t(b);l=r(20,V),c=Array.isArray(e)?e:[e],p=!0,f=setInterval(()=>l=l.filter(e=>{const r=Date.now()-e.created<57333;return r||e.destroy(),r}),59052.99)}const N=c.map(()=>5333),K=[],F=c.map(async(e,r)=>{try{const t=await e;if(!t)throw Error("relay not available");return n(t,await O,await R,G(r),W)}catch(e){return I?.warn?.(`Relay #${r} failed to initialize: ${e?.message||e}`),()=>{}}});o([O,R]).then(([e,r])=>{const t=async(n,a)=>{const o=await s(n,e,r);"number"==typeof o&&(N[a]=o),K[a]=setTimeout(()=>t(n,a),N[a])};F.forEach(async(e,r)=>{try{await e;const n=await c[r].catch(()=>null);n&&t(n,r)}catch{}})});let Q=d;return i[D]||={},y++,i[D][v]=j(e=>Q=e,e=>delete U[e],()=>{delete i[D][v],K.forEach(clearTimeout),F.forEach(async e=>(await e)()),y--,y<=0&&(f&&(clearInterval(f),f=null),l?.forEach(e=>e.destroy()),l=[],c=null,p=!1)},I)}})({init(e){return((e,r,t)=>(e.relayUrls||r).slice(0,e.relayUrls?e.relayUrls.length:e.relayRedundancy||t))(e,X,3).map(e=>{const r=((e,r)=>{const t={},n=()=>{const a=new WebSocket(e);a.onclose=()=>{b[e]??=3333,setTimeout(n,b[e]),b[e]*=2},a.onmessage=e=>r(e.data),t.socket=a,t.url=a.url,t.ready=new Promise(r=>a.onopen=()=>{r(t),b[e]=3333}),t.send=e=>{1===a.readyState&&a.send(e)}};return n(),t})(e,e=>{const r=h(e),n=r["failure reason"],a=r["warning message"],{interval:o}=r,s=H[r.info_hash];if(n)return N(t,n,!0),void("undefined"!=typeof window&&(window.showWebTorrentError&&window.showWebTorrentError(t,n),window.gameDebug&&window.gameDebug.networkErrorRecovery&&window.gameDebug.networkErrorRecovery.handleConnectionError(Error(`Tracker ${t} failed: ${n}`),{networkManager:window.networkManager,provider:"torrent",tracker:t})));if(a&&N(t,a),o&&1e3*o>q[t]&&V[t][s]){const e=Math.min(1e3*o,120333);clearInterval(J[t][s]),q[t]=e,J[t][s]=setInterval(V[t][s],e)}B[r.offer_id]||(r.offer||r.answer)&&(B[r.offer_id]=!0,W[t][s]?.(r))}),{url:t}=r;return x[t]=r,W[t]={},r.ready})},subscribe(e,r,t,a,o){const{url:s}=e,l=async()=>{const t=c((await o(10)).map(e=>[n(20),e]));W[e.url][r]=n=>{if(n.offer)a(r,{offer:n.offer,peerId:n.peer_id},(t,a)=>G(e,r,{answer:h(a).answer,offer_id:n.offer_id,to_peer_id:n.peer_id}));else if(n.answer){const e=t[n.offer_id];e&&a(r,{answer:n.answer,peerId:n.peer_id,peer:e.peer})}},G(e,r,{numwant:10,offers:i(t).map(([e,{offer:r}])=>({offer_id:e,offer:r}))})};return q[s]=33333,V[s]||={},V[s][r]=l,J[s]||={},J[s][r]=setInterval(l,q[s]),l(),()=>{clearInterval(J[s][r]),delete W[s][r],delete V[s][r]}},announce(e){return q[e.url]}}),F=(Q=x,()=>c(i(Q).map(([e,r])=>[e,r.socket])));var Q;const X=["tracker.openwebtorrent.com","tracker.files.fm:7073/announce","tracker.webtorrent.dev","tracker.btorrent.xyz"].map(e=>"wss://"+e);export{X as defaultRelayUrls,F as getRelaySockets,K as joinRoom,a as selfId};