const{floor:e,random:r}=Math,t="Trystero",n=(e,r)=>Array(e).fill().map(r),a="0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",o=t=>n(t,()=>a[e(62*r())]).join(""),s=o(20),i=Promise.all.bind(Promise),c="undefined"!=typeof window,{entries:l,fromEntries:d,keys:u}=Object,f=()=>{},p=e=>Error(`${t}: ${e}`),y=new TextEncoder,m=new TextDecoder,w=e=>y.encode(e),g=e=>m.decode(e),h=(...e)=>e.join("@"),b=JSON.stringify,v=JSON.parse,k={},P="AES-GCM",T={},S=async e=>T[e]||=Array.from(await(async(e,r)=>new Uint8Array(await crypto.subtle.digest(e,w(r))))("SHA-1",e)).map(e=>e.toString(36)).join(""),A=async(e,r)=>{const t=crypto.getRandomValues(new Uint8Array(16));return t.join(",")+"$"+(n=await crypto.subtle.encrypt({name:P,iv:t},await e,w(r)),btoa(String.fromCharCode.apply(null,new Uint8Array(n))));var n},$=async(e,r)=>{if(!r||"string"!=typeof r||!r.includes("$"))throw Error("Invalid encrypted data format");const[t,n]=r.split("$");if(!t||!n)throw Error("Missing IV or ciphertext in encrypted data");return g(await crypto.subtle.decrypt({name:P,iv:new Uint8Array(t.split(","))},await e,(e=>{const r=atob(e);return new Uint8Array(r.length).map((e,t)=>r.charCodeAt(t)).buffer})(n)))},D="icegatheringstatechange",I="offer";var L=(e,{rtcConfig:r,rtcPolyfill:t,turnConfig:n})=>{const a=new(t||RTCPeerConnection)({iceServers:E.concat(n||[]),...r}),o={};let s=!1,c=!1,l=null;const d=e=>{e.binaryType="arraybuffer",e.bufferedAmountLowThreshold=65535,e.onmessage=e=>o.data?.(e.data),e.onopen=()=>o.connect?.(),e.onclose=()=>o.close?.(),e.onerror=e=>o.error?.(e)},u=e=>Promise.race([new Promise(r=>{const t=()=>{"complete"===e.iceGatheringState&&(e.removeEventListener(D,t),r())};e.addEventListener(D,t),t()}),new Promise(e=>setTimeout(e,5e3))]).then(()=>({type:e.localDescription.type,sdp:e.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")}));return e?(l=a.createDataChannel("data"),d(l)):a.ondatachannel=({channel:e})=>{l=e,d(e)},a.onnegotiationneeded=async()=>{try{s=!0,await a.setLocalDescription();const e=await u(a);o.signal?.(e)}catch(e){o.error?.(e)}finally{s=!1}},a.onconnectionstatechange=()=>{["disconnected","failed","closed"].includes(a.connectionState)&&o.close?.()},a.ontrack=e=>{o.track?.(e.track,e.streams[0]),o.stream?.(e.streams[0])},a.onremovestream=e=>o.stream?.(e.stream),e&&(a.canTrickleIceCandidates||a.onnegotiationneeded()),{created:Date.now(),connection:a,get channel(){return l},get isDead(){return"closed"===a.connectionState},async signal(r){if("open"!==l?.readyState||r.sdp?.includes("a=rtpmap"))try{if(r.type===I){if(s||"stable"!==a.signalingState&&!c){if(e)return;await i([a.setLocalDescription({type:"rollback"}),a.setRemoteDescription(r)])}else await a.setRemoteDescription(r);await a.setLocalDescription();const t=await u(a);return o.signal?.(t),t}if("answer"===r.type){c=!0;try{await a.setRemoteDescription(r)}finally{c=!1}}}catch(e){o.error?.(e)}},sendData(e){if(!l||"open"!==l.readyState)throw Error("Data channel is not available or not open");l.send(e)},destroy(){l?.close(),a.close(),s=!1,c=!1},setHandlers(e){return Object.assign(o,e)},offerPromise:e?new Promise(e=>o.signal=r=>{r.type===I&&e(r)}):Promise.resolve(),addStream(e){return e.getTracks().forEach(r=>a.addTrack(r,e))},removeStream(e){return a.getSenders().filter(r=>e.getTracks().includes(r.track)).forEach(e=>a.removeTrack(e))},addTrack(e,r){return a.addTrack(e,r)},removeTrack(e){const r=a.getSenders().find(r=>r.track===e);r&&a.removeTrack(r)},replaceTrack(e,r){const t=a.getSenders().find(r=>r.track===e);if(t)return t.replaceTrack(r)}}};const E=[...n(3,(e,r)=>`stun:stun${r||""}.l.google.com:19302`),"stun:stun.cloudflare.com:3478"].map(e=>({urls:e})),C=["none","error","warn","info","debug"],U=(e={})=>{const{level:r="warn",prefix:t="Trystero"}=e||{},n=C.includes(r)?C.indexOf(r):C.indexOf("warn"),a=e=>C.indexOf(e)<=n&&n>0,o=e=>`[${t}:${e}]`;return{error(...e){return a("error")&&console.error(o("error"),...e)},warn(...e){return a("warn")&&console.warn(o("warn"),...e)},info(){return a("info")&&void 0},debug(...e){return a("debug")&&console.debug(o("debug"),...e)}}},_=Object.getPrototypeOf(Uint8Array),O=16369,x=255,j="bufferedamountlow",H=e=>"@_"+e;var M=(e,r,a,o)=>{const s=o||U({level:"none"}),y={},m={},h={},k={},P={},T={},S={},A={onPeerJoin:f,onPeerLeave:f,onPeerStream:f,onPeerTrack:f},$=(e,r)=>(e?Array.isArray(e)?e:[e]:u(y)).flatMap(e=>{const n=y[e];return n?r(e,n):(s.warn(`${t}: no peer with id ${e} found`),[])}),D=e=>{y[e]&&(y[e].destroy(),delete y[e],delete k[e],delete P[e],A.onPeerLeave(e),r(e))},I=e=>{if(m[e])return h[e];if(!e)throw p("action type argument is required");const r=w(e);if(r.byteLength>12)throw p(`action type string "${e}" (${r.byteLength}b) exceeds byte limit (12). Hint: choose a shorter name.`);const t=new Uint8Array(12);t.set(r);let a=0;return m[e]={onComplete:f,onProgress:f,setOnComplete(r){return m[e]={...m[e],onComplete:r}},setOnProgress(r){return m[e]={...m[e],onProgress:r}},async send(e,r,o,s){if(o&&"object"!=typeof o)throw p("action meta argument must be an object");const c=typeof e;if("undefined"===c)throw p("action data cannot be undefined");const l="string"!==c,d=e instanceof Blob,u=d||e instanceof ArrayBuffer||e instanceof _;if(o&&!u)throw p("action meta argument can only be used with binary data");const f=u?new Uint8Array(d?await e.arrayBuffer():e):w(l?b(e):e),m=o?w(b(o)):null,g=Math.ceil(f.byteLength/O)+(o?1:0)||1,h=n(g,(e,r)=>{const n=r===g-1,s=o&&0===r,i=new Uint8Array(15+(s?m.byteLength:n?f.byteLength-O*(g-(o?2:1)):O));return i.set(t),i.set([a],12),i.set([n|s<<1|u<<2|l<<3],13),i.set([Math.round((r+1)/g*x)],14),i.set(o?s?m:f.subarray((r-1)*O,r*O):f.subarray(r*O,(r+1)*O),15),i});return a=a+1&x,i($(r,async(e,r)=>{const{channel:t}=r;let n=0;for(;n<g;){const a=h[n];if(t.bufferedAmount>t.bufferedAmountLowThreshold&&await new Promise(e=>{const r=()=>{t.removeEventListener(j,r),e()};t.addEventListener(j,r)}),!y[e])break;r.sendData(a),n++,s?.(a[14]/x,e,o)}}))}},h[e]||=[m[e].send,m[e].setOnComplete,m[e].setOnProgress]},L=async()=>{await z(""),await new Promise(e=>setTimeout(e,99)),l(y).forEach(([e,r])=>{r.destroy(),delete y[e]}),a()},[E,C]=I(H("ping")),[M,J]=I(H("pong")),[R,q]=I(H("signal")),[B,G]=I(H("stream")),[N,V]=I(H("track")),[z,K]=I(H("leave"));return e((e,r)=>{y[r]||(y[r]=e,e.setHandlers({data(e){return((e,r)=>{const n=new Uint8Array(r),a=g(n.subarray(0,12)).replaceAll("\0",""),[o]=n.subarray(12,13),[s]=n.subarray(13,14),[i]=n.subarray(14,15),c=n.subarray(15),l=!!(1&s),d=!!(2&s),u=!!(4&s),f=!!(8&s);if(!m[a])return void console.warn(`${t}: received message with unregistered type (${a})`);if(!y[e])return;k[e]||={},k[e][a]||={};const p=k[e][a][o]||={chunks:[]};if(d?p.meta=v(g(c)):p.chunks.push(c),m[a].onProgress(i/x,e,p.meta),!l)return;const w=new Uint8Array(p.chunks.reduce((e,r)=>e+r.byteLength,0));if(p.chunks.reduce((e,r)=>(w.set(r,e),e+r.byteLength),0),k[e]?.[a]&&delete k[e][a][o],u)m[a].onComplete(w,e,p.meta);else{const r=g(w);m[a].onComplete(f?v(r):r,e)}})(r,e)},stream(e){A.onPeerStream(e,r,T[r]),delete T[r]},track(e,t){A.onPeerTrack(e,t,r,S[r]),delete S[r]},signal(e){return R(e,r)},close(){return D(r)},error(e){s.error(e),D(r)}}),A.onPeerJoin(r))}),C((e,r)=>M("",r)),J((e,r)=>{P[r]?.(),delete P[r]}),q((e,r)=>y[r]?.signal(e)),G((e,r)=>T[r]=e),V((e,r)=>S[r]=e),K((e,r)=>D(r)),c&&addEventListener("beforeunload",L),{makeAction:I,leave:L,async ping(e){if(!e)throw p("ping() must be called with target peer ID");const r=Date.now();return E("",e),await new Promise(r=>P[e]=r),Date.now()-r},getPeers(){return d(l(y).map(([e,r])=>[e,r.connection]))},addStream(e,r,t){return $(r,async(r,n)=>{t&&await B(t,r),n.addStream(e)})},removeStream(e,r){return $(r,(r,t)=>t.removeStream(e))},addTrack(e,r,t,n){return $(t,async(t,a)=>{n&&await N(n,t),a.addTrack(e,r)})},removeTrack(e,r){return $(r,(r,t)=>t.removeTrack(e))},replaceTrack(e,r,t,n){return $(t,async(t,a)=>{n&&await N(n,t),a.replaceTrack(e,r)})},onPeerJoin(e){return A.onPeerJoin=e},onPeerLeave(e){return A.onPeerLeave=e},onPeerStream(e){return A.onPeerStream=e},onPeerTrack(e){return A.onPeerTrack=e}}};const J={},R={},q={},B={},G={},N={},V={},z={},K=async e=>{if(R[e])return R[e];const r=(await S(e)).slice(0,20);return R[e]=r,q[r]=e,r},W=async(e,r,t)=>e.send(b({action:"announce",info_hash:await K(r),peer_id:s,...t})),F=(e,r,n)=>console.warn(`${t}: torrent tracker ${n?"failure":"warning"} from ${e} - ${r}`),Q=(({init:e,subscribe:r,announce:a})=>{const o={};let c,l,d,u=0,y=!1;return(m,g,k)=>{const T=(e=>{if(!e)throw p("requires a config map as the first argument");const r={...e};return r.logger=U(e.logger),r.rtcConfig||={},r})(m),{appId:D,logger:I}=T;if(o[D]?.[g])return o[D][g];const E={},C={},_=h(t,D,g),O=S(_),x=S(h(_,s)),j=(async(e,r,t)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},w(`${e}:${r}:${t}`)),{name:P},!1,["encrypt","decrypt"]))(T.password||"",D,g),H=e=>async r=>({type:r.type,sdp:await e(j,r.sdp)}),J=H($),R=H(A),q=()=>L(!0,T),B=(e,r,t)=>{C[r]?C[r]!==e&&e.destroy():(C[r]=e,Q(e,r),E[r]?.forEach((e,r)=>{r!==t&&e.destroy()}),delete E[r])},G=(e,r)=>{C[r]===e&&delete C[r]},N=e=>(l.push(...n(e,q)),i(l.splice(0,e).map(e=>e.offerPromise.then(R).then(r=>({peer:e,offer:r}))))),V=(e,r)=>k?.({error:`incorrect password (${T.password}) when decrypting ${r}`,appId:D,peerId:e,roomId:g}),z=e=>async(r,t,n)=>{const[a,o]=await i([O,x]);if(r!==a&&r!==o)return;const{peerId:c,offer:l,answer:d,peer:u}="string"==typeof t?v(t):t;if(c!==s&&!C[c])if(!c||l||d){if(l){const r=E[c]?.[e];if(r&&s>c)return;const t=L(!1,T);let a;t.setHandlers({connect(){return B(t,c,e)},close(){return G(t,c)}});try{a=await J(l)}catch{return void V(c,"offer")}if(t.isDead)return;const[o,d]=await i([S(h(_,c)),t.signal(a)]);n(o,b({peerId:s,answer:await R(d)}))}else if(d){let r;try{r=await J(d)}catch(e){return void V(c,"answer")}if(u)u.setHandlers({connect(){return B(u,c,e)},close(){return G(u,c)}}),u.signal(r);else{const t=E[c]?.[e];t&&!t.isDead&&t.signal(r)}}}else{if(E[c]?.[e])return;const[[{peer:r,offer:t}],a]=await i([N(1),S(h(_,c))]);E[c]||=[],E[c][e]=r,setTimeout(()=>((e,r)=>{if(C[e])return;const t=E[e]?.[r];t&&(delete E[e][r],t.destroy())})(c,e),.9*K[e]),r.setHandlers({connect(){return B(r,c,e)},close(){return G(r,c)}}),n(a,b({peerId:s,offer:t}))}};if(!D&&!T.firebaseApp)throw p("config map is missing appId field");if(!g)throw p("roomId argument required");if(!y){const r=e(m);l=n(20,q),c=Array.isArray(r)?r:[r],y=!0,d=setInterval(()=>l=l.filter(e=>{const r=Date.now()-e.created<57333;return r||e.destroy(),r}),59052.99)}const K=c.map(()=>5333),W=[],F=c.map(async(e,t)=>r(await e,await O,await x,z(t),N));i([O,x]).then(([e,r])=>{const t=async(n,o)=>{const s=await a(n,e,r);"number"==typeof s&&(K[o]=s),W[o]=setTimeout(()=>t(n,o),K[o])};F.forEach(async(e,r)=>{await e,t(await c[r],r)})});let Q=f;return o[D]||={},u++,o[D][g]=M(e=>Q=e,e=>delete C[e],()=>{delete o[D][g],W.forEach(clearTimeout),F.forEach(async e=>(await e)()),u--,u<=0&&(d&&(clearInterval(d),d=null),l?.forEach(e=>e.destroy()),l=[],c=null,y=!1)},I)}})({init(e){return((e,r,t)=>(e.relayUrls||r).slice(0,e.relayUrls?e.relayUrls.length:e.relayRedundancy||t))(e,Z,3).map(e=>{const r=((e,r)=>{const t={},n=()=>{const a=new WebSocket(e);a.onclose=()=>{k[e]??=3333,setTimeout(n,k[e]),k[e]*=2},a.onmessage=e=>r(e.data),t.socket=a,t.url=a.url,t.ready=new Promise(r=>a.onopen=()=>{r(t),k[e]=3333}),t.send=e=>{1===a.readyState&&a.send(e)}};return n(),t})(e,e=>{const r=v(e),n=r["failure reason"],a=r["warning message"],{interval:o}=r,s=q[r.info_hash];if(n)F(t,n,!0);else{if(a&&F(t,a),o&&1e3*o>N[t]&&G[t][s]){const e=Math.min(1e3*o,120333);clearInterval(B[t][s]),N[t]=e,B[t][s]=setInterval(G[t][s],e)}V[r.offer_id]||(r.offer||r.answer)&&(V[r.offer_id]=!0,z[t][s]?.(r))}}),{url:t}=r;return J[t]=r,z[t]={},r.ready})},subscribe(e,r,t,n,a){const{url:s}=e,i=async()=>{const t=d((await a(10)).map(e=>[o(20),e]));z[e.url][r]=a=>{if(a.offer)n(r,{offer:a.offer,peerId:a.peer_id},(t,n)=>W(e,r,{answer:v(n).answer,offer_id:a.offer_id,to_peer_id:a.peer_id}));else if(a.answer){const e=t[a.offer_id];e&&n(r,{answer:a.answer,peerId:a.peer_id,peer:e.peer})}},W(e,r,{numwant:10,offers:l(t).map(([e,{offer:r}])=>({offer_id:e,offer:r}))})};return N[s]=33333,G[s]||={},G[s][r]=i,B[s]||={},B[s][r]=setInterval(i,N[s]),i(),()=>{clearInterval(B[s][r]),delete z[s][r],delete G[s][r]}},announce(e){return N[e.url]}}),X=(Y=J,()=>d(l(Y).map(([e,r])=>[e,r.socket])));var Y;const Z=["tracker.webtorrent.dev","tracker.openwebtorrent.com","tracker.btorrent.xyz","tracker.files.fm:7073/announce"].map(e=>"wss://"+e);export{Z as defaultRelayUrls,X as getRelaySockets,Q as joinRoom,s as selfId};